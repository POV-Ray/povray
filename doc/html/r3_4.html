<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2009-2011  -->

<html lang="en">
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Reference Section 4</title>
<link rel="StyleSheet" href="povray.css" type="text/css">
<link rel="shortcut icon" href="favicon.ico">

<!--  NOTE: In order to help users find information about POV-Ray using web      -->
<!--  search engines, we ask that you *not* let them index documentation         -->
<!--  mirrors because effectively, when searching, users will get hundreds of    -->
<!--  results containing the same information! For this reason, these meta tags  -->
<!--  below disable archiving of this page by search engines.                    -->

<meta name="robots" content="noarchive">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="expires" content="0">
</head>
<body>

<div class="Page">

<!-- NavPanel Begin -->
<div class="NavPanel">
<table class="NavTable">
<tr>
  <td class="FixedPanelHeading"><a title="3.4" href="#r3_4">Scene File Basics</a></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.1" href="#r3_4_1">Global Settings</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.1" href="#r3_4_1_1">ADC_Bailout</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.2" href="#r3_4_1_2">Ambient_Light</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.3" href="#r3_4_1_3">Assumed_Gamma</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.4" href="#r3_4_1_4">HF_Gray_16</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.5" href="#r3_4_1_5">Irid_Wavelength</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.6" href="#r3_4_1_6">Charset</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.7" href="#r3_4_1_7">Max_Trace_Level</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.8" href="#r3_4_1_8">Max_Intersections</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.9" href="#r3_4_1_9">Mm_Per_Unit</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.10" href="#r3_4_1_10">Number_Of_Waves</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.11" href="#r3_4_1_11">Noise_generator</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.1.12" href="#r3_4_1_12">Subsurface</a></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.2" href="#r3_4_2">Camera</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.1" href="#r3_4_2_1">Placing the Camera</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.1.1" href="#r3_4_2_1_1">Location and Look_At</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.1.2" href="#r3_4_2_1_2">The Sky Vector</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.1.3" href="#r3_4_2_1_3">Angles</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.1.4" href="#r3_4_2_1_4">The Direction Vector</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.1.5" href="#r3_4_2_1_5">Up and Right Vectors</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.1.6" href="#r3_4_2_1_6">Aspect Ratio</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.1.7" href="#r3_4_2_1_7">Handedness</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.1.8" href="#r3_4_2_1_8">Transforming the Camera</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.2" href="#r3_4_2_2">Types of Projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.1" href="#r3_4_2_2_1">Perspective projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.2" href="#r3_4_2_2_2">Orthographic projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.3" href="#r3_4_2_2_3">Mesh projection</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.2.2.3.1" href="#r3_4_2_2_3_1">Rays Per Pixel</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.2.2.3.2" href="#r3_4_2_2_3_2">Distribution Type</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.2.2.3.3" href="#r3_4_2_2_3_3">Max Distance</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.2.2.3.4" href="#r3_4_2_2_3_4">Mesh Object</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.2.2.3.5" href="#r3_4_2_2_3_5">About the Location Vector</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.2.2.3.6" href="#r3_4_2_2_3_6">About the Direction Vector</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.2.2.3.7" href="#r3_4_2_2_3_7">The Smooth Modifier</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.4" href="#r3_4_2_2_4">Fisheye projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.5" href="#r3_4_2_2_5">Ultra wide angle projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.6" href="#r3_4_2_2_6">Omnimax projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.7" href="#r3_4_2_2_7">Panoramic projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.8" href="#r3_4_2_2_8">Cylindrical projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.9" href="#r3_4_2_2_9">Spherical projection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.2.2.10" href="#r3_4_2_2_10">User defined projection</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.3" href="#r3_4_2_3">Focal Blur</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.4" href="#r3_4_2_4">Camera Ray Perturbation</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.2.5" href="#r3_4_2_5">Camera Identifiers</a></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.4.3" href="#r3_4_3">Lighting Types</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.3.1" href="#r3_4_3_1">Light Source</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.1" href="#r3_4_3_1_1">Point Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.2" href="#r3_4_3_1_2">Spotlights</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.3" href="#r3_4_3_1_3">Cylindrical Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.4" href="#r3_4_3_1_4">Parallel Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.5" href="#r3_4_3_1_5">Area Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.6" href="#r3_4_3_1_6">Shadowless Lights</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.7" href="#r3_4_3_1_7">Looks Like</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.8" href="#r3_4_3_1_8">Projected Through</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.9" href="#r3_4_3_1_9">Light Fading</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.10" href="#r3_4_3_1_10">Atmospheric Media Interaction</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.1.11" href="#r3_4_3_1_11">Atmospheric Attenuation</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.3.2" href="#r3_4_3_2">Light Group</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.3.3" href="#r3_4_3_3">Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.3.1" href="#r3_4_3_3_1">Radiosity Basics</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.3.2" href="#r3_4_3_3_2">How Radiosity Works</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.3.3" href="#r3_4_3_3_3">Adjusting Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.1" href="#r3_4_3_3_3_1">adc_bailout</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.2" href="#r3_4_3_3_3_2">always_sample</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.3" href="#r3_4_3_3_3_3">brightness</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.4" href="#r3_4_3_3_3_4">count</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.5" href="#r3_4_3_3_3_5">error_bound</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.6" href="#r3_4_3_3_3_6">gray_threshold</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.7" href="#r3_4_3_3_3_7">low_error_factor</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.8" href="#r3_4_3_3_3_8">max_sample</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.9" href="#r3_4_3_3_3_9">maximum_reuse</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.10" href="#r3_4_3_3_3_10">minimum_reuse</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.11" href="#r3_4_3_3_3_11">nearest_count</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.12" href="#r3_4_3_3_3_12">pretrace_start and pretrace_end</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.3.13" href="#r3_4_3_3_3_13">recursion_limit</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.3.4" href="#r3_4_3_3_4">Configuring Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.4.1" href="#r3_4_3_3_4_1">Importance</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.4.2" href="#r3_4_3_3_4_2">Media and Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.4.3" href="#r3_4_3_3_4_3">No Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.4.4" href="#r3_4_3_3_4_4">Normal and Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.4.5" href="#r3_4_3_3_4_5">Save and Load Radiosity Data</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.3.4.6" href="#r3_4_3_3_4_6">Subsurface and Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.3.5" href="#r3_4_3_3_5">Tips on Radiosity</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.4.3.4" href="#r3_4_3_4">Photons</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.1" href="#r3_4_3_4_1">Examples</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.2" href="#r3_4_3_4_2">Using Photon Mapping in Your Scene</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.3" href="#r3_4_3_4_3">Photon Global Settings</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.4" href="#r3_4_3_4_4">Shooting Photons at an Object</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.5" href="#r3_4_3_4_5">Photons and Light Sources</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.6" href="#r3_4_3_4_6">Photons and Media</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.7" href="#r3_4_3_4_7">Photons FAQ</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.8" href="#r3_4_3_4_8">Photon Tips</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.4.3.4.9" href="#r3_4_3_4_9">Advanced Techniques</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.4.9.1" href="#r3_4_3_4_9_1">Autostop</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.4.9.2" href="#r3_4_3_4_9_2">Adaptive Search Radius</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.4.9.3" href="#r3_4_3_4_9_3">Photons and Dispersion</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.4.3.4.9.4" href="#r3_4_3_4_9_4">Saving and Loading Photon Maps</a></div></td>
</tr>
<tr>
  <td><div class="divh1">&nbsp;</div></td>
</tr>
<tr>
  <td><div class="divh1">&nbsp;</div></td>
</tr>
</table>
</div>
<!-- NavPanel End -->

<div class="Content">
<table class="HeaderFooter" width="100%">
<tr>
  <td colspan=5 align="left" class="HeaderFooter">
    POV-Ray for Unix <strong class="HeaderFooter">version 3.8</strong>
  </td>
</tr>
<tr >
  <td colspan=5>
    <hr align="right" width="70%">
  </td>
</tr>
<tr>
  <td width="30%"></td>
  <td class="NavBar"><a href="index.html" title="The Front Door">Home</a></td>
  <td class="NavBar"><a href="u1_0.html" title="Unix Table of Contents">POV-Ray for Unix</a></td>
  <td class="NavBar"><a href="t2_0.html" title="Tutorial Table of Contents">POV-Ray Tutorial</a></td>
  <td class="NavBar"><a href="r3_0.html" title="Reference Table of Contents">POV-Ray Reference</a></td>
</tr>
</table>

<a name="r3_4"></a>
<div class="content-level-h2" contains="Scene File Basics" id="r3_4">
<h2>3.4 Scene File Basics</h2>
<p>Quick Links:</p>

<ul>
  <li><a href="r3_4.html#r3_4_1">Global Settings</a></li>
  <li><a href="r3_4.html#r3_4_2">Camera</a></li>
  <li><a href="r3_4.html#r3_4_3">Lighting Types</a></li>
</ul></div>

<a name="r3_4_1"></a>
<div class="content-level-h3" contains="Global Settings" id="r3_4_1">
<h3>3.4.1 Global Settings</h3>
<p>The <code>global_settings</code> statement is a catch-all statement that
gathers together a number of global parameters. The statement may appear
anywhere in a scene as long as it is not inside any other statement. You may
have multiple <code>global_settings</code> statements in a scene. Whatever
values were specified in the last <code>global_settings</code> statement
override any previous settings.</p>
<p class="Note"><strong>Note:</strong> Some items which were language directives in earlier versions of
POV-Ray have been moved inside the <code>global_settings</code> statement so
that it is more obvious to the user that their effect is global. The old
syntax is permitted but generates a warning.</p>
<p> The new syntax is:</p>
<pre>
GLOBAL_SETTINGS:
  global_settings { [GLOBAL_SETTINGS_ITEMS...] }
GLOBAL_SETTINGS_ITEM:
  adc_bailout Value | ambient_light COLOR | assumed_gamma GAMMA_VALUE | 
  hf_gray_16 [Bool] | irid_wavelength COLOR | charset GLOBAL_CHARSET |
  max_intersections Number | max_trace_level Number |
  mm_per_unit Number | number_of_waves Number | noise_generator Number |
  radiosity { RADIOSITY_ITEMS... } | subsurface { SUBSURFACE_ITEMS } |
  photon { PHOTON_ITEMS... }
GLOBAL_CHARSET:
  ascii | utf8 | sys
GAMMA_VALUE:
  Value | srgb
</pre>

<p>Global setting default values:</p>
<pre>
charset		   : ascii
adc_bailout	   : 1/255
ambient_light	   : &lt;1,1,1&gt;
assumed_gamma	   : 1.0 (undefined for legacy scenes)
hf_gray_16	   : deprecated
irid_wavelength	   : &lt;0.25,0.18,0.14&gt;
max_trace_level	   : 5
max_intersections  : 64
mm_per_unit        : 10
number_of_waves	   : 10
noise_generator	   : 2

Radiosity:
adc_bailout	   : 0.01
always_sample	   : off
brightness	   : 1.0
count		   : 35  (supports adaptive mode)
error_bound	   : 1.8
gray_threshold	   : 0.0
low_error_factor   : 0.5
max_sample	   : non-positive value
maximum_reuse      : 0.2
minimum_reuse	   : 0.015
nearest_count	   : 5   (max = 20; supports adaptive mode)
normal		   : off 
pretrace_start	   : 0.08
pretrace_end	   : 0.04
recursion_limit	   : 2
subsurface 	   : off

Subsurface:
radiosity	   : off
samples		   : 50,50 
</pre>

<p>Each item is optional and may appear in any order. If an item is specified
more than once, the last setting overrides previous values. Details on each
item are given in the following sections.</p>

</div>
<a name="r3_4_1_1"></a>
<div class="content-level-h4" contains="ADC_Bailout" id="r3_4_1_1">
<h4>3.4.1.1 ADC_Bailout</h4>
<p>In scenes with many reflective and transparent surfaces, POV-Ray can get
bogged down tracing multiple reflections and refractions that contribute very
little to the color of a particular pixel. The program uses a system called
<em>Adaptive Depth Control</em> (ADC) to stop computing additional reflected
or refracted rays when their contribution is insignificant.</p>
<p>
You may use the global setting <code>adc_bailout</code> keyword followed by
float value to specify the point at which a ray's contribution is
considered insignificant. For example:</p>
<pre>
global_settings { adc_bailout 0.01 }
</pre>

<p>The default value is 1/255, or approximately 0.0039, since a change
smaller than that could not be visible in a 24 bit image. Generally this
setting is perfectly adequate and should be left alone. Setting
<code>adc_bailout</code> to 0 will disable ADC, relying completely on
<code>max_trace_level</code> to set an upper limit on the number of rays spawned.</p>
<p>
See the section <a href="r3_4.html#r3_4_1_7">Max_Trace_Level</a> for details on how ADC and <code>max_trace_level</code> interact.</p>

</div>
<a name="r3_4_1_2"></a>
<div class="content-level-h4" contains="Ambient_Light" id="r3_4_1_2">
<h4>3.4.1.2 Ambient_Light</h4>
<p>Ambient light is used to simulate the effect of inter-diffuse reflection
that is responsible for lighting areas that partially or completely lie in
shadow. POV-Ray provides the <code>ambient_light</code> keyword to let you
easily change the brightness of the ambient lighting without changing every
ambient value in all finish statements. It also lets you create interesting
effects by changing the color of the ambient light source. The syntax is:</p>
<pre>
global_settings { ambient_light COLOR }
</pre>

<p>The default is a white ambient light source set at <code>rgb
&lt;1,1,1&gt;</code>. Only the rgb components are used. The actual ambient
used is: <em>Ambient = Finish_Ambient * Global_Ambient</em>.</p>
<p>See the section <a href="r3_6.html#r3_6_1_3_1">Ambient</a> for more information.</p>

</div>
<a name="r3_4_1_3"></a>
<div class="content-level-h4" contains="Assumed_Gamma" id="r3_4_1_3">
<h4>3.4.1.3 Assumed_Gamma</h4>
<p>The <code>assumed_gamma</code> statement specifies a dsiplay gamma for which all color literals in the scene are presumed to be pre-corrected; at the same time it also defines the <em>working gamma space</em> in which POV-Ray will perform all its color computations.</p>

<p class="Note"><strong>Note:</strong> Using any value other than 1.0 will produce physically inaccurate results. Furthermore, if you decide to go for a different value for convenience, it is highly recommended to set this value to the same as your <code>Display_Gamma</code>. Using this parameter for artistic purposes is strongly discouraged.</p>

<p class="Note"><strong>Note:</strong> As of POV-Ray 3.7 this keyword is considered mandatory (except in legacy scenes) and consequently enables the <em>experimental</em> gamma handling feature. Future versions of POV-Ray may treat the absence of this keyword in non-legacy scenes as an error.</p>

<p>See section <a href="t2_3.html#t2_3_4">Gamma Handling</a> for more information about gamma.</p>

</div>
<a name="r3_4_1_4"></a>
<div class="content-level-h4" contains="HF_Gray_16" id="r3_4_1_4">
<h4>3.4.1.4 HF_Gray_16</h4>
<p>A <font class="Change">Change</font> as of version 3.7 has deprecated the <code>hf_gray_16</code> keyword in the <code>global_settings</code> block. If encountered, it has no effect on the output type and will additionally generate a warning message. Grayscale output can still be used to generate heightfields for use in other POV-Ray scenes. See: <a href="r3_2.html#r3_2_4_1">Output File Type</a> for details.</p>

</div>
<a name="r3_4_1_5"></a>
<div class="content-level-h4" contains="Irid_Wavelength" id="r3_4_1_5">
<h4>3.4.1.5 Irid_Wavelength</h4>
<p>Iridescence calculations depend upon the dominant wavelengths of the
primary colors of red, green and blue light. You may adjust the values using
the global setting <code>irid_wavelength</code> as follows...</p>
<pre>
global_settings { irid_wavelength COLOR }
</pre>

<p>The default value is <code>rgb &lt;0.70,0.52,0.48&gt;</code> and any
filter or transmit values are ignored. These values are proportional to the
wavelength of light but they represent no real world units.</p>
<p>
In general, the default values should prove adequate but we provide this
option as a means to experiment with other values.</p>

</div>
<a name="r3_4_1_6"></a>
<div class="content-level-h4" contains="Charset" id="r3_4_1_6">
<h4>3.4.1.6 Charset</h4>
<p>This allows you to specify the assumed character set of all text strings.
If you specify <code>ascii</code> only standard ASCII character codes in the
range from 0 to 127 are valid. You can easily find a table of ASCII 
characters on the internet. The option <code>utf8</code> is a special Unicode
text encoding and it allows you to specify characters of nearly all languages
in use today. We suggest you use a text editor with the capability to export
text to UTF8 to generate input files. You can find more information, 
including tables with codes of valid characters on the
<a href="http://www.unicode.org/">Unicode website</a>
The last possible option is to use a system specific character set. For 
details about the <code>sys</code> character set option refer to the platform 
specific documentation.</p>

</div>
<a name="r3_4_1_7"></a>
<div class="content-level-h4" contains="Max_Trace_Level" id="r3_4_1_7">
<h4>3.4.1.7 Max_Trace_Level</h4>
<p>In scenes with many reflective and transparent surfaces POV-Ray can get
bogged down tracing multiple reflections and refractions that contribute very
little to the color of a particular pixel. The global setting <code>
max_trace_level</code> defines the integer maximum number of recursive levels
that POV-Ray will trace a ray.</p>
<pre>
global_settings { max_trace_level Level }
</pre>

<p>This is used when a ray is reflected or is passing through a transparent
object and when shadow rays are cast. When a ray hits a reflective surface,
it spawns another ray to see what that point reflects. That is trace level
one. If it hits another reflective surface another ray is spawned and it goes
to trace level two. The maximum level by default is five.</p>
<p>
One speed enhancement added to POV-Ray in version 3.0 is <em>Adaptive Depth
Control</em> (ADC). Each time a new ray is spawned as a result of reflection
or refraction its contribution to the overall color of the pixel is reduced
by the amount of reflection or the filter value of the refractive surface. At
some point this contribution can be considered to be insignificant and there
is no point in tracing any more rays. Adaptive depth control is what tracks
this contribution and makes the decision of when to bail out. On scenes that
use a lot of partially reflective or refractive surfaces this can result in a
considerable reduction in the number of rays fired and makes it safer to use
much higher <code> max_trace_level</code> values.</p>
<p>
This reduction in color contribution is a result of scaling by the
reflection amount and/or the filter values of each surface, so a perfect
mirror or perfectly clear surface will not be optimizable by ADC. You can see
the results of ADC by watching the <code> Rays Saved</code> and <code>Highest
Trace Level</code> displays on the statistics screen.</p>
<p>
The point at which a ray's contribution is considered insignificant is
controlled by the <code>adc_bailout</code> value. The default is 1/255 or
approximately 0.0039 since a change smaller than that could not be visible in
a 24 bit image. Generally this setting is perfectly adequate and should be
left alone. Setting <code><a href="r3_4.html#r3_4_1_1">adc_bailout</a></code> to 0 will disable ADC, relying
completely on <code> max_trace_level</code> to set an upper limit on the
number of rays spawned.</p>
<p>
If <code>max_trace_level</code> is reached before a non-reflecting surface
is found and if ADC has not allowed an early exit from the ray tree the
color is returned as black. Raise <code>max_trace_level</code> if you see
black areas in a reflective surface where there should be a color.</p>
<p>
The other symptom you could see is with transparent objects. For instance,
try making a union of concentric spheres with a clear texture on them. Make
ten of them in the union with radius's from 1 to 10 and render the scene.
The image will show the first few spheres correctly, then black. This is
because a new level is used every time you pass through a transparent
surface. Raise <code>max_trace_level</code> to fix this problem.</p>
<p class="Note"><strong>Note:</strong> Raising <code>max_trace_level</code> will use more memory and time
and it could cause the program to crash with a stack overflow error, although
ADC will alleviate this to a large extent.</p>
<p>Values for <code>max_trace_level</code> can be set up to a maximum of 256.
If there is no <code>max_trace_level</code> set and during rendering the default value is reached, a warning is issued.
</p>

</div>
<a name="r3_4_1_8"></a>
<div class="content-level-h4" contains="Max_Intersections" id="r3_4_1_8">
<h4>3.4.1.8 Max_Intersections</h4>
<p>Previous versions of POV-Ray used a set of internal stacks to collect ray/object intersection points. As of version 3.7 <code>max_intersections</code> has been deprecated, and using it in the global settings blocks now produces a warning at parse time.</p>

</div>
<a name="r3_4_1_9"></a>
<div class="content-level-h4" contains="Mm_Per_Unit" id="r3_4_1_9">
<h4>3.4.1.9 Mm_Per_Unit</h4>
<p>See the section <a href="r3_6.html#r3_6_1_3_3_4">Subsurface Light Transport</a> for more information about the role of <code>mm_per_unit</code> in the global settings block.</p>

</div>
<a name="r3_4_1_10"></a>
<div class="content-level-h4" contains="Number_Of_Waves" id="r3_4_1_10">
<h4>3.4.1.10 Number_Of_Waves</h4>
<p>The <code><a href="r3_6.html#r3_6_2_1_29">waves</a></code> and <code><a href="r3_6.html#r3_6_2_1_23">ripples</a></code>
patterns are generated by summing a series of waves, each with a slightly different center and size. By default, ten waves are summed but this amount can be globally controlled by changing the <code>number_of_waves</code> setting.</p>
<pre>
global_settings { number_of_waves Integer }
</pre>

<p>Changing this value affects both waves and ripples alike on all patterns in the scene.</p>

</div>
<a name="r3_4_1_11"></a>
<div class="content-level-h4" contains="Noise_generator" id="r3_4_1_11">
<h4>3.4.1.11 Noise_generator</h4>
<p> There are three noise generators implemented. </p>
<ul>
<li><code>noise_generator 1</code> the noise that was used in POV_Ray 3.1</li>
<li><code>noise_generator 2</code> 'range corrected' version of the old noise, it does not show the plateaus seen with <code>noise_generator 1</code> </li>
<li><code>noise_generator 3</code> generates Perlin noise</li>
</ul>
<p>The default is <code>noise_generator 2</code></p>
<p class="Note"><strong>Note:</strong> The noise_generators can also be used within the pigment/normal/etc. statement.</p>

</div>
<a name="r3_4_1_12"></a>
<div class="content-level-h4" contains="Subsurface" id="r3_4_1_12">
<h4>3.4.1.12 Subsurface</h4>
<p>See the section <a href="r3_6.html#r3_6_1_3_3_4">Subsurface Light Transport</a> for more information about the role of <code>subsurface</code> in the global settings block.</p></div>

<a name="r3_4_2"></a>
<div class="content-level-h3" contains="Camera" id="r3_4_2">
<h3>3.4.2 Camera</h3>
<p>The camera definition describes the position, projection type and
properties of the camera viewing the scene. Its syntax is:</p>
<pre>
CAMERA:
  camera{ [CAMERA_ITEMS...] }
CAMERA_ITEMS:
  CAMERA_TYPE | CAMERA_VECTOR | CAMERA_MODIFIER |
  CAMERA_IDENTIFIER
CAMERA_TYPE:
  perspective | orthographic | mesh_camera { MESHCAM_MODIFIERS } | fisheye | ultra_wide_angle |
  omnimax | panoramic | cylinder CylinderType | spherical | user_defined { USER_DEFINED_MODIFIERS }
CAMERA_VECTOR:
  location &lt;Location&gt; | right &lt;Right&gt; | up &lt;Up&gt; | 
  direction &lt;Direction&gt; | sky &lt;Sky&gt;
CAMERA_MODIFIER:
  angle HORIZONTAL [VERTICAL] | look_at &lt;Look_At&gt; |
  blur_samples [MIN_SAMPLES,] MAX_SAMPLES | aperture Size |
  focal_point &lt;Point&gt; | confidence Blur_Confidence |
  variance Blur_Variance | [bokeh { pigment { BOKEH } }] |
  NORMAL | TRANSFORMATION | [MESHCAM_SMOOTH]
MESHCAM_MODIFIERS:
  rays per pixel Value,
  distribution type Value,
  [max distance Value],
  MESH_OBJECT | [MESH_OBJECT...]
BOKEH:
  a COLOR_VECTOR in the range of &lt;0,0,0&gt; ... &lt;1,1,0&gt;
MESHCAM_SMOOTH:
  smooth
USER_DEFINED_MODIFIERS:
  [location  &lt;function{ }&gt;, &lt;function{ }&gt;, &lt;function{ }&gt;]
  [direction &lt;function{ }&gt;, &lt;function{ }&gt;, &lt;function{ }&gt;]
</pre>
<p>
Camera default values:</p>
<pre>
DEFAULT CAMERA:
camera {
  perspective
  location &lt;0,0,0&gt;
  direction &lt;0,0,1&gt;
  right &lt;image_width/image_height,0,0&gt;
  up y
  sky &lt;0,1,0&gt;
  }

CAMERA TYPE: perspective
  angle      : ~67.380 ( direction_length=0.5*right_length/tan(angle/2) )
  confidence : 0.9 (90%)
  direction  : &lt;0,0,1&gt;
  focal_point: &lt;0,0,0&gt;
  location   : &lt;0,0,0&gt;
  look_at    : z
  right      : &lt;image_width/image_height,0,0&gt;
  sky        : &lt;0,1,0&gt;
  up         : y
  variance   : 1/128
</pre>

<p>Depending on the projection type zero or more of the parameters are required:</p>
<ul>
  <li>If no camera is specified the default camera is used.</li>
  <li>If no projection type is given the perspective camera will be used (pinhole camera).</li>
  <li>The <em>CAMERA_TYPE</em> has to be the first item in the camera statement.</li>
  <li>Other <em>CAMERA_ITEMS</em> may legally appear in any order.</li>
  <li>For other than the perspective camera, the minimum that has to be specified is the CAMERA_TYPE, the cylindrical camera also requires the <em>CAMERA_TYPE</em> to be followed by a float.</li>
  <li>The Orthographic camera has two <em>modes</em>. For a purely orthographic projection up or right has to be specified. For an orthographic camera, with the same area of view as a perspective camera at the plane which goes through the look_at point, the angle keyword has to be used. A value for the angle is optional.</li>
  <li>All other <em>CAMERA_ITEMS</em> are taken from the default camera, unless they are specified differently.</li>
</ul>

</div>
<a name="r3_4_2_1"></a>
<div class="content-level-h4" contains="Placing the Camera" id="r3_4_2_1">
<h4>3.4.2.1 Placing the Camera</h4>
<p>The POV-Ray camera has 10 different models and they are as follows:</p>

<ol>
  <li><a href="r3_4.html#r3_4_2_2_1">perspective</a></li>
  <li><a href="r3_4.html#r3_4_2_2_2">orthographic</a></li>
  <li><a href="r3_4.html#r3_4_2_2_3">mesh</a></li>
  <li><a href="r3_4.html#r3_4_2_2_4">fisheye</a></li>
  <li><a href="r3_4.html#r3_4_2_2_5">ultra-wide angle</a></li>
  <li><a href="r3_4.html#r3_4_2_2_6">onmimax</a></li>
  <li><a href="r3_4.html#r3_4_2_2_7">panoramic</a></li>
  <li><a href="r3_4.html#r3_4_2_2_8">cylindrical</a></li>
  <li><a href="r3_4.html#r3_4_2_2_9">spherical</a></li>
  <li><a href="r3_4.html#r3_4_2_2_10">user defined</a></li>
</ol>

<p>Each of which uses a different projection method to project the scene onto your screen. Regardless of the projection type all cameras use <code>location</code>, <code>right</code>, <code>up</code>, <code>direction</code>, and other keywords to determine the location and orientation of the camera. The type keywords and these four vectors fully define the camera. All other camera modifiers adjust how the camera does its job. The meaning of these vectors and other modifiers differ with the projection type used. A more detailed explanation of the camera types follows later. In the sub-sections which follows, we explain how to place and orient the camera by the use of these four vectors and the <code>sky</code> and <code>look_at</code> modifiers. You may wish to refer to the illustration of the perspective camera below as you read about these
vectors.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
  <img class="center" width="640px" src="images/f/fd/RefImgPerspcam.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Basic (default) camera geometry</p>
  </td>
</tr>
</table>

</div>
<a name="r3_4_2_1_1"></a>
<div class="content-level-h5" contains="Location and Look_At" id="r3_4_2_1_1">
<h5>3.4.2.1.1 Location and Look_At</h5>
<p>Under many circumstances just two vectors in the camera statement are all
you need to position the camera: <code>location</code> and <code>look_at</code>
vectors. For example:</p>
<pre>
camera {
  location &lt;3,5,-10&gt;
  look_at &lt;0,2,1&gt;
  }
</pre>

<p>The location is simply the x, y, z coordinates of the camera. The camera
can be located anywhere in the ray-tracing universe. The default location is
<code>&lt;0,0,0&gt;</code>. The <code>look_at</code> vector tells POV-Ray to
pan and tilt the camera until it is looking at the specified x, y, z
coordinates. By default the camera looks at a point one unit in the
z-direction from the location.</p>
<p>
The <code>look_at</code> modifier should almost always be the last item in
the camera statement. If other camera items are placed after the <code>
look_at</code> vector then the camera may not continue to look at the
specified point.</p>

</div>
<a name="r3_4_2_1_2"></a>
<div class="content-level-h5" contains="The Sky Vector" id="r3_4_2_1_2">
<h5>3.4.2.1.2 The Sky Vector</h5>
<p>Normally POV-Ray pans left or right by rotating about the y-axis until it
lines up with the <code>look_at</code> point and then tilts straight up or
down until the point is met exactly. However you may want to slant the camera
sideways like an airplane making a banked turn. You may change the tilt of
the camera using the <code>sky</code> vector. For example:</p>
<pre>
camera {
  location &lt;3,5,-10&gt;
  sky &lt;1,1,0&gt;
  look_at &lt;0,2,1&gt;
  }
</pre>

<p>This tells POV-Ray to roll the camera until the top of the camera is in
line with the sky vector. Imagine that the sky vector is an antenna pointing
out of the top of the camera. Then it uses the <code>sky</code> vector as the
axis of rotation left or right and then to tilt up or down in line with the
<code>sky</code> until pointing at the <code>look_at</code> point. In effect
you are telling POV-Ray to assume that the sky isn't straight up.</p>
<p>
The <code>sky</code> vector does nothing on its own. It only modifies the
way the <code>look_at</code> vector turns the camera. The default value is
<code>sky &lt;0,1,0&gt;</code>.</p>

</div>
<a name="r3_4_2_1_3"></a>
<div class="content-level-h5" contains="Angles" id="r3_4_2_1_3">
<h5>3.4.2.1.3 Angles</h5>
<p>The <code>angle</code> keyword followed by a float expression specifies
the (horizontal) viewing angle in degrees of the camera used. Even though it
is possible to use the <code>direction</code> vector to determine the viewing
angle for the perspective camera it is much easier to use the <code>
angle</code> keyword.</p>
<p>
When you specify the <code>angle</code>, POV-Ray adjusts the length of the
<code>direction</code> vector accordingly. The formula used is <em>
direction_length = 0.5 * right_length / tan(angle / 2)</em> where <em>
right_length</em> is the length of the <code>right</code> vector. You should
therefore specify the <code>direction</code> and <code>right</code> vectors
before the <code>angle</code> keyword. The <code>right</code> vector is
explained in the next section.</p>
<p>
There is no limitation to the viewing angle except for the perspective
projection. If you choose viewing angles larger than 360 degrees you will
see repeated images of the scene (the way the repetition takes place depends
on the camera). This might be useful for special effects.</p>
<p>
The <code>spherical</code> camera has the option to also specify a vertical
angle. If not specified it defaults to the horizontal angle/2</p>
<p>
For example if you render an image with a 2:1 aspect ratio and map it 
to a sphere using spherical mapping, it will recreate the scene. Another 
use is to map it onto an object and if you specify transformations for 
the object before the texture, say in an animation, it will look like 
reflections of the environment (sometimes called environment mapping).</p>

</div>
<a name="r3_4_2_1_4"></a>
<div class="content-level-h5" contains="The Direction Vector" id="r3_4_2_1_4">
<h5>3.4.2.1.4 The Direction Vector</h5>
<p>You will probably not need to explicitly specify or change the camera
<code>direction</code> vector but it is described here in case you do. It
tells POV-Ray the initial direction to point the camera before moving it with
the <code>look_at</code> or <code>rotate</code> vectors the default value is
<code>direction &lt;0,0,1&gt;</code>. It may also be used to control the
(horizontal) field of view with some types of projection. The length of the
vector determines the distance of the viewing plane from the camera's
location. A shorter <code>direction</code> vector gives a wider view while a
longer vector zooms in for close-ups. In early versions of POV-Ray, this was
the only way to adjust field of view. However zooming should now be done
using the easier to use <code>angle</code> keyword.</p>
<p>
If you are using the <code>ultra_wide_angle</code>, <code>panoramic</code>,
or <code>cylindrical</code> projection you should use a unit length <code>
direction</code> vector to avoid strange results. The length of the <code>
direction</code> vector does not matter when using the <code>
orthographic</code>, <code>fisheye</code>, or <code>omnimax</code> projection
types.</p>

</div>
<a name="r3_4_2_1_5"></a>
<div class="content-level-h5" contains="Up and Right Vectors" id="r3_4_2_1_5">
<h5>3.4.2.1.5 Up and Right Vectors</h5>
<p>The primary purpose of the <code>up</code> and <code>right</code> vectors
is to tell POV-Ray the relative height and width of the view screen. The
default values are:</p>
<pre>
right &lt;image_width/image_height,0,0&gt;
up y
</pre>

<p>In the default <code>perspective</code> camera, these two vectors also
define the initial plane of the view screen before moving it with the <code>
look_at</code> or <code>rotate</code> vectors. The length of the <code>
right</code> vector (together with the <code>direction</code> vector) may
also be used to control the (horizontal) field of view with some types of
projection. The <code>look_at</code> modifier changes both the <code>up</code>
and <code>right</code> vectors. The <code>angle</code> calculation depends on the <code>
right</code> vector.</p>
<p>
Most camera types treat the <code>up</code> and <code>right</code> vectors
the same as the <code>perspective</code> type. However several make special
use of them. In the <code>orthographic</code> projection: The lengths of the
<code>up</code> and <code>right</code> vectors set the size of the viewing
window regardless of the <code>direction</code> vector length, which is not
used by the orthographic camera.</p>
<p>
When using <code>cylindrical</code> projection: types 1 and 3, the axis of
the cylinder lies along the <code>up</code> vector and the width is
determined by the length of <code>right</code> vector or it may be overridden
with the <code>angle</code> vector. In type 3 the <code>up</code> vector
determines how many units high the image is. For example if you have <code>up
4*y</code> on a camera at the origin. Only points from y=2 to y=-2 are
visible. All viewing rays are perpendicular to the y-axis. For type 2 and 4,
the cylinder lies along the <code>right</code> vector. Viewing rays for type
4 are perpendicular to the <code>right</code> vector.</p>
<p>See Also: <a href="r3_4.html#r3_4_2_1_6">Aspect Ratio</a></p>
<p class="Note"><strong>Note:</strong> The <code>up</code>, <code>right</code>, and <code>direction</code> vectors should always remain perpendicular to each other or the image will be distorted. If this is not the case a warning message will be printed. The vista buffer will not work for non-perpendicular camera vectors.</p>

</div>
<a name="r3_4_2_1_6"></a>
<div class="content-level-h5" contains="Aspect Ratio" id="r3_4_2_1_6">
<h5>3.4.2.1.6 Aspect Ratio</h5>
<p>Together the <code>right</code> <em>(width)</em> and <code>up</code> <em>(height)</em> vectors define the <em>aspect ratio</em> of the resulting image.</p>

<p>A <font class="Change">Change</font> in version 3.8 redefines how the <code>right</code> vector default is derived. The default setting is now <code>right &lt;image_width/image_height,0,0&gt;</code> as opposed to the <code>right &lt;1.33,0,0&gt;</code> value used in previous versions. Requires <code>#version 3.8;</code> or equivalent INI setting or command-line option. See also: <a href="r3_3.html#r3_3_2_5">Version Directive</a>. As usual, the image width and height can be specified from either the pull down menu available in <em>GUI</em> versions <em>ONLY</em> or the <code>+Wn</code> and <code>+Hn</code> command-line options available to <em>ALL</em> versions. The default <code>up</code> vector remains as <code>&lt;0,1,0&gt;</code>.</p>

<p>To retain legacy behavior see the example below:</p>

<pre>
#version X.y; // X.y is a version less than 3.8
camera {
  location &lt;3,5,-10&gt;
  look_at &lt;0,2,1&gt;
  }
</pre>

</div>
<a name="r3_4_2_1_7"></a>
<div class="content-level-h5" contains="Handedness" id="r3_4_2_1_7">
<h5>3.4.2.1.7 Handedness</h5>
<p>The <code>right</code> vector also describes the direction to the right of
the camera. It tells POV-Ray where the right side of your screen is. The sign
of the <code>right</code> vector can be used to determine the handedness of
the coordinate system in use. The default value is: <code>
right &lt;image_width/image_height,0,0&gt;</code>. This means that the +x-direction is to the
right. It is called a <em>left-handed</em> system because you can use your
left hand to keep track of the axes. Hold out your left hand with your palm
facing to your right. Stick your thumb up. Point straight ahead with your
index finger. Point your other fingers to the right. Your bent fingers are
pointing to the +x-direction. Your thumb now points into +y-direction. Your
index finger points into the +z-direction.</p>
<p>
To use a right-handed coordinate system, as is popular in some CAD programs
and other ray-tracers, make the same shape using your right hand. Your thumb
still points up in the +y-direction and your index finger still points
forward in the +z-direction but your other fingers now say the +x-direction
is to the left. That means that the right side of your screen is now in the
-x-direction. To tell POV-Ray to act like this you can use a negative x value
in the <code>right</code> vector such as: <code>
right &lt;-image_width/image_height,0,0&gt;</code>. Since having x values increasing to the left
does not make much sense on a 2D screen you now rotate the whole thing 180
degrees around by using a positive z value in your camera's location. You
end up with something like this.</p>
<pre>
camera {
  location &lt;0,0,10&gt;
  up &lt;0,1,0&gt;
  right &lt;-image_width/image_height,0,0&gt;
  look_at &lt;0,0,0&gt;
  }
</pre>

<p>Now when you do your ray-tracer's aerobics, as explained in the
section <a href="t2_2.html#t2_2_1_1">Understanding POV-Ray's Coordinate System</a>, you use your right hand to determine the direction of rotations.</p>
<p>
In a two dimensional grid, x is always to the right and y is up. The two
versions of handedness arise from the question of whether z points into the
screen or out of it and which axis in your computer model relates to up in
the real world.</p>
<p>
Architectural CAD systems, like AutoCAD, tend to use the <em> God's
Eye</em> orientation that the z-axis is the elevation and is the model's
up direction. This approach makes sense if you are an architect looking at
a building blueprint on a computer screen. z means up, and it increases
towards you, with x and y still across and up the screen. This is the basic
right handed system.</p>
<p>
Stand alone rendering systems, like POV-Ray, tend to consider you as a
participant. You are looking at the screen as if you were a photographer
standing in the scene. The up direction in the model is now y, the same as up
in the real world and x is still to the right, so z must be depth, which
increases away from you into the screen. This is the basic left handed
system.</p>

</div>
<a name="r3_4_2_1_8"></a>
<div class="content-level-h5" contains="Transforming the Camera" id="r3_4_2_1_8">
<h5>3.4.2.1.8 Transforming the Camera</h5>
<p>The various transformations such as <code>translate</code> and <code>
rotate</code> modifiers can re-position the camera once you have defined
it. For example:</p>
<pre>
camera {
  location &lt;0,0,0&gt;
  direction &lt;0,0,1&gt;
  up &lt;0,1,0&gt;
  right &lt;1,0,0&gt;
  rotate &lt;30,60,30&gt;
  translate &lt;5,3,4&gt;
  }
</pre>

<p>In this example, the camera is created, then rotated by 30 degrees about
the x-axis, 60 degrees about the y-axis and 30 degrees about the z-axis, then
translated to another point in space.</p>

</div>
<a name="r3_4_2_2"></a>
<div class="content-level-h4" contains="Types of Projection" id="r3_4_2_2">
<h4>3.4.2.2 Types of Projection</h4>
<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/0/09/RefImgCameraSampleScene.jpg">
</td>
<td>
  <p class="tabletext">The following sections explain the different projection types that can be used with the scene camera. The most common types are the  perspective and orthographic projections. The <em>CAMERA_TYPE</em> should be the <em>first</em> item in a  <code>camera</code> statement. If none is specified, the <code>perspective</code> camera is the default.</p>
</td>
</tr>
<tr>
<td>
  <p class="caption">The camera sample scene global view</p>
</td>
<td></td>
</tr>
</table>

<p class="Note"><strong>Note:</strong> The <a href="r3_2.html#r3_2_8_4">vista buffer</a> feature can only be used with the perspective and orthographic camera.</p>

</div>
<a name="r3_4_2_2_1"></a>
<div class="content-level-h5" contains="Perspective projection" id="r3_4_2_2_1">
<h5>3.4.2.2.1 Perspective projection</h5>
<p>The <code>perspective</code> keyword specifies the default perspective camera which simulates the classic pinhole camera. The <em>horizontal</em> viewing angle is either determined by the ratio between the length of the <code>direction</code> vector and the length of the <code>right</code> vector or by the optional keyword <code>angle</code>, which is the preferred way. The viewing angle has to be larger than 0 degrees and smaller than 180 degrees.</p>

<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/8/82/RefImgCameraViewPerspective.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/f/f6/RefImgCameraSampleperspective.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The perspective projection diagram</p>
</td>
<td>
  <p class="caption">A perspective camera sample image</p>
</td>
</tr>
</table>

<p class="Note"><strong>Note:</strong> The <code>angle</code> keyword can be used as long as less than 180 degrees. It recomputes the length of right and up vectors using <code>direction</code>. The proper aspect ratio between the <code>up</code> and <code>right</code> vectors is maintained.</p>

</div>
<a name="r3_4_2_2_2"></a>
<div class="content-level-h5" contains="Orthographic projection" id="r3_4_2_2_2">
<h5>3.4.2.2.2 Orthographic projection</h5>
<p>The orthographic camera offers two modes of operation:</p>

<p>The pure <code>orthographic</code> projection. This projection uses parallel camera rays to create an image of the scene. The area of view is determined by the lengths of the <code>right</code> and <code>up</code> vectors. One of these has to be specified, they are not taken from the default camera. If omitted the second method of the camera is used.</p>

<p>If, in a perspective camera, you replace the <code>perspective</code> keyword by <code>orthographic</code> and leave all other parameters the same, you will get an orthographic view with the same image area, i.e. the size of the image is
the same. The same can be achieved by adding the <code>angle</code> keyword to an orthographic camera. A value for the angle is optional. So this second mode is active if no up and right are within the camera statement, or when the angle keyword is within the camera statement.</p>

<p>You should be aware though that the visible parts of the scene change when switching from perspective to orthographic view. As long as all objects of interest are near the look_at point they will be still visible if the orthographic camera is used. Objects farther away may get out of view while nearer objects will stay in view.</p>

<p>If objects are too close to the camera location they may disappear. Too close here means, behind the orthographic camera projection plane (the plane that goes through the <code>location</code> point).</p> 

<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/c/ce/RefImgCameraViewOrthographic.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/b/b2/RefImgCameraSampleorthographic.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The orthographic projection diagram</p>
</td>
<td>
  <p class="caption">An orthographic camera sample image</p>
</td>
</tr>
</table>

<p class="Note"><strong>Note:</strong> The length of direction is irrelevant unless angle is used. The lengths of up and right define the dimensions of the view. The <code>angle</code> keyword can be used, as long as less than 180. It will override the length of the right and up vectors (the aspect ratio between up and right will be kept nevertheless) with a scope of a perspective camera having the same direction and angle.</p>

</div>
<a name="r3_4_2_2_3"></a>
<div class="content-level-h5" contains="Mesh projection" id="r3_4_2_2_3">
<h5>3.4.2.2.3 Mesh projection</h5>
<p>The mesh projection is a special camera type that allows complete control of the ray origin and direction for each pixel of the output image. The basic concept is to associate pixels with faces defined within a <em>previously declared</em> <code>mesh</code> or <code>mesh2</code> object. The <code>MESH_OBJECT_IDENTIFIER</code> need not be instantiated in the scene, though it can be, and doing so can lead to some interesting uses, such as texture baking or illumination calculations.</p>
<p>In its simplest form, each pixel of the output image is assigned to a face of the mesh according to <code>(width * (int) y) + (int) x</code>, however, more complex mapping is possible via multiple meshes and multiple rays per pixel. The type of mapping in use is determined by the distribution type parameter in the camera declaration. Except for mapping #3, the ray origin will be set to the centroid of the face, and the direction will be that of the face's normal. For mapping #3, barycentric co-ordinates are determined from the UV co-ordinates of the first face to match the X and Y position, and those are then converted to a position on the face which will serve as the ray origin. Support is provided to move the origin off the face along the normal, and to reverse the ray direction.</p>
<p>For most of the distribution methods, any POV feature that causes sub-pixel positioning to be used for shooting rays (e.g. anti-aliasing or jitter) will not do anything useful, because X and Y are converted to integers for indexing purposes. At this time, no warning is issued if anti-aliasing or jitter is requested when rendering a non-applicable distribution; this may be added later.</p>
<p>The syntax for the mesh camera is as follows:</p>
<pre>
camera {
  mesh_camera {
    rays per pixel
    distribution type
    [max distance]
    mesh {
      MESH_OBJECT_IDENTIFIER
      [TRANSFORMATIONS]
    }
    [mesh ...]
  }
  [location]
  [direction]
  [smooth]
  } 
</pre>

<p class="Note"><strong>Note:</strong> The mesh camera is an <strong>experimental feature</strong> introduced in version 3.7 beta 39 and its syntax is likely to change. Additionally, many of the normal camera concepts presented in this section (such as location and direction) either do not work as they do for other cameras or do not work at all (for example, the concept of 'up' simply does not apply to a mesh camera). It should also be kept in mind that the camera has not yet been tested with many of POV-Ray's advanced features such as photons and radiosity, and more work in that area is likely to be needed.</p>

</div>
<a name="r3_4_2_2_3_1"></a>
<div class="content-level-h6" contains="Rays Per Pixel" id="r3_4_2_2_3_1">
<h6>3.4.2.2.3.1 Rays Per Pixel</h6>
<p>This float parameter controls the number of rays that will be shot for each pixel in the output image. Each distribution allows different values, but the minimum is always 1.</p>

</div>
<a name="r3_4_2_2_3_2"></a>
<div class="content-level-h6" contains="Distribution Type" id="r3_4_2_2_3_2">
<h6>3.4.2.2.3.2 Distribution Type</h6>
<p>This float parameter controls how pixels are assigned to faces as documented below:</p>
<ul>
<li><strong>distribution #0</strong></li>
</ul>
<p>This method allows single or multiple rays per pixel, with the ray number for that pixel allocated to each mesh in turn. The index into the meshes is the ray number, where <em>rays per pixel</em> is greater than one, and the index into the selected mesh is the pixel number within the output image. If there is no face at that pixel position, the resulting output pixel is unaffected.</p>
<p>You must supply at least as many meshes as <em>rays per pixel</em>. Each pixel is shot <em>rays per pixel</em> times, and the results averaged. Any ray that does not correspond with a face (i.e. the pixel number is greater than or equal to the face count) does not affect the resulting pixel color. Generally, it would be expected that the number of faces in each mesh is the same, but this is not a requirement. Keep in mind that a ray that is not associated with a face is not the same thing as a ray that is but that, when shot, hits nothing. The latter will return a pixel (even if it is transparent or the background color), whereas the former causes the ray to not be shot in the first place; hence, it is not included in the calculation of the average for the pixel.</p>
<p>Using multiple rays per pixel is useful for generating anti-aliasing (since standard AA won't work) or for special effects such as focal blur, motion blur, and so forth, with each additional mesh specified in the camera representing a slightly different camera position.</p>
<p class="Note"><strong>Note:</strong> It is legal to use transformations on meshes specified in the camera body, hence it's possible to obtain basic anti-aliasing by using a single mesh multiple times, with subsequent ones jittered slightly from the first combined with a suitable <em>rays per pixel</em> count.</p>
<ul>
<li><strong>distribution #1</strong></li>
</ul>
<p>This method allows both multiple rays per pixel and summing of meshes, in other words the faces of all the supplied meshes are logically summed together as if they were one single mesh. In this mode, if you specify more than one ray per pixel, the second ray for a given pixel will go to the face at <code>(width * height * ray_number) + pixel_number</code>, where <em>ray_number</em> is the count of rays shot into a specific pixel. If the calculated face index exceeds the total number of faces for all the meshes, no ray is shot.</p>
<p>The primary use for this summing method is convenience in generation of the meshes, as some modelers slow down to an irritating extent with very large meshes. Using <em>distribution #1</em> allows these to be split up.</p>
<ul>
<li><strong>distribution #2</strong></li>
</ul>
<p>Distribution method 2 is a horizontal array of sub-cameras, one per mesh (i.e. like method #0, it does not sum meshes). The image is divided horizontally into <em>#num_meshes</em> blocks, with the first mesh listed being the left-most camera, and the last being the right-most. The most obvious use of this would be with two meshes to generate a stereo camera arrangement.</p>
<p>In this mode, you can (currently) only have a single ray per pixel.</p>
<ul>
<li><strong>distribution #3</strong></li>
</ul>
<p>This method will reverse-map the face from the UV co-ordinates. Currently, only a single ray per pixel is supported, however, unlike the preceding methods, standard AA and jitter will work. This method is particularly useful for texture baking and resolution-independent mesh cameras, but requires that the mesh have a UV map supplied with it.</p>
<p>You can use the smooth modifier to allow interpolation of the normals at the vertices. This allows for use of UV mapped meshes as cameras with the benefit of not being resolution dependent, unlike the other distributions. The interpolation is identical to that used for smooth_triangles.</p>
<p>If used for texture baking, the generated image may have visible seams when applied back to the mesh, this can be mitigated. Also, depending on the way the original UV map was set up, using AA may produce incorrect pixels on the outside edge of the generated maps.</p>

</div>
<a name="r3_4_2_2_3_3"></a>
<div class="content-level-h6" contains="Max Distance" id="r3_4_2_2_3_3">
<h6>3.4.2.2.3.3 Max Distance</h6>
This is an optional floating-point value which, if greater than EPSILON (a very small value used internally for comparisons with 0), will be used as the limit for the length of any rays cast. Objects at a distance greater than this from the ray origin will not be intersected by the ray.

The primary use for this parameter is to allow a mesh camera to 'probe' a scene in order to determine whether or not a given location contains a visible object. Two examples would be a camera that divides the scene into slices for use in 3d printing or to generate an STL file, and a camera that divides the scene into cubes to generate voxel information. In both cases, some external means of processing the generated image into a useful form would be required.

It should be kept in mind that this method of determining spatial information is not guaranteed to generate an accurate result, as it is entirely possible for a ray to miss an object that is within its section of the scene, should that object have features that are smaller than the resolution of the mesh being used. In other words, it is (literally) hit and miss. This issue is conceptually similar to aliasing in a normal render.

It is left as an exercise for the reader to come up with means of generating pixel information that carries useful information, given the lack of light sources within the interior of an opaque object (hint: try ambient).

</div>
<a name="r3_4_2_2_3_4"></a>
<div class="content-level-h6" contains="Mesh Object" id="r3_4_2_2_3_4">
<h6>3.4.2.2.3.4 Mesh Object</h6>
<p>One or more <code>mesh</code> or <code>mesh2</code> objects to be used for the camera. These will be treated differently depending on the distribution method, as explained above. Transformations on the meshes can be used here, and will reflect on the resulting image as it would be expected for a regular camera.</p>

</div>
<a name="r3_4_2_2_3_5"></a>
<div class="content-level-h6" contains="About the Location Vector" id="r3_4_2_2_3_5">
<h6>3.4.2.2.3.5 About the Location Vector</h6>
<p>With this special camera, location doesn't affect where the camera is placed per se (that information is on the mesh object itself), but is used to move the origin of the ray off the face, along the normal of that face. This would typically be done for texture baking or illumination calculation scenes where the camera mesh is also instantiated into the scene, usually only a tiny amount of displacement is needed. The X and Y for location is not currently used, and the Z always refers to the normal of the face, rather than the real Z direction in the scene.</p>

</div>
<a name="r3_4_2_2_3_6"></a>
<div class="content-level-h6" contains="About the Direction Vector" id="r3_4_2_2_3_6">
<h6>3.4.2.2.3.6 About the Direction Vector</h6>
<p>Like location, this doesn't correspond to the real direction vector of the camera. It serves only to reverse the normal of all the faces, if necessary. If the Z component is less than -EPSILON, then the rays will be shot in the opposite direction than they would otherwise have been. X and Y are not used.</p>

</div>
<a name="r3_4_2_2_3_7"></a>
<div class="content-level-h6" contains="The Smooth Modifier" id="r3_4_2_2_3_7">
<h6>3.4.2.2.3.7 The Smooth Modifier</h6>
<p>This optional parameter is only useful with distribution #3, and will cause the ray direction to be interpolated according to the same rules as are applied to smooth triangles. For this to work, the mesh must have provided a normal for each vertex.</p>
<p class="Note"><strong>Note:</strong> See the sample scene files located in <em>~scenes/camera/mesh_camera/</em> for additional usages and other samples of mesh cameras. There are also some useful macros to assist in generating and processing meshes for use as cameras.</p>

</div>
<a name="r3_4_2_2_4"></a>
<div class="content-level-h5" contains="Fisheye projection" id="r3_4_2_2_4">
<h5>3.4.2.2.4 Fisheye projection</h5>
<p> This is a spherical projection. The viewing angle is specified by the <code>angle</code> keyword. An angle of 180 degrees creates the &quot;standard&quot; fisheye while an angle of 360 degrees creates a super-fisheye  or &quot;I-see-everything-view&quot;. If you use this projection you should get a circular image. If this is not the case, i.e. you get an elliptical image, you should read <a href="r3_4.html#r3_4_2_1_6">Aspect Ratio</a>.</p>

<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/a/a1/RefImgCameraViewFisheye.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/f/f5/RefImgCameraSamplefisheye.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The fisheye projection diagram</p>
</td>
<td>
  <p class="caption">A fisheye camera sample image</p>
</td>
</tr>
</table>

<p class="Note"><strong>Note:</strong> The length of the direction, up and right vectors are irrelevant. The <code>angle</code> keyword is the important setting.</p>

</div>
<a name="r3_4_2_2_5"></a>
<div class="content-level-h5" contains="Ultra wide angle projection" id="r3_4_2_2_5">
<h5>3.4.2.2.5 Ultra wide angle projection</h5>
<p>The ultra wide angle projection is somewhat similar to the fisheye, but it projects the image onto a rectangle instead of a circle. The viewing angle can be specified by using the <code>angle</code> keyword. The aspect ratio of the lengths of the up/right vectors are used to provide the vertical angle from the horizontal angle, so that the ratio of vertical angle on horizontal angle is identical to the ratio of the length of up on length of right. When the ratio is one, a square is wrapped on a quartic surface defined as follows:</p>
<p>x<sup>2</sup>+y<sup>2</sup>+z<sup>2</sup>&nbsp;=&nbsp;x<sup>2</sup>y<sup>2</sup>&nbsp;+&nbsp;1</p>
<p>The section where z=0 is a square, the section where x=0 or y=0 is a circle, and the sections parallel to x=0 or y=0 are ellipses. When the ratio is not one, the bigger angle obviously gets wrapped further. When the angle reaches 180, the border meets the square section. The angle can be greater than 180, in that case, when both (vertical and horizontal) angles are greater than 180, the parts around the corners of the square section will be wrapped more than once. The classical usage (using an angle of 360) but with a up/right ratio of 1/2 <code>up 10*y</code> and <code>right 20*x</code> will keep the top of the image as the zenith, and the bottom of the image as the nadir, avoiding perception issues and giving a full 360 degree view.</p>


<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/3/3d/RefImgCameraViewUltrawideangle.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/0/01/RefImgCameraSampleultra_wide_angle.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The ultra wide angle projection diagram</p>
</td>
<td>
  <p class="caption">An ultra wide angle sample image</p>
</td>
</tr>
</table>

</div>
<a name="r3_4_2_2_6"></a>
<div class="content-level-h5" contains="Omnimax projection" id="r3_4_2_2_6">
<h5>3.4.2.2.6 Omnimax projection</h5>
<p>The omnimax projection is a 180 degrees fisheye that has a reduced viewing angle in the vertical direction. In reality this projection is used to make movies that can be viewed in the dome-like Omnimax theaters. The image will look somewhat elliptical.</p>

<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/5/56/RefImgCameraViewOmnimax.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/b/bb/RefImgCameraSampleomnimax.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The omnimax projection diagram</p>
</td>
<td>
  <p class="caption">An omnimax camera sample image</p>
</td>
</tr>
</table>

<p class="Note"><strong>Note:</strong> The use of the <code>angle</code> keyword is irrelevant, the relative length of up and right vectors are what is important.</p>

</div>
<a name="r3_4_2_2_7"></a>
<div class="content-level-h5" contains="Panoramic projection" id="r3_4_2_2_7">
<h5>3.4.2.2.7 Panoramic projection</h5>
<p>This projection is called &quot;cylindrical equirectangular projection&quot;. It overcomes the degeneration problem of the perspective projection if the viewing angle approaches 180 degrees. It uses a type of cylindrical projection to be able to use viewing angles larger than 180 degrees with a tolerable lateral-stretching distortion. The <code>angle</code> keyword is used to determine the viewing angle.</p>

<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/b/b1/RefImgCameraViewPanoramic.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/7/77/RefImgCameraSamplepanoramic.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The panoramic projection diagram</p>
</td>
<td>
  <p class="caption">A panoramic camera sample image</p>
</td>
</tr>
</table>

<p class="Note"><strong>Note:</strong> The <code>angle</code> keyword is irrelevant. The relative length of direction, up and right vectors are important as they define the lengths of the 3 axis of the ellipsoid. With identical length and orthogonal vectors (both strongly recommended, unless used on purpose), it's identical to a spherical camera with angle 180,90.</p>

</div>
<a name="r3_4_2_2_8"></a>
<div class="content-level-h5" contains="Cylindrical projection" id="r3_4_2_2_8">
<h5>3.4.2.2.8 Cylindrical projection</h5>
<p>Using this projection the scene is projected onto a cylinder. There are four different types of cylindrical projections depending on the orientation of the cylinder and the position of the viewpoint. An integer value in the range 1 to 4 must follow the <code>cylinder</code> keyword. The viewing angle and the length of the <code>up</code> or <code>right</code> vector determine the dimensions of the camera and the visible image. The characteristics of different types are as follows:</p>

<ol>
<li>vertical cylinder, fixed viewpoint</li>
<li>horizontal cylinder, fixed viewpoint</li>
<li>vertical cylinder, viewpoint moves along the cylinder's axis</li>
<li>horizontal cylinder, viewpoint moves along the cylinder's axis</li>
</ol>

<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/7/73/RefImgCameraViewCylinder1.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/4/46/RefImgCameraSamplecylinder_1.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The type 1 cylindrical projection diagram</p>
</td>
<td>
  <p class="caption">A type 1 cylindrical camera sample image</p>
</td>
</tr>
</table>
<p></p>
<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/a/ae/RefImgCameraViewCylinder2.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/6/61/RefImgCameraSamplecylinder_2.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The type 2 cylindrical projection diagram</p>
</td>
<td>
  <p class="caption">A type 2 cylindrical camera sample image</p>
</td>
</tr>
</table>

<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/d/d3/RefImgCameraViewCylinder3.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/2/2c/RefImgCameraSamplecylinder_3.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The type 3 cylindrical projection diagram</p>
</td>
<td>
  <p class="caption">A type 3 cylindrical camera sample image</p>
</td>
</tr>
</table>
<p></p>
<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/8/81/RefImgCameraViewCylinder4.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/3/33/RefImgCameraSamplecylinder_4.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The type 4 cylindrical projection diagram</p>
</td>
<td>
  <p class="caption">A type 4 cylindrical camera sample image</p>
</td>
</tr>
</table>

</div>
<a name="r3_4_2_2_9"></a>
<div class="content-level-h5" contains="Spherical projection" id="r3_4_2_2_9">
<h5>3.4.2.2.9 Spherical projection</h5>
<p>Using this projection the scene is  projected onto a sphere.</p>
<p>The syntax is:</p>
<pre>
camera {
  spherical
  [angle HORIZONTAL [VERTICAL]]
  [CAMERA_ITEMS...]
  }
</pre>
<p>The first value after <code>angle</code> sets the horizontal viewing angle of the camera. With the optional second value, the vertical viewing angle is set: both in degrees. If the vertical angle is not specified, it defaults to half the horizontal angle.</p>

<p>The spherical projection is similar to the fisheye projection, in that the scene is projected on a sphere. But unlike the fisheye camera, it uses rectangular coordinates instead of polar coordinates; in this it works the same way as spherical mapping (map_type 1).</p>

<p>This has a number of uses. Firstly, it allows an image rendered with the spherical camera to be mapped on a sphere without distortion (with the fisheye camera, you first have to convert the image from polar to rectangular coordinates in some image editor). Also, it allows effects such as &quot;environment mapping&quot;, often used for simulating reflections in scanline renderers.</p>

<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
<td>
  <img class="leftpanel" width="320px" src="images/e/e6/RefImgCameraViewSpherical.png">
</td>
<td>
  <img class="rightpanel" width="320px" src="images/4/47/RefImgCameraSamplespherical.jpg">
</td>
</tr>
<tr>
<td>
  <p class="caption">The spherical projection diagram</p>
</td>
<td>
  <p class="caption">A spherical camera sample image</p>
</td>
</tr>
</table>

<p class="Note"><strong>Note:</strong> The lengths of the direction, up and right vectors are irrelevant. Angle is the important setting, and it gets two values separated by a comma: the first is the horizontal angle, the second is the vertical angle. Both values can reach 360. If the second value is missing, it is set to half the value of the first.</p>

</div>
<a name="r3_4_2_2_10"></a>
<div class="content-level-h5" contains="User defined projection" id="r3_4_2_2_10">
<h5>3.4.2.2.10 User defined projection</h5>
<p><font class="New">New</font> to version 3.8 a user defined camera capability was added. Similar to the <a href="r3_4.html#r3_4_2_2_3">mesh camera</a> the <code>user_defined</code> camera allows complete control over ray origin and direction, with the advantage of not having to actually load a mesh to function. It's inner workings are also less constrained than the mesh camera.</p>

<p>In addition to being able to duplicate existing camera types, this mechanism can also be easily used for other arbitrary camera formats waiting to be integrated into POV-Ray. This includes light probe style, angular, cube mapping, side-by-side stereo-grams, Omni-Directional Stereo (ODS), Mercator, and other map projections.</p>

<p>The specified functions take screen coordinates in the form of (x,y or u,v) vector pairs as parameters ranging from -0.5 (left/bottom) to 0.5 (right/top), respectively.</p>

<p>See the examples below:</p>
<pre>
// Basic orthographic
#declare Camera01 = camera {
    user_defined
    location {
      function { x }
      function { y }
      function { -5 }
    }
    direction {
      function { 0 }
      function { 0 }
      function { 1 }
    }
}

// Only direction functions specified
#declare Camera01 = camera {
    user_defined
    direction {
      function { x }
      function { y }
      function { 1 }
    }
    location  &lt;0,0,-2&gt;
    rotate    y*5
}

// Only location functions specified
#declare Camera01 = camera {
    user_defined
    location {
      function { x }
      function { y }
      function { -5 }
    }
    look_at   &lt;0,0,1&gt;
}
</pre>

<p>See the distribution scene file <em>~scenes/camera/user_defined.pov</em> for additional usage.</p>

</div>
<a name="r3_4_2_3"></a>
<div class="content-level-h4" contains="Focal Blur" id="r3_4_2_3">
<h4>3.4.2.3 Focal Blur</h4>
<p>POV-Ray can simulate focal depth-of-field by shooting a number of sample rays from jittered points within each pixel and averaging the results.</p>
<p>To turn on focal blur, you must specify the <code>aperture</code> keyword followed by a float value which determines the depth of the sharpness zone. Large apertures give a lot of blurring, while narrow apertures will give a wide zone of sharpness.</p>
<p class="Note"><strong>Note:</strong> While this behaves as a real camera does, the values for aperture are purely arbitrary and are not related to <em>f</em>-stops.</p>
<p>You must also specify the <code>blur_samples</code> keyword followed by an integer value specifying the maximum number of rays to use for each pixel. More rays give a smoother appearance but is slower. By default no focal blur is used, i. e. the default aperture is 0 and the default number of samples is 0.</p>

<p>The center of the <em>zone of sharpness</em> is specified by the <code>focal_point</code> vector. The <em>zone of sharpness</em> is a plane through the <code>focal_point</code> and is parallel to the camera. Objects close to this plane of focus are in focus and those farther from that plane are more blurred. The default value is <code>focal_point &lt;0,0,0&gt;</code>.</p>

<p>Although <code>blur_samples</code> specifies the maximum number of samples, there is an adaptive mechanism that stops shooting rays when a certain degree of confidence has been reached. At that point, shooting more rays would not result in a significant change.</p>
<p>Extra samples are generated in a circular rather than square pattern when <code>blur_samples</code> is <strong>not</strong> set to either 4, 7, 19 or 37, leading to a circular rather than square bokeh. The extra samples are generated from a <em>Halton</em> sequence rather than a random stream. You can also optionally specify a minimum number of samples to be taken before testing against the <code>confidence</code> and <code>variance</code> settings. The default is 4, if the <code>blur_samples</code> maximum is less than 7, otherwise the default is 7, to provide a means to get rid of stray non-blurred pixels.</p>
<p>The syntax is:</p>
<pre>
blur_samples [ MIN_SAMPLES, ] MAX_SAMPLES
</pre>

<p>The <code>confidence</code> and <code>
variance</code> keywords are followed by float values to control the adaptive function. The <code>confidence</code> value is used to determine when the samples seem to be <em>close enough</em> to the correct color. The <code>variance</code> value specifies an acceptable tolerance on the variance of the samples taken so far. In other words, the process of shooting sample rays is terminated when the estimated color value is very likely (as controlled by the confidence probability) near the real color value.</p>
<p>Since the <code>confidence</code> is a probability its values can range from 0 to less than 1 (the default is 0.9, i. e. 90%). The value for the <code>variance</code> should be in the range of the smallest displayable color difference (the default is 1/128). If 1 is used POV-Ray will issue a warning and then use the default instead.</p>
<p>Rendering with the default settings can result in quite grainy images. This can be improved by using a lower <code>variance</code>. A value of 1/10000 gives a fairly good result (with default confidence and blur_samples set to something like 100) without being unacceptably slow.</p>
<p>Larger <code>confidence</code> values will lead to more samples, slower traces and better images. The same holds for smaller <code>variance</code> thresholds.</p>
<p>Focal blur can also support a user-defined <code>bokeh</code> using the following syntax:</p>
<pre>
camera {
  // ... focal blur camera definition
  bokeh {
    pigment { ... }
    }
  }
</pre>
<p>If <code>bokeh</code> is specified, focal blur will use a custom sampling sequence based on the specified pigment's brightness in the range &lt;0,0,0&gt; to &lt;1,1,0&gt; i.e. the unit square in the XY plane.</p>

</div>
<a name="r3_4_2_4"></a>
<div class="content-level-h4" contains="Camera Ray Perturbation" id="r3_4_2_4">
<h4>3.4.2.4 Camera Ray Perturbation</h4>
<p>The optional <code><a href="r3_6.html#r3_6_1_2">normal</a></code> may be used to assign a normal pattern to
the camera. For example:</p>
<pre>
camera{
  location Here
  look_at There
  normal { bumps 0.5 }
  }
</pre>

<p>All camera rays will be perturbed using this pattern. The image will be distorted as though you were looking through bumpy glass or seeing a reflection off of a bumpy surface. This lets you create special effects. See the animated scene <code>camera2.pov</code> for an example. See <a href="r3_6.html#r3_6_1_2">Normal</a> for information on normal patterns.</p>

</div>
<a name="r3_4_2_5"></a>
<div class="content-level-h4" contains="Camera Identifiers" id="r3_4_2_5">
<h4>3.4.2.5 Camera Identifiers</h4>
<p>Camera identifiers may be declared to make scene files more readable and
to parameterize scenes so that changing a single declaration changes many
values. You may declare several camera identifiers if you wish. This makes it
easy to quickly change cameras. An identifier is declared as follows.</p>
<pre>
CAMERA_DECLARATION:
  #declare IDENTIFIER = CAMERA |
  #local IDENTIFIER = CAMERA
</pre>

<p>Where <em>IDENTIFIER</em> is the name of the identifier up to 40
characters long and <em>CAMERA</em> is any valid camera statement. See
<a href="r3_3.html#r3_3_2_2_2">#declare vs. #local</a> for information on identifier scope. Here is an example...</p>
<pre>
#declare Long_Lens =
camera {
  location -z*100
  look_at &lt;0,0,0&gt;
  angle 3
  }

#declare Short_Lens =
camera {
  location -z*50
  look_at &lt;0,0,0&gt;
  angle 15
  }

camera {
  Long_Lens  // edit this line to change lenses
  translate &lt;33,2,0&gt;
  }
</pre>

<p class="Note"><strong>Note:</strong> Only camera transformations can be added to an already declared camera. Camera behaviour changing keywords are not allowed, as they are needed in an earlier stage for resolving the keyword order dependencies.</p></div>

<a name="r3_4_3"></a>
<div class="content-level-h3" contains="Lighting Types" id="r3_4_3">
<h3>3.4.3 Lighting Types</h3>
<p>POV-Ray supports several <em>lighting types</em>. The most basic being a highly configurable conventional <a href="r3_4.html#r3_4_3_1">light source</a>. Scenes <em>can</em> have more than one light source, and light sources can be <a href="r3_4.html#r3_4_3_2">grouped</a> together with other objects and/or light sources. POV-Ray also supports more sophisticated lighting models such as: <em>global illumination</em> or <a href="r3_4.html#r3_4_3_3">radiosity</a> and <a href="r3_4.html#r3_4_3_4">photon</a> mapping.</p></div>

<a name="r3_4_3_1"></a>
<div class="content-level-h4" contains="Light Source" id="r3_4_3_1">
<h4>3.4.3.1 Light Source</h4>

<p>The <code>light_source</code> is not really an object. Light sources have no visible shape of their own. They are just points or areas which emit light. They are categorized as objects so that they can be combined with regular objects using <code>union</code>.</p>
<p class="Note"><strong>Note:</strong> Due to a hard-coded limit the number of light sources should not exceed 127. Since the class of the variable that governs this limit is <em>not exclusive</em> to light sources, a value had to be chosen that provides the best balance between performance, memory use and flexibility. See the following <a href="http://news.povray.org/povray.beta-test/thread/web.4d18ce518224b54c231f2b0b0@news.povray.org/">news-group&nbsp;discussion</a> for more details and information about ways to overcome this limitation.</p>
 
<p>The syntax is as follows:</p>
<pre>
LIGHT_SOURCE:
  light_source {
    &lt;Location&gt;, COLOR
    [LIGHT_MODIFIERS...]
    }
LIGHT_MODIFIER:
  LIGHT_TYPE | SPOTLIGHT_ITEM | AREA_LIGHT_ITEMS |
  GENERAL_LIGHT_MODIFIERS
LIGHT_TYPE:
  spotlight | shadowless | cylinder | parallel
SPOTLIGHT_ITEM:
  radius Radius | falloff Falloff | tightness Tightness |
  point_at &lt;Spot&gt;
PARALLEL_ITEM:
  point_at &lt;Spot&gt;
AREA_LIGHT_ITEM:
  area_light &lt;Axis_1&gt;, &lt;Axis_2&gt;, Size_1, Size_2 |
  adaptive Adaptive | area_illumination [Bool] |
  jitter | circular | orient
GENERAL_LIGHT_MODIFIERS:
  looks_like { OBJECT } |
  TRANSFORMATION fade_distance Fade_Distance |
  fade_power Fade_Power | media_attenuation [Bool] |
  media_interaction [Bool] | projected_through
</pre>

<p>Light source default values:</p>
<pre>
LIGHT_TYPE        : pointlight
falloff           : 70
media_interaction : on
media_attenuation : off
point_at          : &lt;0,0,1&gt;
radius            : 70
tightness         : 10
</pre>

<p>The different types of light sources and the optional modifiers are
described in the following sections.</p>
<p>
The first two items are common to all light sources. The <em><code>&lt;Location&gt;</code></em>
vector gives the location of the light. The <em>COLOR</em> gives the color 
of the light. Only the red, green, and blue components are significant. Any 
transmit or filter values are ignored. </p>
<p class="Note"><strong>Note:</strong> You vary the intensity of the light as well as the color using this parameter. A color such as 
<code>rgb &lt;0.5,0.5,0.5&gt;</code> gives a white light that is half the normal intensity.</p>
<p> All of the keywords or items in the syntax 
specification above may appear in any order. Some keywords only have effect 
if specified with other keywords. The keywords are grouped into functional 
categories to make it clear which keywords work together. The 
<em>GENERAL_LIGHT_MODIFIERS</em> work with all types of lights and all 
options. </p>
<p class="Note"><strong>Note:</strong> <em>TRANSFORMATIONS</em> such as <code><a href="r3_3.html#r3_3_1_12">translate</a></code>, <code><a href="r3_3.html#r3_3_1_12">rotate</a></code> etc. may be applied but no  other <em>OBJECT_MODIFIERS</em> may be used.</p>
<p>
There are three mutually exclusive light types. If no <em>LIGHT_TYPE</em> is
specified it is a point light. The other choices are <code>spotlight</code>
and <code>cylinder</code>.</p>

</div>
<a name="r3_4_3_1_1"></a>
<div class="content-level-h5" contains="Point Lights" id="r3_4_3_1_1">
<h5>3.4.3.1.1 Point Lights</h5>
<p>The simplest kind of light is a point light. A point light source sends
light of the specified color uniformly in all directions. The default light
type is a point source. The <em><code>&lt;Location&gt;</code></em> and <em>
COLOR</em> is all that is required. For example:</p>
<pre>
light_source {
  &lt;1000,1000,-1000&gt;, rgb &lt;1,0.75,0&gt; //an orange light
  }
</pre>

</div>
<a name="r3_4_3_1_2"></a>
<div class="content-level-h5" contains="Spotlights" id="r3_4_3_1_2">
<h5>3.4.3.1.2 Spotlights</h5>
<p>Normally light radiates outward equally in all directions from the source.
However the <code>spotlight</code> keyword can be used to create a cone of
light that is bright in the center and falls of to darkness in a soft fringe
effect at the edge.</p>
<p>
Although the cone of light fades to soft edges, objects illuminated by
spotlights still cast hard shadows. The syntax is:</p>
<pre>
SPOTLIGHT_SOURCE:
  light_source {
    &lt;Location&gt;, COLOR spotlight
    [LIGHT_MODIFIERS...]
    }
LIGHT_MODIFIER:
  SPOTLIGHT_ITEM | AREA_LIGHT_ITEMS | GENERAL_LIGHT_MODIFIERS
SPOTLIGHT_ITEM:
  radius Radius | falloff Falloff | tightness Tightness |
  point_at &lt;Spot&gt;
</pre>
<p>
Default values:
</p>
<pre>
radius:    30 degrees
falloff:   45 degrees
tightness:  0
</pre>

<p>The <code>point_at</code> keyword tells the spotlight to point at a
particular 3D coordinate. A line from the location of the spotlight to the
<code>point_at</code> coordinate forms the center line of the cone of light.
The following illustration will be helpful in understanding how these values
relate to each other.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/4/45/RefImgSpotgeom.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The geometry of a spotlight.</p>
  </td>
</tr>
</table>
<p>The <code>falloff</code>, <code>radius</code>, and <code>tightness</code>
keywords control the way that light tapers off at the edges of the cone.
These four keywords apply only when the <code>spotlight</code> or <code>
cylinder</code> keywords are used.</p>
<p>
The <code>falloff</code> keyword specifies the overall size of the cone of
light. This is the point where the light falls off to zero intensity. The
float value you specify is the angle, in degrees, between the edge of the
cone and center line. The <code>radius</code> keyword specifies the size of
the <em>hot-spot</em> at the center of the cone of light. The
<em>hot-spot</em> is a brighter cone of light inside the spotlight cone
and has the same center line. The <code>radius</code> value specifies the
angle, in degrees, between the edge of this bright, inner cone and the center
line. The light inside the inner cone is of uniform intensity. The light
between the inner and outer cones tapers off to zero.</p>
<p>
For example, assuming a <code>tightness 0</code>, with <code>radius 10</code> and <code>falloff 20</code> the light
from the center line out to 10 degrees is full intensity. From 10 to 20
degrees from the center line the light falls off to zero intensity. At 20
degrees or greater there is no light.</p>
<p class="Note"><strong>Note:</strong> If the radius and falloff
values are close or equal the light intensity drops rapidly and the spotlight
has a sharp edge.</p>
<p>
The values for the <code>radius</code>, and <code>tightness</code> parameters are half the opening angles of the
corresponding cones, both angles have to be smaller than 90 degrees. The
light smoothly falls off between the radius and the falloff angle like shown
in the figures below (as long as the radius angle is not negative).</p>

<table class="matte" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/0/0b/RefImgFixfallo.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Intensity multiplier curve with a fixed falloff angle of 45 degrees.</p>
  </td>
</tr>
</table>
<p>&nbsp;</p>
<table class="matte" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/c/c8/RefImgFixedrad.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Intensity multiplier curve with a fixed radius angle of 45 degrees.</p>
  </td>
</tr>
</table>

<p>The <code>tightness</code> keyword is used to specify an <em>
additional</em> exponential softening of the edges. A value other than 0, will
affect light within the radius cone as well as light in the falloff cone. 
The intensity of light at an angle from the center line is given by: 
<em><code>intensity * cos(angle)tightness</code></em>.
The default value for tightness is 0. Lower
tightness values will make the spotlight brighter, making the spot wider and
the edges sharper. Higher values will dim the spotlight, making the spot
tighter and the edges softer. Values from 0 to 100 are acceptable.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/1/14/RefImgDiftight.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Intensity multiplier curve with fixed angle and falloff angles of 30 and 60 degrees respectively and different tightness values.</p>
  </td>
</tr>
</table>

<p>You should note from the figures that the radius and falloff angles
interact with the tightness parameter. To give the tightness value full control
over the spotlight's appearance use radius 0 falloff 90. As you
can see from the figure below. In that case the falloff angle has no effect
and the lit area is only determined by the tightness parameter.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/e/e2/RefImgNegradli.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Intensity multiplier curve with a negative radius angle and different tightness values.</p>
  </td>
</tr>
</table>

<p>Spotlights may be used any place that a normal light source is used. Like
any light sources, they are invisible. They may also be used in conjunction
with area lights.</p>

</div>
<a name="r3_4_3_1_3"></a>
<div class="content-level-h5" contains="Cylindrical Lights" id="r3_4_3_1_3">
<h5>3.4.3.1.3 Cylindrical Lights</h5>
<p>The <code>cylinder</code> keyword specifies a cylindrical light source
that is great for simulating laser beams. Cylindrical light sources work
pretty much like spotlights except that the light rays are constrained by a
cylinder and not a cone. The syntax is:</p>
<pre>
CYLINDER_LIGHT_SOURCE:
  light_source {
    &lt;Location&gt;, COLOR cylinder
    [LIGHT_MODIFIERS...]
    }
LIGHT_MODIFIER:
  SPOTLIGHT_ITEM | AREA_LIGHT_ITEMS | GENERAL_LIGHT_MODIFIERS
SPOTLIGHT_ITEM:
  radius Radius | falloff Falloff | tightness Tightness |
  point_at &lt;Spot&gt;
</pre>
<p>
Default values:
</p>
<pre>
radius:     0.75 degrees
falloff:    1    degrees
tightness:  0
</pre>

<p>The <code>point_at</code>, <code>radius</code>, <code>falloff</code> and
<code>tightness</code> keywords control the same features as with the
spotlight. See <a href="r3_4.html#r3_4_3_1_2">Spotlights</a> for details.</p>

<p>You should keep in mind that the cylindrical light source is still a point
light source. The rays are emitted from one point and are only constraint by
a cylinder. The light rays are not parallel.</p>

</div>
<a name="r3_4_3_1_4"></a>
<div class="content-level-h5" contains="Parallel Lights" id="r3_4_3_1_4">
<h5>3.4.3.1.4 Parallel Lights</h5>
<pre>
syntax:

light_source {
  LOCATION_VECTOR, COLOR
  [LIGHT_SOURCE_ITEMS...]
  parallel
  point_at VECTOR
  }
</pre>

<p>The <code>parallel</code> keyword can be used with any type of light source.</p>
<p class="Note"><strong>Note:</strong> For normal point lights, <code>point_at</code> must come after
<code>parallel</code>.</p>

<p>Parallel lights are useful for simulating very distant light sources, such as
sunlight. As the name suggests, it makes the light rays parallel.</p>
<p>Technically this is done by shooting rays from the closest point on a plane to the
object intersection point. The plane is determined by a perpendicular defined by the
light <code>location</code> and the <code>point_at</code> vector.</p>

<p>Two things must be considered when choosing the light location
(specifically, its distance):</p><ol>
<li>Any parts of an object <em>above</em> the light plane still get illuminated according to
the light direction, but they will not cast or receive shadows.</li>
<li><code>fade_distance</code> and <code>fade_power</code> use the light
<code>location</code> to determine distance for light attenuation, so the attenuation
still looks like that of a point source.
<br>Area light also uses the light location in its calculations.</li></ol>

</div>
<a name="r3_4_3_1_5"></a>
<div class="content-level-h5" contains="Area Lights" id="r3_4_3_1_5">
<h5>3.4.3.1.5 Area Lights</h5>
<p>Area light sources occupy a finite, one or two-dimensional area of space. They can cast soft shadows because an object can partially block their light. Point sources are either totally blocked or not blocked.</p>
<p>The <code>area_light</code> keyword in POV-Ray creates sources that are rectangular in shape, sort of like a flat panel light. Rather than performing the complex calculations that would be required to model a true area light, it is approximated as an array of point light sources spread out over the area occupied by the light. The array-effect applies to shadows only, however with the addition of the <code>area_illumination</code> keyword,  full area light diffuse and specular illumination can be achieved. The object's illumination is still that of a point source. The intensity of each individual point light in the array is dimmed so that the total amount of light emitted by the light is equal to the light color specified in the declaration. The syntax is:</p>
<pre>
AREA_LIGHT_SOURCE:
  light_source {
    LOCATION_VECTOR, COLOR
    area_light
    AXIS_1_VECTOR, AXIS_2_VECTOR, Size_1, Size_2
    [ adaptive Adaptive ] [ area_illumination on/off ]
    [ jitter ] [ circular ] [ orient ]
    [ [LIGHT_MODIFIERS...]
    }
</pre>

<p>Any type of light source may be an area light. </p>

<p>The <code>area_light</code> keyword defines the location, the size and orientation of the area light as well as the number of lights in the light source array. The location vector is the centre of a rectangle defined by the two vectors <em><code>&lt;Axis_1&gt;</code></em> and <em><code>&lt;Axis_2&gt;</code></em>. These specify the lengths and directions of the edges of the light.</p>

<table class="centered" width="340x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="320px" src="images/a/a8/RefImgAreal.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">4x4 Area light, location and vectors.</p>
  </td>
</tr>
</table>

<p>Since the area lights are rectangular in shape these vectors should be perpendicular to each other. The larger the size of the light the thicker the soft part of shadows will be. The integers Size_1 and Size_2 specify the number of rows and columns of point sources of the. The more lights you use the smoother the shadows, but render time will increase.</p>

<p class="Note"><strong>Note:</strong> It is possible to specify spotlight parameters along with the area light parameters to create area spotlights. Using area spotlights is a good way to speed up scenes that use area lights since you can confine the lengthy soft shadow calculations to only the parts of your scene that need them.</p>
<p>An interesting effect can be created using a linear light source. Rather than having a rectangular shape, a linear light stretches along a line sort of like a thin fluorescent tube. To create a linear light just create an area light with one of the array dimensions set to 1.</p>

<p class="Note"><strong>Note:</strong> In version 3.7 experimental support for full area light diffuse and specular illumination was added. </p>
<p>This feature is off by default, so area lights will work as previously expected, and can be turned on by specifying the <code>area_illumination</code> keyword, followed by the optional on/off keyword, in the light source definition. As with area lights, the Size_1 and Size_2 parameters determine the quality of the lighting, as well as the quality of the shadows.</p>

<p>The <code>jitter</code> keyword is optional. When used it causes the positions of the point lights in the array to be randomly jittered to eliminate any shadow banding that may occur. The jittering is completely random from render to render and should not be used when generating animations.</p>

<p>The <code>adaptive</code> keyword is used to enable adaptive sampling of the light source. By default POV-Ray calculates the amount of light that reaches a surface from an area light by shooting a test ray at every point light within the array. As you can imagine this is very slow. Adaptive sampling on the other hand attempts to approximate the same calculation by using a minimum number of test rays. The number specified after the keyword controls how much adaptive sampling is used. The higher the number the more accurate your shadows will be but the longer they will take to render. If you are not sure what value to use a good starting point is <code>adaptive 1</code>. The <code>adaptive</code> keyword only accepts integer values and cannot be set lower than 0.</p>

<p>When performing adaptive sampling POV-Ray starts by shooting a test ray at each of the four corners of the area light. If the amount of light received from all four corners is approximately the same then the area light is assumed to be either fully in view or fully blocked. The light intensity is then calculated as the average intensity of the light received from the four corners. However, if the light intensity from the four corners differs significantly then the area light is partially blocked. The area light is split into four quarters and each section is sampled as described above. This allows POV-Ray to rapidly approximate how much of the area light is in view
without having to shoot a test ray at every light in the array. Visually the sampling goes like shown below.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/1/18/RefImgArealigh.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Area light adaptive samples.</p>
  </td>
</tr>
</table>

<p>While the adaptive sampling method is fast (relatively speaking) it can sometimes produce inaccurate shadows. The solution is to reduce the amount of adaptive sampling without completely turning it off. The number after the adaptive keyword adjusts the number of times that the area light will be split before the adaptive phase begins. For example if you use <code>adaptive 0</code> a minimum of 4 rays will be shot at the light. If you use <code>adaptive 1</code> a minimum of 9 rays will be shot (<code>adaptive
2</code> gives 25 rays, <code>adaptive 3</code> gives 81 rays, etc). Obviously the more shadow rays you shoot the slower the rendering will be so you should use the lowest value that gives acceptable results.</p>
<p>The number of rays never exceeds the values you specify for rows and columns of points. For example <code>area_light x,y,4,4</code> specifies a 4 by 4 array of lights. If you specify <code>adaptive 3</code> it would mean that you should start with a 9 by 9 array. In this case no adaptive sampling is done. The 4 by 4 array is used.</p>

<p>The <code>circular</code> keyword has been added to area lights in order to better create circular soft shadows. With ordinary area lights the pseudo-lights are arranged in a rectangular grid and thus project partly rectangular shadows around all objects, including circular objects. By including the <code>circular</code> tag in an area light, the light is stretched and squashed so that it looks like a circle: this way, circular or spherical light sources are better simulated.</p>
<p>A few things to remember:</p>
<ul>
<li>Circular area lights can be ellipses: the AXIS_1_VECTOR and AXIS_2_VECTOR
define the shape and orientation of the circle; if the vectors are not equal, the light
source is elliptical in shape.</li>
<li>Rectangular artefacts may still show up with very large area grids.</li>
<li>There is no point in using <code>circular</code> with linear area lights or area lights which have a  2x2 size.</li>
<li>The area of a circular light is roughly 78.5 per cent of a similar size rectangular area light.  Increase your axis vectors accordingly if you wish to keep the light source area constant.</li>
</ul>

<p>The <code>orient</code> keyword has been added to area lights in order to better create soft shadows. Without this modifier, you have to take care when choosing the axis vectors of an area_light, since they define both its area and orientation. Area lights are two dimensional: shadows facing the area light receive light from a larger surface area than shadows at the sides of the area light.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/6/63/RefImgArea2.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Area light facing object.</p>
  </td>
</tr>
</table>

<p>Actually, the area from which light is emitted at the sides of the area light is reduced to a single line, only casting soft shadows in one direction.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/6/65/RefImgArea1.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Area light not facing object.</p>
  </td>
</tr>
</table>

<p>Between these two extremes the surface area emitting light progresses gradually. By including the <code>orient</code> modifier in an area light, the light is rotated so that for every shadow test, it always faces the point being tested. The initial orientation is no longer important, so you only have to consider the desired dimensions (area) of the light source when specifying the axis vectors. In effect, this makes the area light source appear 3-dimensional (e.g. an area_light with perpendicular axis vectors of the same size and dimensions using <code>circular</code> <em>and</em> <code>orient</code> simulates a spherical light source).</p>

<p>Orient has a few restrictions:</p>

<ol>
<li>It can be used with <em>circular</em> lights only.</li>
<li>The two axes of the area light must be of equal length.</li>
<li>The two axes of the area light should use an equal number of samples, and that number should be greater than one</li>
</ol>
<p>These three rules exist because without them, you can get unpredictable results from the orient feature.</p>

<p>If one of the first two rules is broken, POV-Ray will issue a warning and correct the problem. If the third rule is broken, you will only get the error message, and POV-Ray will not automatically correct the problem.</p>

</div>
<a name="r3_4_3_1_6"></a>
<div class="content-level-h5" contains="Shadowless Lights" id="r3_4_3_1_6">
<h5>3.4.3.1.6 Shadowless Lights</h5>
<p>Using the <code>shadowless</code> keyword you can stop a light source from
casting shadows. These lights are sometimes called <em>fill lights</em>.
They are another way to simulate ambient light however shadowless lights have
a definite source. The syntax is:</p>
<pre>
SHADOWLESS_LIGHT_SOURCE:
  light_source {
    &lt;Location&gt;, COLOR shadowless
    [LIGHT_MODIFIERS...]
    }
LIGHT_MODIFIER:
  AREA_LIGHT_ITEMS | GENERAL_LIGHT_MODIFIERS
</pre>

<p><code>shadowless</code> may be used with all types of light sources.
The only restriction is that <code>shadowless</code> should be before or
after <em>all</em> spotlight or cylinder option keywords. Do not mix or you get
the message <em>Keyword 'the one following shadowless' cannot be used with
standard light source</em>. Also note that shadowless lights will not cause
highlights on the illuminated objects.</p>

</div>
<a name="r3_4_3_1_7"></a>
<div class="content-level-h5" contains="Looks Like" id="r3_4_3_1_7">
<h5>3.4.3.1.7 Looks Like</h5>
<p>By default a light source has no visible shape. The light simply radiates from an invisible point or area, however there are cases where this is not desired. Using <code>looks_like</code> is as an easy way to override this behavior. There is an implied <code>no_shadow</code> so that light is not blocked by the object, without it the light inside a non-transparent object could not escape. The object would, in effect, cast a shadow over everything.</p>

<p>When using <code>looks_like</code> there are a few important things to consider:</p>
<ol>
  <li>the object should be positioned at the origin</li>
  <li>it's generally easier but not <em>necessary</em> to declare the object beforehand</li>
  <li>works with point <em>and</em> spot lights <em>not</em> parallel lights</li>
  <li>use a union instead if you want the object to block light and remember to make <em>some</em> portion of the object transparent</li>
</ol>

<p>See the following examples:</p>
<pre>
#declare My_Lamp_Shape = sphere { &lt;0, 0, 0&gt;, Some_Radius }

// using looks_like
light_source {
  &lt;100, 200, -300&gt; color White
  looks_like { My_Lamp_Shape }
  }

// using union
union {
  light_source { &lt;100, 200, -300&gt; color White }
  object { My_Lamp_Shape translate &lt;100, 200, -300&gt; }
  }
</pre>

</div>
<a name="r3_4_3_1_8"></a>
<div class="content-level-h5" contains="Projected Through" id="r3_4_3_1_8">
<h5>3.4.3.1.8 Projected Through</h5>
<p>You can use <code>projected_through</code> with any type of light source. Any object can be used, provided it has been declared beforehand. Projecting a light through an object can be thought of as the opposite of shadowing, in that only the light rays that hit the projected through object will contribute to the scene. This also works with <a href="r3_4.html#r3_4_3_1_5">area lights</a> producing spots of light with soft edges. Any objects between the light and the projected through object will not cast shadows, additionally any surface within the projected through object will not cast shadows. Any textures or interiors on the object will be stripped and the object will not show up in the scene.</p>
<p>The syntax is as follows:</p>
<pre>
light_source {
  LOCATION_VECTOR, COLOR
  [LIGHT_SOURCE_ITEMS...]
  projected_through { OBJECT }
  }
</pre>

</div>
<a name="r3_4_3_1_9"></a>
<div class="content-level-h5" contains="Light Fading" id="r3_4_3_1_9">
<h5>3.4.3.1.9 Light Fading</h5>
<p>By default POV-Ray does not diminish light from any light source as it
travels through space. In order to get a more realistic effect <code>
fade_distance</code> and <code>fade_power</code> keywords followed by float
values can be used to model the distance based falloff in light
intensity.</p>

<p>The <code>fade_distance</code> is used to specify the distance at which the full light intensity arrives, i.e.: the intensity which was given by the <code>color</code> attribute. The actual attenuation is described by the <code>fade_power</code> keyword, which determines the falloff rate. For example linear or quadratic falloff can be used by setting the <code>fade_power</code> to 1 or 2 respectively.</p>

<p>The complete formula to calculate the factor by which the light is attenuated is:</p>

<table class="centered" width="415px" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <!--<img src="ref_tex/lattenua.tex" alt="">---><img class="center" width="395px" src="images/6/69/RefImgLattenua.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The attenuation of light fading formula</p>
  </td>
</tr>
</table>

<p>Where <em><code>d</code></em> is the distance the light has traveled.</p>

<table class="centered" width="660px" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/4/4d/RefImgLfadefx.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Light fading functions for different fading powers</p>
  </td>
</tr>
</table>

<p>With any given value for <code>fade_distance</code>, either larger <em>OR</em> smaller than one, the light intensity at distances smaller than that given value actually increases. The internal calculation used to determine the <em>attenuation</em> factor is set up in a way so that one could set the fade distance and know that for any given fade distance, the light value would equal the set intensity. Lastly, only light coming directly from light sources is attenuated, and that reflected or refracted light is not attenuated by distance.</p>

<p>However, further investigation does reveal certain short comings with this method, as it doesn't follow a very good inverse-squared relationship over the fade distance and somewhat beyond.  In other words, the function does break down to be very close to inverse squared as the distance from the given value for <code>fade_distance</code> gets significantly larger.</p>

<p>To that end consider the following:</p>

<p>A value for the light source intensity can be easily calculated when you take into account the distance from the light source to the scene center, or the object to be illuminated, and you set a relatively small value for <code>fade_distance</code> e.g.: the size of the light itself, relative to the scene dimensions.</p>

<p>The following example, that takes the reciprocal of the above formula that was used to calculate the factor by which the light is attenuated.</p>

<pre>
// setup the function
#declare Intensity_Factor = function (LD,FD,FP) {(1+pow(LD/FD,FP))/2};

// the translated position of the light source
#declare Light_Position = &lt;0,0,-2400&gt;;

// determine the light distance
#declare Light_Distance = vlength(Light_Position-&lt;0,0,0&gt;);

// scaled size of the light source
#declare Fade_Distance = 4.5;

// linear (1) or quadratic (2) falloff 
#declare Fade_Power = 2;
</pre>

<p class="Note"><strong>Note:</strong> The above example calculates <em>Light_Distance</em> to the scene center, but you could have just as easily used the location of an object.</p>

<p>Now all you have to do is setup the light source. The <code>#debug</code> statements make it easy to see whats going on while tuning the light source.</p>

<pre>
#debug concat ("\nFade Distance: ", str(Fade_Distance,2,4))
#debug concat ("\nLight Distance: ", str(Light_Distance,5,4)," \n")
#debug concat ("Intensity Factor: ", str(Intensity_Factor (Light_Distance, Fade_Distance, Fade_Power),6,4)
#debug concat ("\n\n")

light_source {
  0, rgb &lt;0.9,0.9,1&gt; * Intensity_Factor (Light_Distance, Fade_Distance, Fade_Power)
  fade_distance Fade_Distance
  fade_power Fade_Power
  translate Light_Position
  }
</pre>

<p>At first glance this may seem counter-intuitive but it works out well given the small value used for <em>Fade_Distance</em>. You should be aware that this method is meant to give a light strength value of <em>ONE</em> at the point of interest <em>ONLY</em>. In other words, the point represented by the calculated value <em>Light_Distance</em> in the above example. Naturally objects closer to the light source will get a stronger illumination, while objects further away will receive less.</p>

<p class="Note"><strong>Note:</strong> For maximum realism, use <code>fade_power 2</code> and set <code>fade_distance</code> to the approximate radius of the object supposedly giving off the light, e.g. the radius of a frosted incandescent light bulb, half the length of the tungsten filament in a clear incandescent light bulb, etc.; if this makes the light seem too dim, compensate by boosting the light source brightness. There is nothing wrong with a light source having a color of <code>rgb &lt;10000,8000,2000&gt;</code> if that's what it takes.</p>

<p><font class="New">New</font> in POV-Ray 3.8 is an alternative mode for distance-based light fading, in which the light intensity follows an inverse power law at all distances. To activate this mode, specify <code>fade_distance 0</code>. Nominal light intensity is then achieved at unit distance. For backward compatibility, this mode <em>requires</em> <code>#version 3.8</code> or higher to be set.</p>

</div>
<a name="r3_4_3_1_10"></a>
<div class="content-level-h5" contains="Atmospheric Media Interaction" id="r3_4_3_1_10">
<h5>3.4.3.1.10 Atmospheric Media Interaction</h5>
<p>By default light sources will interact with an atmosphere added to the
scene. This behavior can be switched off by using <code>media_interaction off</code>
inside the light source statement. </p>
<p class="Note"><strong>Note:</strong> In POV-Ray 3.0 this feature was turned off
and on with the <code>atmosphere</code> keyword.</p>

</div>
<a name="r3_4_3_1_11"></a>
<div class="content-level-h5" contains="Atmospheric Attenuation" id="r3_4_3_1_11">
<h5>3.4.3.1.11 Atmospheric Attenuation</h5>
<p>Normally light coming from light sources is not influenced by fog or
atmospheric media. This can be changed by turning the <code>media_attenuation on</code>
for a given light source on. All light coming from this light source will now
be diminished as it travels through the fog or media. This results in an
distance-based, exponential intensity falloff ruled by the used fog or media.
If there is no fog or media no change will be seen.</p>
<p class="Note"><strong>Note:</strong> In POV-Ray 3.0 this
feature was turned off and on with the <code>atmospheric_attenuation</code> keyword.</p></div>

<a name="r3_4_3_2"></a>
<div class="content-level-h4" contains="Light Group" id="r3_4_3_2">
<h4>3.4.3.2 Light Group</h4>

<p>Light groups make it possible to create a <code>union</code> of light sources and objects, where the objects in the group are illuminated by the lights in the group or, if so desired, by the global light sources as well. The light sources in the group can <em>only</em> illuminate the objects that are in the group, this also applies to <code>scattering</code> media, and it <em>must</em> be included in the light group as well. Keep in mind that if the scattering media also has an <code>absorption</code> component, it <em>will</em> be affected by light sources that are <em>not</em> in the light group definition.</p>

<p>Light groups are for example useful when creating scenes in which some objects turn out to be too dark but the average light is exactly how it should be, as the light sources in the group do not contribute to the global lighting.</p>

<p>Syntax :</p>
<pre>
light_group {
  LIGHT_GROUP LIGHT  |
  LIGHT_GROUP OBJECT |
  LIGHT_GROUP
  [LIGHT_GROUP MODIFIER]
  }

LIGHT_GROUP LIGHT:
  light_source | light_source IDENTIFIER
LIGHT_GROUP OBJECT: 
  OBJECT | OBJECT IDENTIFIER
LIGHT_GROUP MODIFIER: 
  global_lights BOOL | TRANSFORMATION
</pre>

<ul>
  <li>To illuminate objects in the group with the light from global light sources, add <code>global_lights on</code> to the light group definition.</li>
  <li>Light groups may be nested. In this case light groups inherit the light sources of the light group in which they are contained.</li>
  <li>Light groups can be seen as a <code>union</code> of an object with a <code>light_source</code> and can be used with CSG.</li>
</ul>

<p>Some examples of a simple light group:</p>

<pre>
#declare RedLight = 
light_source {
  &lt;-500,500,-500&gt;
  rgb &lt;1,0,0&gt;
  }

light_group {
  light_source {RedLight}
  sphere {0,1 pigment {rgb 1}}
  global_lights off
  }
</pre>

<p>A nested light group:</p>

<pre>
#declare L1 = 
light_group {
  light_source {&lt;10,10,0&gt;, rgb &lt;1,0,0&gt;}
  light_source {&lt;0,0,-100&gt;, rgb &lt;0,0,1&gt;}
  sphere {0,1 pigment {rgb 1}}
  }

light_group {
  light_source {&lt;0,100,0&gt;, rgb 0.5}
  light_group {L1}
  }
</pre>

<p>Light groups with CSG:</p>
<pre>
difference {
  light_group {
    sphere {0,1 pigment {rgb 1}}
    light_source {&lt;-100,0,-100&gt; rgb &lt;1,0,0&gt;}
    global_lights off
    }
  light_group {
    sphere {&lt;0,1,0&gt;,1 pigment {rgb 1}}
    light_source {&lt;100,100,0&gt; rgb &lt;0,0,1&gt;}
    global_lights off
    }
  rotate &lt;-45,0,0&gt;
  }
</pre>
<p>In the last example the result will be a sphere illuminated red, where the part that is differenced away is illuminated blue. The end result is comparable to the difference between two spheres with a different pigment.</p></div>

<a name="r3_4_3_3"></a>
<div class="content-level-h4" contains="Radiosity" id="r3_4_3_3">
<h4>3.4.3.3 Radiosity</h4>
</div>
<a name="r3_4_3_3_1"></a>
<div class="content-level-h5" contains="Radiosity Basics" id="r3_4_3_3_1">
<h5>3.4.3.3.1 Radiosity Basics</h5>
<p>Radiosity is an extra calculation that more realistically computes the diffuse inter-reflection of light. This diffuse inter-reflection can be seen if you place a white chair in a room full of blue carpet, blue walls and blue curtains. The chair will pick up a blue tint from light reflecting off of other parts of the room. Also notice that the shadowed areas of your surroundings are not totally dark even if no light source shines directly on the surface. Diffuse light reflecting off of other objects fills in the shadows. Typically ray-tracing uses a trick called <em> ambient</em> light to simulate such effects but it is not very accurate.</p>
<p>Radiosity calculations are only made when a <code>radiosity{}</code> block is used inside the <code>global_settings{}</code> block.</p>
<p>The following sections describes how radiosity works, how to control it with various global settings and tips on trading quality vs. speed.</p>

</div>
<a name="r3_4_3_3_2"></a>
<div class="content-level-h5" contains="How Radiosity Works" id="r3_4_3_3_2">
<h5>3.4.3.3.2 How Radiosity Works</h5>
<p>The problem of ray-tracing is to figure out what the light level is at each point that you can see in a scene. Traditionally, in ray tracing, this is broken into the sum of these components:</p>

<dl>
<dt>Diffuse</dt><dd>the effect that makes the side of things facing the light brighter;</dd>
<dt>Specular</dt><dd>the effect that makes shiny things have dings or sparkles on them;</dd>
<dt>Reflection</dt><dd>the effect that mirrors give; and</dd>
<dt>Ambient</dt><dd>the general all-over light level that any scene has, which keeps things in shadow from being pure black.</dd>
</dl>

<p>POV-Ray's radiosity system, based on a method by Greg Ward, provides a way to replace the last term - the constant ambient light value - with a light level which is based on what surfaces are nearby and how bright in turn they are.</p>
<p>The first thing you might notice about this definition is that it is circular: the brightness and color of everything is dependent on everything else and vice versa. This is true in real life but in the world of ray-tracing, we can make an approximation. The approximation that is used is: the objects you are looking at have their <code>ambient</code> values calculated for you by
checking the other objects nearby. When those objects are checked during this process, however, their <code>diffuse</code> term is used. The brightness of radiosity in POV-Ray is based on two things:</p>

<ol>
<li>the amount of light gathered</li>
<li>the diffuse property of the surface finish</li>
</ol>

<p class="Note"><strong>Note:</strong> The following is an <em>important</em> behavior change!</p>
<p>Previously an object could have both radiosity and an ambient term. This is no longer the case, as when radiosity is used an objects ambient term is effectively set to zero. See the <code><a href="r3_6.html#r3_6_1_3_2">emission</a></code> keyword that has been added to the <code>finish</code> block if the intent is to model a glowing object.</p>
<p>How does POV-Ray calculate the ambient term for each point? By sending out more rays, in many different directions, and averaging the results. A typical point might use 200 or more rays to calculate its ambient light level correctly.</p>
<p>Now this sounds like it would make the ray-tracer 200 times slower. This is true, except that the software takes advantage of the fact that ambient light levels change quite slowly (remember, shadows are calculated separately, so sharp shadow edges are not a problem). Therefore, these extra rays are sent out only <em>once in a while</em> (about 1 time in 50), then these calculated
values are saved and reused for nearby pixels in the image when possible.</p>
<p>This process of saving and reusing values is what causes the need for a variety of tuning parameters, so you can get the scene to look just the way you want.</p>

</div>
<a name="r3_4_3_3_3"></a>
<div class="content-level-h5" contains="Adjusting Radiosity" id="r3_4_3_3_3">
<h5>3.4.3.3.3 Adjusting Radiosity</h5>
<p>As described earlier, radiosity is turned on by using the <code>radiosity{}</code> block in <code>global_setting</code>.
Radiosity has many parameters that are specified as follows:</p>
<pre>
global_settings { radiosity { [RADIOSITY_ITEMS...] } }
RADIOSITY_ITEMS:
  adc_bailout Float | always_sample Bool | brightness Float | 
  count Integer [,Integer] | error_bound Float | gray_threshold Float |
  low_error_factor Float | max_sample Float | media Bool |
  maximum_reuse Float | minimum_reuse Float | nearest_count Integer [,Integer] |
  normal Bool | pretrace_start Float | 
  pretrace_end Float | recursion_limit Integer | subsurface Bool
</pre>

<p>Each item is optional and may appear in any order. If an item is specified more than once the last setting overrides previous values. Details on each item is given in the following sections.</p>

<p class="Note"><strong>Note:</strong> Considerable changes have been made to the way radiosity works in POV-Ray 3.7
compared to previous versions. Old scenes will not render with exactly the same results. It is <em>not</em> possible to use the <code>#version</code> directive to get backward compatibility for radiosity.</p>  

</div>
<a name="r3_4_3_3_3_1"></a>
<div class="content-level-h6" contains="adc_bailout" id="r3_4_3_3_3_1">
<h6>3.4.3.3.3.1 adc_bailout</h6>
<p>You can specify an adc_bailout for radiosity rays. Usually the default of 0.01 will give good results, but for scenes with bright emissive objects it should be set to <code>adc_bailout = 0.01 / brightest_emissive_object</code>.</p>

</div>
<a name="r3_4_3_3_3_2"></a>
<div class="content-level-h6" contains="always_sample" id="r3_4_3_3_3_2">
<h6>3.4.3.3.3.2 always_sample</h6>
<p>Since <code>always_sample off</code> is the default, POV-Ray will only use the data from the pretrace step and not gather any new samples during the final radiosity pass. This produces higher quality results, and quicker renders. It may also reduce the splotchy appearance of the radiosity samples, and can be very useful when reusing previously saved radiosity data. If you find the need to override the behavior, you can do so by specifying <code>always_sample on</code>.</p>

</div>
<a name="r3_4_3_3_3_3"></a>
<div class="content-level-h6" contains="brightness" id="r3_4_3_3_3_3">
<h6>3.4.3.3.3.3 brightness</h6>
<p>The <code>brightness</code> keyword specifies a float value that is the degree to which objects are brightened before being returned upwards to the rest of the system. Ideally brightness should be set to the default value of 1.0. If the overall brightness doesn't seem to fit, the diffuse color of objects and/or the overall brightness of light sources (including emission &gt; 0 objects) should be adjusted.</p>
<p>As an example, a typical problem encountered in radiosity scenes is, when setting <code>pigment {rgb 1}</code> and <code>diffuse 1.0</code>, then tweaking the light source(s) and <code>ambient_light</code> setting to make the image look right. It just doesn't work properly in radiosity scenes, as it will give too strong inter-reflections. While you <em>can</em> compensate for this by reducing radiosity brightness, it's generally discouraged. In this case the surface properties should be fixed (e.g. diffuse set to something around 0.7, which is much more realistic).</p>
<p>An exception, calling for the adjustment of radiosity brightness, would be to compensate for a low <code>recursion_limit</code> setting (e.g <code>recursion_limit 1</code>). In such a case, increasing <code>brightness</code> will help maintain a realistic overall brightness.</p>

</div>
<a name="r3_4_3_3_3_4"></a>
<div class="content-level-h6" contains="count" id="r3_4_3_3_3_4">
<h6>3.4.3.3.3.4 count</h6>
<p>The integer number of rays that are sent out whenever a new radiosity value has to be calculated is given by <code>count</code>. The default value is 35, if the value exceeds 1600, POV-Ray will use a <em>Halton</em> sequence instead of the default built-in sequence. When this value is too low, the light level will tend to look a little bit blotchy, as if the surfaces you are looking at were slightly warped. If this is not important to your scene (as in the case that you have a bump map or if you have a strong texture) then by all means use a lower number.</p>
<p>By default, POV-Ray uses the same set of directions for each new radiosity value to calculate. In order to cover more directions in total without increasing the number of rays to trace, <code>count</code> accepts an optional second parameter which specifies the total number of directions from which to choose. POV-Ray will then draw directions from this pool in a round-robin fashion.</p>

</div>
<a name="r3_4_3_3_3_5"></a>
<div class="content-level-h6" contains="error_bound" id="r3_4_3_3_3_5">
<h6>3.4.3.3.3.5 error_bound</h6>
<p>The <code>error_bound</code> float value is one of the two main speed/quality tuning values (the other is of course the number of rays shot).  In an ideal world, this would be the <em>only</em> value needed. It is intended to mean the fraction of error tolerated. For example, if it were set to 1 the algorithm would not calculate a new value until the error on the last one was estimated at as high as 100%. Ignoring the error introduced by rotation for the moment, on flat surfaces this is equal to the fraction of the reuse distance, which in turn is the distance to the closest item hit. If you have an old sample on the floor 10 inches from a wall, an error bound of 0.5 will get you a new sample at a distance of about 5 inches from the wall.</p>
<p>The default value of 1.8 is good for a smooth general lighting effect. Using lower values is more accurate, but it will strongly increase the danger of artifacts and therefore require higher <code>count</code>.  You can use values even lower than 0.1 but both render time and memory use can become extremely high.</p>

</div>
<a name="r3_4_3_3_3_6"></a>
<div class="content-level-h6" contains="gray_threshold" id="r3_4_3_3_3_6">
<h6>3.4.3.3.3.6 gray_threshold</h6>
<p>Diffusely inter-reflected light is a function of the objects around the point in question. Since this is recursively defined to millions of levels of recursion, in any real life scene, every point is illuminated at least in part by every other part of the scene. Since we cannot afford to compute this, if we only do one bounce, the calculated ambient light is very strongly affected by the colors of the objects near it. This is known as color bleed and it really happens but not as much as this calculation method would have you believe. The <code>gray_threshold</code> float value grays it down a little, to make your scene more believable. A value of .6 means to calculate the ambient value as 60% of the equivalent gray value calculated, plus 40% of the actual value calculated. At 0%, this feature does nothing. At 100%, you always get white/gray ambient light, with no hue.</p>
<p class="Note"><strong>Note:</strong> This does not change the lightness/darkness, only the strength of hue/grayness (in HLS
terms, it changes S only). The default value is 0.0</p>

</div>
<a name="r3_4_3_3_3_7"></a>
<div class="content-level-h6" contains="low_error_factor" id="r3_4_3_3_3_7">
<h6>3.4.3.3.3.7 low_error_factor</h6>
<p>If you calculate just enough samples, but no more, you will get an image which has slightly blotchy lighting. What you want is just a few extra interspersed, so that the blending will be nice and smooth. The solution to this is the mosaic preview, controlled by 
<a href="r3_4.html#r3_4_3_3_3_12">pretrace</a>, it goes over the image one or more times beforehand, calculating radiosity values. To ensure that you get a few extra, the radiosity algorithm lowers the error bound during the pre-final passes, then sets it back just before the final pass. The <code>low_error_factor</code> is a float tuning value which sets the amount that the error bound is dropped during the preliminary image passes. If your low error factor is 0.8 and your error bound is set to 0.4 it will really use an error bound of 0.32 during the first passes and 0.4 on the final pass. The default value is 0.5.</p>

</div>
<a name="r3_4_3_3_3_8"></a>
<div class="content-level-h6" contains="max_sample" id="r3_4_3_3_3_8">
<h6>3.4.3.3.3.8 max_sample</h6>
<p>Sometimes there can be splotchy patches that are caused by objects that are very bright. This can be sometimes avoided by using the <code>max_sample</code> keyword. <code>max_sample</code> takes a float parameter which specifies the brightest that any gathered sample is allowed to be. Any samples brighter than this will have their brightness decreased (without affecting color). Note however that this mechanism will somewhat darken the overall brightness in an unrealistic way. Specifying a non-positive value for <code>max_sample</code> will allow any brightness of samples (which is the default).</p>

</div>
<a name="r3_4_3_3_3_9"></a>
<div class="content-level-h6" contains="maximum_reuse" id="r3_4_3_3_3_9">
<h6>3.4.3.3.3.9 maximum_reuse</h6>
<p>The <code>maximum_reuse</code> parameter works in conjunction with, and is similar to that of <code>minimum_reuse</code>, the only difference being that it is an upper bound rather than a lower one. The default value is 0.200.</p>
<p class="Note"><strong>Note:</strong> If you choose to adjust either the <code>minimum_reuse</code> or <code>maximum_reuse</code> settings they are subject to the criteria listed below:</p>
<ul>
<li>If <code>minimum_reuse &gt; maximum_reuse/2</code> with only one value is specified, a warning is issued and the unspecified value is adjusted.</li>
<li>If <code>minimum_reuse &gt; maximum_reuse/2</code> with both values specified, a warning is issued and neither value is modified.</li>
<li>If <code>minimum_reuse &gt;= maximum_reuse</code>, an error is generated.</li>
</ul>

</div>
<a name="r3_4_3_3_3_10"></a>
<div class="content-level-h6" contains="minimum_reuse" id="r3_4_3_3_3_10">
<h6>3.4.3.3.3.10 minimum_reuse</h6>
<p>The minimum effective radius ratio is set by <code>minimum_reuse</code> float value. This is the fraction of the screen width which sets the minimum radius of reuse for each sample point (actually, it is the fraction of the distance from the eye but the two are roughly equal for normal camera angles). For example, if the value is 0.02, the radius of maximum reuse for every sample is set to whatever ground distance corresponds to 2% of the width of the screen. Imagine you sent a ray off to the horizon and it hits the ground at a distance of 100 miles from your eye point. The reuse distance for that sample will be set to 2 miles. At a resolution of 300*400 this will correspond to (very roughly) 8 pixels. The theory is that you do not want to calculate values for every pixel into every crevice everywhere in the scene, it will take too long. This sets a minimum bound for the reuse. If this value is too low, (which it should be in theory) rendering gets slow, and inside corners can get a little grainy. If it is set too high, you do not get the natural darkening of illumination near inside edges, since it reuses. At values higher than 2% you start getting more just plain errors, like reusing the illumination of the open table underneath the apple. Remember that this is a unit less ratio. The default value is 0.015.</p>

</div>
<a name="r3_4_3_3_3_11"></a>
<div class="content-level-h6" contains="nearest_count" id="r3_4_3_3_3_11">
<h6>3.4.3.3.3.11 nearest_count</h6>
<p>The <code>nearest_count</code> integer value is the minimum number of old radiosity values blended together to create a new interpolated value. There is no upper limit on the number of samples blended, all available samples are blended that match the <code>error_bound</code> and <code>maximum_reuse</code> settings. When an optional second parameter (adaptive radiosity pretrace) is specified after the <code>nearest_count</code> keyword, pretrace will stop re-iterating over areas where, on average, that many average-quality samples are already present per ray. (The actual number of samples required to satisfy the <code>nearest_count</code> settings is influenced by sample quality, with high-quality samples reducing the effective number of samples required, down to 1/4 of the parameter value in extreme cases, and low-quality samples increasing the number.) With a setting lower than 4, things can get pretty patchy, this can be useful for debugging. Conversely, the <code>nearest_count</code> upper limit setting is 20, since values greater than 20 are not very useful in practice,  and that is currently the size of the array allocated. The default value is 5.</p>  

</div>
<a name="r3_4_3_3_3_12"></a>
<div class="content-level-h6" contains="pretrace_start and pretrace_end" id="r3_4_3_3_3_12">
<h6>3.4.3.3.3.12 pretrace_start and pretrace_end</h6>
<p>To control the radiosity pre-trace gathering step, use the keywords <code>pretrace_start</code> and <code>pretrace_end</code>. Each of these is followed by a decimal value between 0.0 and 1.0 which specifies the size of the blocks in the mosaic preview as a percentage of the image size. The defaults are 0.08 for <code>pretrace_start</code> and 0.04 for <code>pretrace_end</code>.</p>

</div>
<a name="r3_4_3_3_3_13"></a>
<div class="content-level-h6" contains="recursion_limit" id="r3_4_3_3_3_13">
<h6>3.4.3.3.3.13 recursion_limit</h6>
<p>The <code>recursion_limit</code> is an integer value which determines how many recursion levels are used to calculate the diffuse inter-reflection. The default value is 2, the upper limit is 20. In practice, values greater than 3 are seldom useful.</p>

</div>
<a name="r3_4_3_3_4"></a>
<div class="content-level-h5" contains="Configuring Radiosity" id="r3_4_3_3_4">
<h5>3.4.3.3.4 Configuring Radiosity</h5>
<p>The following parameters deal with configuring radiosity and how it interacts with other features. See also these additional command line <a href="r3_2.html#r3_2_8_9">options</a> for more control.</p>

</div>
<a name="r3_4_3_3_4_1"></a>
<div class="content-level-h6" contains="Importance" id="r3_4_3_3_4_1">
<h6>3.4.3.3.4.1 Importance</h6>
<p>If you have some comparatively small yet bright objects in your scene, radiosity will tend to produce bright splotchy artifacts unless you use a pretty high number of rays, which in turn will tremendously increase rendering time. To somewhat mitigate this issue, full ray computations are performed only for a certain portion of sample rays, depending on the ''importance'' of the first object each ray encounters. Importance can be assigned on a per-object basis using the following syntax:
</p>
<pre>
sphere { ... radiosity { importance IMPORTANCE } }
</pre>
<p>Where IMPORTANCE is a value in the range of <em>greater than 0.0 to less than or equal to 1.0</em> specifying the percentage of rays to actually compute on average. A particular ray will only be fully computed if it is within the first COUNT*IMPORTANCE rays of the sampling sequence; due to the low-discrepancy sub-random nature of the sequence, this is mostly equivalent to a per-ray weighted random choice, while maintaining a low-discrepancy uniform distribution on a per-object basis. Rays actually computed are weighted to compensate for those not computed.</p>
<p>Objects derived from previously defined objects will default to the <em>inherited</em> importance. CSG components without an explicit importance value set will default to their parent object's importance. Other objects will normally default to <code>importance 1.0</code>, however this can be changed in a <code>default{}</code> block:</p>
<pre>
default { radiosity { importance DEFAULT_IMPORTANCE } }
</pre>

</div>
<a name="r3_4_3_3_4_2"></a>
<div class="content-level-h6" contains="Media and Radiosity" id="r3_4_3_3_4_2">
<h6>3.4.3.3.4.2 Media and Radiosity</h6>
<p>Radiosity estimation can be affected by media. To enable this feature, add <code>media on</code> to the <code>radiosity{}</code> block. The default is <code>off</code></p>

</div>
<a name="r3_4_3_3_4_3"></a>
<div class="content-level-h6" contains="No Radiosity" id="r3_4_3_3_4_3">
<h6>3.4.3.3.4.3 No Radiosity</h6>
<p>Specifying <code>no_radiosity</code> in an object block makes that object invisible to radiosity rays, in the same way as <code>no_image</code>, <code>no_reflection</code> and <code>no_shadow</code> make an object invisible to primary, reflected and shadow test rays, respectively.</p>

</div>
<a name="r3_4_3_3_4_4"></a>
<div class="content-level-h6" contains="Normal and Radiosity" id="r3_4_3_3_4_4">
<h6>3.4.3.3.4.4 Normal and Radiosity</h6>
<p> Radiosity estimation can be affected by normals. To enable this feature, add <code>normal on</code> to the <code>radiosity{}</code> block. The default is <code>off</code></p>

</div>
<a name="r3_4_3_3_4_5"></a>
<div class="content-level-h6" contains="Save and Load Radiosity Data" id="r3_4_3_3_4_5">
<h6>3.4.3.3.4.5 Save and Load Radiosity Data</h6>
<p>In general, it is not a good idea to save and load radiosity data if scene objects are moving. Even after the data is loaded, more samples may be taken during the final rendering phase, particularly if you've specified <code>always_sample on</code>.</p>
<p class="Note"><strong>Note:</strong> The method to load and save radiosity data has been changed to a command line option. See section <a href="r3_2.html#r3_2_8_9_2">radiosity load and save</a> for more details.</p>

</div>
<a name="r3_4_3_3_4_6"></a>
<div class="content-level-h6" contains="Subsurface and Radiosity" id="r3_4_3_3_4_6">
<h6>3.4.3.3.4.6 Subsurface and Radiosity</h6>
<p>To specify whether radiosity sampling should <em>honor</em> subsurface light transport, you should place the following in the global settings <code>radiosity</code> block:</p>
<pre>
  global_settings {
    radiosity { subsurface BOOL }
    }
</pre>
<p>If this setting is <code>off</code>, the default, radiosity based diffuse illumination is computed as if the surrounding objects had subsurface light transport turned off. Setting this to <code>on</code> may improve realism especially in the presence of materials with high translucency, but at some cost in rendering time.</p>
<p>See the section <a href="r3_6.html#r3_6_1_3_3_4">Subsurface Light Transport</a> for more information about the role of <code>subsurface</code> in the global settings block.</p>

</div>
<a name="r3_4_3_3_5"></a>
<div class="content-level-h5" contains="Tips on Radiosity" id="r3_4_3_3_5">
<h5>3.4.3.3.5 Tips on Radiosity</h5>
<p>Have a look at the <a href="t2_3.html#t2_3_8">Radiosity Tutorial</a> to get a feel for what the visual result of changing radiosity parameters is.</p>

<p>If you want to see where your values are being calculated set radiosity <code>count</code> down to about 20, set radiosity <code>nearest_count</code> to 1 and set <code>gray_threshold</code> to 0. This will make everything maximally patchy, so you will be able to see the borders between patches. There will have been a radiosity calculation at the center of most patches. As a bonus, this is quick to run. You can then change the <code> error_bound</code> up and down to see how it changes things. Likewise
modify <code>minimum_reuse</code>.</p>
<p>One way to get extra smooth results: crank up the sample count (we have gone as high as 1300) and drop the <code>low_error_factor</code> to something small like 0.6. Bump up the <code> nearest_count</code> to 7 or 8. This will get better values, and more of them, then interpolate among more of them on the last pass. This is not for people with a lack of patience since it is like a squared function. If your blotchiness is only in certain corners or near certain objects try tuning the error bound instead. Never drop it by more than a little at a time, since the run time will get very long.</p>
<p>Sometimes extra samples are taken during the final rendering pass, if you've specified <code>always_sample on</code>. These newer samples can cause discontinuities in the radiosity in some scenes. To decrease these artifacts, use a <code>pretrace_end</code> of 0.04 (or even 0.02 if you are really patient and picky). This will cause the majority of the samples to be taken during the preview passes, and decrease the artifacts created during the final rendering pass. Be sure to force POV-Ray to only use the data from the pretrace step and not gather any new samples during the final radiosity pass, by removing <code>always_sample on</code> from within the <code>global_settings</code> radiosity block.</p>
<p>If your scene uses ambient objects (especially small ambient objects) as light sources, you should probably use a higher count (100-150 and higher). For such scenes, an error_bound of 1.0 is usually good. A higher value causes too much error, but lower causes very slow rendering. It is important to adjust adc_bailout.</p></div>

<a name="r3_4_3_4"></a>
<div class="content-level-h4" contains="Photons" id="r3_4_3_4">
<h4>3.4.3.4 Photons</h4>
<p>With <code>photons</code> it is possible to render true reflective and refractive caustics. The photon map was first introduced by Henrik Wann Jensen (see <a href="t2_5.html#t2_5_9">Suggested Reading</a>).</p>

<p>Photon mapping is a technique which uses a forward ray-tracing
pre-processing step to render refractive and reflective caustics realistically.
This means that mirrors can reflect light rays and lenses can focus light.</p>

<p>Photon mapping works by shooting packets of light (photons) from light
sources into the scene. The photons are directed towards specific objects. When
a photon hits an object after passing through (or bouncing off of) the target
object, the ray intersection is stored in memory. This data is later used to
estimate the amount of light contributed by reflective and refractive caustics.</p>

</div>
<a name="r3_4_3_4_1"></a>
<div class="content-level-h5" contains="Examples" id="r3_4_3_4_1">
<h5>3.4.3.4.1 Examples</h5>
<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <p>This image shows refractive caustics from a sphere and a cylinder. Both use an index of refraction of <code>1.2</code>. Also visible is a small amount of reflective caustics from the metal sphere, and also from the clear cylinder and sphere.</p>
  </td>
  <td>
    <img class="right" width="320px" src="images/3/3d/RefImgPhotons1.png">
  </td>
</tr>
<tr>
  <td></td>
  <td>
    <p class="caption">Reflective caustics</p>
  </td>
</tr>
</table>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="left" width="320px" src="images/6/6c/RefImgPhotons2.png">
  </td>
  <td>
    <p>Here we have three lenses and three light sources. The middle lens has photon mapping turned off. You can also see some reflective caustics from the brass box (some light reflects and hits the blue box, other light bounces through the nearest lens and is focused in the lower left corner of the image).</p>
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Photons used for lenses and caustics</p>
  </td>
  <td></td>
</tr>
</table>

</div>
<a name="r3_4_3_4_2"></a>
<div class="content-level-h5" contains="Using Photon Mapping in Your Scene" id="r3_4_3_4_2">
<h5>3.4.3.4.2 Using Photon Mapping in Your Scene</h5>
<p>When designing a scene with photons, it helps to think of the scene objects
in two categories.  Objects in the first category will show photon caustics
when hit by photons.  Objects in the second category cause photon caustics
by reflecting or refracting photons.  Some objects may be in both
categories, and some objects may be in neither category.</p>

<p>Category 1 - Objects that show photon caustics</p>

<p>By default, all objects are in the first category.  Whenever a photon hits
an object, the photon is stored and will later be used to render caustics on
that object.  This means that, by default, caustics from photons can appear
on any surface.  To speed up rendering, you can take objects out of this
category.  You do this with the line: <code>photons{collect off}</code>.  If you use
this syntax, caustics from photons will not appear on the object.  This will
save both memory and computational time during rendering.</p>

<p>Category 2 - Objects that cause photon caustics</p>

<p>By default, there are no objects in the second category.  If you want your
object to cause caustics, you need to do two things.  First, make your object into
a &quot;target.&quot;  You do this with the <code>target</code> keyword.  This enables light
sources to shoot photons at your object.  Second, you need to specify if
your object reflects photons, refracts photons, or both.  This is done with
the <code>reflection on</code> and <code>refraction on</code> keywords.  To allow an object to
reflect and refract photons, you would use the following lines of code
inside the object:
</p>
<pre>
photons{
  target
  reflection on
  refraction on
  }
</pre>

<p>Generally speaking, you do not want an object to be in both categories.  Most
objects that cause photon caustics do not themselves have much color or
brightness.  Usually they simply refract or reflect their surroundings.  For
this reason, it is usually a waste of time to display photon caustics on
such surfaces.  Even if computed, the effects from the caustics would be so
dim that they would go unnoticed.</p>

<p>Sometimes, you may also wish to add <code>photons{collect off}</code> to other clear or
reflective objects, even if they are not photon targets.  Again, this is
done to prevent unnecessary computation of caustic lighting.</p>

<p>Finally, you may wish to enable photon reflection and refraction for a
surface, even if it is not a target.  This allows indirect photons (photons
that have already hit a target and been reflected or refracted) to continue
their journey after hitting this object.</p>

</div>
<a name="r3_4_3_4_3"></a>
<div class="content-level-h5" contains="Photon Global Settings" id="r3_4_3_4_3">
<h5>3.4.3.4.3 Photon Global Settings</h5>
<pre>
global_photon_block:

photons {
  spacing &lt;photon_spacing&gt; | count &lt;photons_to_shoot&gt;
  [gather &lt;min_gather&gt;, &lt;max_gather&gt;]
  [media &lt;max_steps&gt; [,&lt;factor&gt;]]
  [jitter &lt;jitter_amount&gt;]
  [max_trace_level &lt;photon_trace_level&gt;]
  [adc_bailout &lt;photon_adc_bailout&gt;]
  [save_file &quot;filename&quot; | load_file &quot;filename&quot;]
  [autostop &lt;autostop_fraction&gt;]
  [expand_thresholds &lt;percent_increase&gt;, &lt;expand_min&gt;]
  [radius &lt;gather_radius&gt;, &lt;multiplier&gt;, &lt;gather_radius_media&gt;,&lt;multiplier&gt;]
  }
</pre>

<p>All photons default values:</p>
<pre>
Global :
expand_min    : 40 
gather        : 20, 100
jitter        : 0.4
media         : 0

Object :
collect       : on
refraction    : off
reflection    : off
split_union   : on
target        : 1.0

Light_source:
area_light    : off
refraction    : off
reflection    : off
</pre>

<p>To specify photon gathering and storage options you need to add a photons
block to the <code>global_settings</code> section of your scene.</p>

<p>For example:</p>

<pre>
global_settings {
  photons {
    count 20000
    autostop 0
    jitter .4
    }
  }
</pre>

<p>The number of photons generated can be set using either the spacing or count
keywords: </p>

<ul>
<li>If spacing is used, it specifies approximately the average distance
between photons on surfaces. If you cut the spacing in half, you will get four
times as many surface photons, and eight times as many media photons.</li>
<li>If count is used, POV-Ray will shoot the approximately number of photons
specified. The actual number of photons that result from this will almost
always be at least slightly different from the number specified. Still, if you
double the photons_to_shoot value, then twice as many photons will be shot. If
you cut the value in half, then half the number of photons will be shot.
<ul>
<li>It may be less, because POV shoots photons at a target object's
bounding box, which means that some photons will miss the target object.</li>
<li>On the other hand, may be more, because each time one object hits an
object that has both reflection and refraction, two photons are created
(one for reflection and one for refraction).</li>
<li>POV will attempt to compensate for these two factors, but it can only
estimate how many photons will actually be generated. Sometimes this
estimation is rather poor, but the feature is still usable.</li>
</ul></li>
</ul>

<p>The keyword <code>gather</code> allows you to specify how many photons are
gathered at each point during the regular rendering step. The first number
(default 20) is the minimum number to gather, while the second number (default
100) is the maximum number to gather. These are good values and you should only
use different ones if you know what you are doing.</p>

<p>The keyword <code>media</code> turns on media photons. The parameter 
<code>max_steps</code> specifies the maximum number of photons to deposit 
over an interval. The optional parameter factor specifies the difference in 
media spacing compared to surface spacing. You can increase factor and 
decrease max_steps if too many photons are being deposited in media.</p>

<p>The keyword <code>jitter</code> specifies the amount of jitter used in the
sampling of light rays in the pre-processing step. The default value is good and
usually does not need to be changed.</p>

<p>The keywords <code>max_trace_level</code> and <code>adc_bailout</code> allow
you to specify these attributes for the photon-tracing step. If you do not
specify these, the values for the primary ray-tracing step will be used.</p>

<p>The keywords <code>save_file</code> and <code>load_file</code> allow you to
save and load photon maps. If you load a photon map, no photons will be shot.
The photon map file contains all surface (caustic) and media
photons.</p>

<p><code>radius</code> is used for gathering photons. The larger the radius, the longer it
takes to gather photons. But if you use too small of a radius, you might
not get enough photons to get a good estimate. Therefore, choosing a good
radius is important. Normally POV-Ray looks through the photon map and uses some ad-hoc statistical analysis to determine a reasonable radius. Sometimes it does a good job, sometimes it does not. The radius keyword lets you override or adjust POV-Ray's guess.
</p>
<p><code>radius</code> parameters (all are optional):</p>
<ol>
<li>Manually set the gather radius for surface photons.  If this is either
zero or if you leave it out, POV-Ray will analyze and guess.</li>
<li>Adjust the radius for surface photons by setting a multiplier.  If POV-Ray, for example, is picking a radius that you think is too big (render is too slow), you can use <code>radius ,0.5</code> to lower the radius (multiply by 0.5) and speed up the render at the cost of quality.</li>
<li>Manually set the gather radius for media photons.</li>
<li>Adjust the radius for media photons by setting a multiplier.
</ol>

<p>The keywords <code><a href="r3_4.html#r3_4_3_4_9_1">autostop</a></code>
and <code><a href="r3_4.html#r3_4_3_4_9_2">expand_thresholds</a></code> will be explained later.</p>

</div>
<a name="r3_4_3_4_4"></a>
<div class="content-level-h5" contains="Shooting Photons at an Object" id="r3_4_3_4_4">
<h5>3.4.3.4.4 Shooting Photons at an Object</h5>
<pre>
object_photon_block:
photons {
  [target [Float]]
  [refraction on|off]
  [reflection on|off]
  [collect on|off]
  [pass_through]
  }
</pre>

<p>To shoot photons at an object, you need to tell POV that the object receives
photons. To do this, create a <code>photons { }</code> block within the object. For example:</p>

<pre>
object {
  MyObject
  photons {
    target
    refraction on
    reflection on
    collect off
    }
  }
</pre>

<p>In this example, the object both reflects and refracts photons. Either of
these options could be turned off (by specifying reflection off, for example).
By using this, you can have an object with a reflective finish which does not
reflect photons for speed and memory reasons.</p>

<p>The keyword <code>target</code> makes this object a target.</p>

<p>The density of the photons can be adjusted by specifying a spacing multiplier in the form of an optional value after the <code>target</code> keyword. If, for example, you specify a spacing multiplier of 0.5, then the spacing for photons hitting this object will be 1/2 of the distance of the spacing for other objects.</p>

<p class="Note"><strong>Note:</strong> This means four times as many surface photons, and
eight times as many media photons.</p>

<p>The keyword <code>collect off</code> causes the object to ignore photons.
Photons are neither deposited nor gathered on that object.</p>

<p>The keyword <code>pass_through</code> causes photons to pass through the 
object <strong>unaffected</strong> on their way to a target object. Once a 
photon hits the target object, it will ignore the <code>pass_through</code> 
flag. This is basically a photon version of the <code>no_shadow</code> 
keyword, with the exception that media within the object will still be 
affected by the photons (unless that media specifies collect off). If you 
use the <code>no_shadow</code> keyword, the object will be tagged as 
<code>pass_through</code> automatically. You can then turn off 
<code>pass_through</code> if necessary by simply using <code>photons { 
pass_through off }</code>.</p>

<p class="Note"><strong>Note:</strong> Photons will not be shot at an object unless you
specify the <code>target</code> keyword. Simply turning refraction on will not
suffice.</p>

<p>When shooting photons at a CSG-union, it may sometimes be of advantage to use
<code><a href="r3_5.html#r3_5_1_4_2_1">split_union off</a></code> inside the union. 
POV-Ray will be forced to shoot at the whole object, instead of splitting it up
and shooting photons at its compound parts.</p>

</div>
<a name="r3_4_3_4_5"></a>
<div class="content-level-h5" contains="Photons and Light Sources" id="r3_4_3_4_5">
<h5>3.4.3.4.5 Photons and Light Sources</h5>
<pre>
light_photon_block:
photons {
  [refraction on | off]
  [reflection on | off]
  [area_light]
  }
</pre>
<p>Example:</p>
<pre>
light_source {
  MyLight
  photons {
    refraction on
    reflection on
    }
  }
</pre>

<p>Sometimes, you want photons to be shot from one light source and not another. In that case, you can turn photons on for an object, but specify <code>photons {reflection off refraction off }</code> in the light source's definition. You can also turn off only reflection or only refraction for any light source.</p>
<p class="Note"><strong>Note:</strong> The photon shooting <em>performance</em> has been improved with the addition of multiple-thread support. To take advantage of this at the moment, your scene will need multiple light sources. </p>

</div>
<a name="r3_4_3_4_6"></a>
<div class="content-level-h5" contains="Photons and Media" id="r3_4_3_4_6">
<h5>3.4.3.4.6 Photons and Media</h5>
<pre>
global_settings {
  photons {
    count 10000
    media 100
    }
  }
</pre>

<p>Photons also interact fully with media. This means that volumetric photons
are stored in scattering media. This is enabled by using the keyword media
within the photons block.</p>

<p>To store photons in media, POV deposits photons as it steps through the media
during the photon-tracing phase of the render. It will deposit these photons as
it traces caustic photons, so the number of media photons is dependent on the
number of caustic photons. As a light ray passes through a section of media, the
photons are deposited, separated by approximately the same distance that
separates surface photons.</p>

<p>You can specify a factor as a second optional parameter to the media keyword.
If, for example, factor is set to 2.0, then photons will be spaced twice as far
apart as they would otherwise have been spaced.</p>

<p>Sometimes, however, if a section of media is very large, using these settings
could create a large number of photons very fast and overload memory. Therefore,
following the media keyword, you must specify the maximum number of photons that
are deposited for each ray that travels through each section of media. A setting
of 100 should probably work in most cases.</p>

<p>You can put <code>collect off</code> into media to make that media ignore
photons. Photons will neither be deposited nor gathered in a media that is
ignoring them. Photons will also not be gathered nor deposited in non-scattering
media. However, if multiple medias exist in the same space, and at least
one does not ignore photons and is scattering, then photons will be deposited in
that interval and will be gathered for use with all media in that interval.</p>

</div>
<a name="r3_4_3_4_7"></a>
<div class="content-level-h5" contains="Photons FAQ" id="r3_4_3_4_7">
<h5>3.4.3.4.7 Photons FAQ</h5>
<p><em>I made an object with IOR 1.0 and the shadows look weird.</em></p>

<p>If the borders of your shadows look odd when using photon mapping, do not be
alarmed. This is an unfortunate side-effect of the method. If you increase the
density of photons (by decreasing spacing and gather radius) you will notice the
problem diminish. We suggest not using photons if your object does not cause
much refraction (such as with a window pane or other flat piece of glass or any
objects with an IOR very close to 1.0).</p>

<p><em>My scene takes forever to render.</em></p>

<p>When POV-Ray builds the photon maps, it continually displays in the status
bar the number of photons that have been shot. Is POV-Ray stuck in this step and
does it keep shooting lots and lots of photons?</p>

<p><em>yes</em></p>

<p>If you are shooting photons at an infinite object (like a plane), then you
should expect this. Either be patient or do not shoot photons at infinite
objects.</p>

<p>Are you shooting photons at a CSG difference? Sometimes POV-Ray does a bad
job creating bounding boxes for these objects. And since photons are shot at the
bounding box, you could get bad results. Try manually bounding the object. You
can also try the autostop feature (try <code>autostop 0</code>). See the docs
for more info on autostop.</p>

<p><em>no</em></p>

<p>Does your scene have lots of glass (or other clear objects)? Glass is slow
and you need to be patient.</p>

<p><em>My scene has polka dots but renders really quickly. Why?</em></p>

<p>You should increase the number of photons (or decrease the spacing).</p>

<p><em>The photons in my scene show up only as small, bright dots. How can I fix
this?</em></p>

<p>The automatic calculation of the gather radius is probably not working
correctly, most likely because there are many photons not visible in your scene
which are affecting the statistical analysis.</p>

<p>You can fix this by either reducing the number of photons that are in your
scene but not visible to the camera (which confuse the auto-computation), or by
specifying the initial gather radius manually by using the keyword radius. If
you must manually specify a gather radius, it is usually best to also use
spacing instead of count, and then set radius and spacing to a 5:1
(radius:spacing) ratio.</p>

<p><em>Adding photons slowed down my scene a lot, and I see polka dots.</em></p>

<p>This is usually caused by having both high- and low-density photons in the
same scene. The low density ones cause polka dots, while the high density ones
slow down the scene. It is usually best if the all photons are on the same order
of magnitude for spacing and brightness. Be careful if you are shooting photons
objects close to and far from a light source. There is an optional parameter to
the target keyword which allows you to adjust the spacing of photons at the
target object. You may need to adjust this factor for objects very close to or
surrounding the light source.</p>

<p><em>I added photons, but I do not see any caustics.</em></p>

<p>When POV-Ray builds the photon maps, it continually displays in the status
bar the number of photons that have been shot. Did it show any photons being
shot?</p>

<p><em>no</em></p>

<p>Try avoiding <code>autostop</code>, or you might want to bound your object
manually.</p>

<p>Try increasing the number of photons (or decreasing the spacing).</p>

<p><em>yes</em></p>

<p><em>Were any photons stored (the number after <code>total</code> in the
rendering message as POV-Ray shoots photons)?</em></p>

<p><em>no</em></p>

<p>It is possible that the photons are not hitting the target object (because
another object is between the light source and the other object).</p>

<p><em>yes</em></p>
<p>The photons may be diverging more than you expect. They are probably there,
but you cannot see them since they are spread out too much</p>

<p><em>The base of my glass object is really bright.</em></p>

<p>Use <code>collect off</code> with that object.</p>

<p><em>Will area lights work with photon mapping?</em></p>

<p>Photons do work with area lights. However, normally photon mapping ignores
all area light options and treats all light sources as point lights. If you
would like photon mapping to use your area light options, you must specify the
&quot;area_light&quot; keyword <strong>within</strong> the <code>photons {
}</code> block in your light source's code. Doing this will not increase the
number of photons shot by the light source, but it might cause regular patterns
to show up in the rendered caustics (possibly splotchy).</p>

<p><em>What do the stats mean?</em></p>

<p>In the stats, <code>photons shot</code> means how many light rays were shot
from the light sources. <code>photons stored</code> means how many photons are
deposited on surfaces in the scene. If you turn on reflection and refraction,
you could get more photons stored than photons shot, since the each ray can get
split into two.</p>

</div>
<a name="r3_4_3_4_8"></a>
<div class="content-level-h5" contains="Photon Tips" id="r3_4_3_4_8">
<h5>3.4.3.4.8 Photon Tips</h5>
<ul>
<li>Use <code>collect off</code> in objects that photons do not hit. Just
put <code>photons { collect off }</code> in the object's definition.</li>
<li>Use <code>collect off</code> in glass objects.</li>
<li>Use <code>autostop</code> unless it causes problems.</li>
<li>A big tip is to make sure that all of the final densities of photons are
of the same general magnitude. You do not want spots with really high 
density photons and another area with really low density photons. You will
always have some variation (which is a good thing), but having really big
differences in photon density is what causes some scenes to take many hours 
to render.</li>
</ul>

</div>
<a name="r3_4_3_4_9"></a>
<div class="content-level-h5" contains="Advanced Techniques" id="r3_4_3_4_9">
<h5>3.4.3.4.9 Advanced Techniques</h5>

</div>
<a name="r3_4_3_4_9_1"></a>
<div class="content-level-h6" contains="Autostop" id="r3_4_3_4_9_1">
<h6>3.4.3.4.9.1 Autostop</h6>
<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
<p>To understand the <code>autostop</code> option, you need to understand the way photons are shot from light sources. Photons are shot in a spiral pattern with uniform angular density. Imagine a sphere with a spiral starting at one of the poles and spiraling out in ever-increasing circles to the equator. Two angles are involved here. The first, phi, is the how far progress has been made in the current circle of the spiral. The second, theta, is how far we are from the pole to the equator. Now, imagine this sphere centered at the light source with the pole where the spiral starts pointed towards the center of the object receiving photons. Now, photons are shot out of the light in this spiral pattern.</p>
  </td>
  <td>
    <img class="right" width="320px" src="images/2/28/RefImgShootph.png">
  </td>
</tr>
<tr>
  <td></td>
  <td>
    <p class="caption">Example of the photon autostop option</p>
  </td>
</tr>
</table>

<p>Normally, POV does not stop shooting photons until the target object's
entire bounding box has been thoroughly covered. Sometimes, however, an object
is much smaller than its bounding box. At these times, we want to stop shooting
if we do a complete circle in the spiral without hitting the object.
Unfortunately, some objects (such as copper rings), have holes in the middle.
Since we start shooting at the middle of the object, the photons just go through
the hole in the middle, thus fooling the system into thinking that
it is done. To avoid this, the <code>autostop</code> keyword lets you specify
how far the system must go before this auto-stopping feature kicks in. The value
specified is a fraction of the object's bounding box. Valid values are 0.0
through 1.0 (0% through 100%). POV will continue to shoot photons until the
spiral has exceeded this value or the bounding box is completely covered. If a
complete circle of photons fails to hit the target object after the spiral has
passed the autostop threshold, POV will then stop shooting photons.</p>

<p>The <code>autostop</code> feature will also not kick in until at least one
photon has hit the object. This allows you to use <code>autostop 0</code> even
with objects that have holes in the middle.</p>

<p class="Note"><strong>Note:</strong> If the light source is within the object's
bounding box, the photons are shot in all directions from the light source.</p>

</div>
<a name="r3_4_3_4_9_2"></a>
<div class="content-level-h6" contains="Adaptive Search Radius" id="r3_4_3_4_9_2">
<h6>3.4.3.4.9.2 Adaptive Search Radius</h6>
<p>Unless photons are interacting with media, POV-Ray uses an adaptive search 
radius while gathering photons. If the minimum number of photons is not found 
in the original search radius, the radius is expanded and searched again. Using 
this adaptive search radius can both decrease the amount of time it takes to 
render the image, and sharpen the borders in the caustic patterns.</p>

<p>Sometimes this adaptive search technique can create unwanted artifacts at
borders. To remove these artifacts, a few thresholds are used, which can be
specified by <code>expand_thresholds</code>. For example, if expanding the
radius increases the estimated density of photons by too much (threshold is
percent_increase, default is 20%, or 0.2), the expanded search is discarded and
the old search is used instead. However, if too few photons are gathered in the
expanded search (<code>expand_min</code>, default is 40), the new search will be
used always, even if it means more than a 20% increase in photon density.</p>

</div>
<a name="r3_4_3_4_9_3"></a>
<div class="content-level-h6" contains="Photons and Dispersion" id="r3_4_3_4_9_3">
<h6>3.4.3.4.9.3 Photons and Dispersion</h6>
<p>When dispersion is specified for interior of a transparent object, photons
will make use of that and show &quot;colored&quot; caustics.</p>

</div>
<a name="r3_4_3_4_9_4"></a>
<div class="content-level-h6" contains="Saving and Loading Photon Maps" id="r3_4_3_4_9_4">
<h6>3.4.3.4.9.4 Saving and Loading Photon Maps</h6>
<p>It is possible to save and load photon maps to speed up rendering. The photon
map itself is view-independent, so if you want to animate a scene that contains
photons and you know the photon map will not change during the animation, you
can save it on the first frame and then load it for all subsequent frames.</p>

<p>To save the photon map, put the line</p>

<pre>
save_file &quot;myfile.ph&quot;
</pre>

<p>into the <code>photons { }</code> block inside the <code>global_settings</code> section.</p>

<p>Loading the photon map is the same, but with <code>load_file</code> instead
of <code>save_file</code>. You cannot both load and save a photon map in the POV
file. If you load the photon map, it will load all of the photons. No photons will be shot if the map is loaded
from a file. All other options (such as gather radius) must still be specified
in the POV scene file and are not loaded with the photon map.</p>

<p>When can you safely re-use a saved photon map?</p>

<ul>
<li>Moving the camera is <em>always</em> safe.</li>
<li>Moving lights that do not cast photons is <em>always</em> safe.</li>
<li>Moving objects that do not have photons shot at them, that do not receive photons, and would not receive photons in the new location is <em>always</em> safe.</li>
<li>Moving an object that receives photons to a new location where it does not receive photons is <em>sometimes</em> safe.</li>
<li>Moving an object to a location where it receives photons is <em>not</em> safe</li>
<li>Moving an object that has photons shot at it is <em>not</em> safe</li>
<li>Moving a light that casts photons is <em>not</em> safe.</li>
<li>Changing the texture of an object that receives photons is safe.</li>
<li>Changing the texture of an object that has photons shot at it produces
results that are not realistic, but can be useful sometimes.</li>
</ul>
<p>
In general, changes to the scene geometry require photons to be re-shot.
Changing the camera parameters or changing the image resolution does
not.</p></div>

</div>

</div>
</body>
</html>
