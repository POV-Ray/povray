<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2009-2011  -->

<html lang="en">
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Reference Section 6</title>
<link rel="StyleSheet" href="povray.css" type="text/css">
<link rel="shortcut icon" href="favicon.ico">

<!--  NOTE: In order to help users find information about POV-Ray using web      -->
<!--  search engines, we ask that you *not* let them index documentation         -->
<!--  mirrors because effectively, when searching, users will get hundreds of    -->
<!--  results containing the same information! For this reason, these meta tags  -->
<!--  below disable archiving of this page by search engines.                    -->

<meta name="robots" content="noarchive">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="expires" content="0">
</head>
<body>

<div class="Page">

<!-- NavPanel Begin -->
<div class="NavPanel">
<table class="NavTable">
<tr>
  <td class="FixedPanelHeading"><a title="3.6" href="#r3_6">Embellishments</a></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.6.1" href="#r3_6_1">Texture</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.1" href="#r3_6_1_1">Pigment</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.1.1" href="#r3_6_1_1_1">Solid Color Pigments</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.1.2" href="#r3_6_1_1_2">Color Map</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.1.3" href="#r3_6_1_1_3">Pigment Map</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.1.4" href="#r3_6_1_1_4">Color List Pigments</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.1.5" href="#r3_6_1_1_5">Quick Color</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.2" href="#r3_6_1_2">Normal</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.2.1" href="#r3_6_1_2_1">Normal Map</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.2.2" href="#r3_6_1_2_2">Slope Map</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.2.2.1" href="#r3_6_1_2_2_1">Normals, Accuracy</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.2.3" href="#r3_6_1_2_3">Bump Map</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.2.3.1" href="#r3_6_1_2_3_1">Specifying a Bump Map</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.2.3.2" href="#r3_6_1_2_3_2">Bump_Size</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.2.3.3" href="#r3_6_1_2_3_3">Use_Index and Use_Color</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.2.4" href="#r3_6_1_2_4">Scaling normals</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.3" href="#r3_6_1_3">Finish</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.3.1" href="#r3_6_1_3_1">Ambient</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.3.2" href="#r3_6_1_3_2">Emission</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.3.3" href="#r3_6_1_3_3">Diffuse Reflection Items</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.3.3.1" href="#r3_6_1_3_3_1">Diffuse</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.3.3.2" href="#r3_6_1_3_3_2">Brilliance</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.3.3.3" href="#r3_6_1_3_3_3">Crand Graininess</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.3.3.4" href="#r3_6_1_3_3_4">Subsurface Light Transport</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.3.4" href="#r3_6_1_3_4">Highlights</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.3.4.1" href="#r3_6_1_3_4_1">Phong Highlights</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.3.4.2" href="#r3_6_1_3_4_2">Specular Highlight</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.3.4.3" href="#r3_6_1_3_4_3">Metallic Highlight Modifier</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.3.5" href="#r3_6_1_3_5">Specular Reflection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.3.6" href="#r3_6_1_3_6">Conserve Energy for Reflection</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.3.7" href="#r3_6_1_3_7">Iridescence</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.4" href="#r3_6_1_4">Halo</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.5" href="#r3_6_1_5">Patterned Textures</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.5.1" href="#r3_6_1_5_1">Texture Maps</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.5.2" href="#r3_6_1_5_2">Tiles</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.5.3" href="#r3_6_1_5_3">Material Maps</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.1.5.3.1" href="#r3_6_1_5_3_1">Specifying a Material Map</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.6" href="#r3_6_1_6">Layered Textures</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.7" href="#r3_6_1_7">UV Mapping</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.7.1" href="#r3_6_1_7_1">Supported Objects</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.1.7.2" href="#r3_6_1_7_2">UV Vectors</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.8" href="#r3_6_1_8">Triangle Texture Interpolation</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.9" href="#r3_6_1_9">Interior Texture</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.1.10" href="#r3_6_1_10">Cutaway Textures</a></div></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.6.2" href="#r3_6_2">Pattern</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.2.1" href="#r3_6_2_1">General Patterns</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.1" href="#r3_6_2_1_1">Agate Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.2" href="#r3_6_2_1_2">Boxed Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.3" href="#r3_6_2_1_3">Bozo Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.4" href="#r3_6_2_1_4">Brick Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.5" href="#r3_6_2_1_5">Bumps Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.6" href="#r3_6_2_1_6">Cubic Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.7" href="#r3_6_2_1_7">Cylindrical Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.8" href="#r3_6_2_1_8">Density File Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.1.8.1" href="#r3_6_2_1_8_1">df3 file format</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.9" href="#r3_6_2_1_9">Dents Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.10" href="#r3_6_2_1_10">Facets Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.11" href="#r3_6_2_1_11">Fractal Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.12" href="#r3_6_2_1_12">Function Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.1.12.1" href="#r3_6_2_1_12_1">What can be used</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.1.12.2" href="#r3_6_2_1_12_2">Function Image</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.13" href="#r3_6_2_1_13">Gradient Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.14" href="#r3_6_2_1_14">Granite Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.15" href="#r3_6_2_1_15">Leopard Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.16" href="#r3_6_2_1_16">Marble Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.17" href="#r3_6_2_1_17">Onion Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.18" href="#r3_6_2_1_18">Pavement Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.19" href="#r3_6_2_1_19">Pigment Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.20" href="#r3_6_2_1_20">Planar Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.21" href="#r3_6_2_1_21">Quilted Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.22" href="#r3_6_2_1_22">Radial Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.23" href="#r3_6_2_1_23">Ripples Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.24" href="#r3_6_2_1_24">Spherical Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.25" href="#r3_6_2_1_25">Spiral1 Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.26" href="#r3_6_2_1_26">Spiral2 Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.27" href="#r3_6_2_1_27">Spotted Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.28" href="#r3_6_2_1_28">Tiling Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.29" href="#r3_6_2_1_29">Waves Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.30" href="#r3_6_2_1_30">Wood Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.1.31" href="#r3_6_2_1_31">Wrinkles Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.2.2" href="#r3_6_2_2">Discontinuous Patterns</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.2.1" href="#r3_6_2_2_1">Cells Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.2.2" href="#r3_6_2_2_2">Checker Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.2.3" href="#r3_6_2_2_3">Crackle Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.2.4" href="#r3_6_2_2_4">Hexagon Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.2.5" href="#r3_6_2_2_5">Object Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.2.6" href="#r3_6_2_2_6">Square Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.2.7" href="#r3_6_2_2_7">Triangular Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.2.3" href="#r3_6_2_3">Normal-Dependent Patterns</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.3.1" href="#r3_6_2_3_1">Aoi Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.3.2" href="#r3_6_2_3_2">Slope Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.2.4" href="#r3_6_2_4">Special Patterns</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.4.1" href="#r3_6_2_4_1">Average Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.4.2" href="#r3_6_2_4_2">Image Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.4.3" href="#r3_6_2_4_3">Potential Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.4.4" href="#r3_6_2_4_4">User Defined Pattern</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.2.5" href="#r3_6_2_5">Pattern Modifiers</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.5.1" href="#r3_6_2_5_1">Transforming Patterns</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.5.2" href="#r3_6_2_5_2">Frequency and Phase</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.5.3" href="#r3_6_2_5_3">Waveforms</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.5.4" href="#r3_6_2_5_4">Noise Generators</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.5.5" href="#r3_6_2_5_5">Warp</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.1" href="#r3_6_2_5_5_1">Black Hole Warp</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.2" href="#r3_6_2_5_5_2">Repeat Warp</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.3" href="#r3_6_2_5_5_3">Turbulence Warp</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.4" href="#r3_6_2_5_5_4">Octaves</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.5" href="#r3_6_2_5_5_5">Lambda</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.6" href="#r3_6_2_5_5_6">Omega</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.7" href="#r3_6_2_5_5_7">Mapping using warps</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.8" href="#r3_6_2_5_5_8">Turbulence versus Turbulence Warp</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.6.2.5.5.9" href="#r3_6_2_5_5_9">Turbulence</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.2.6" href="#r3_6_2_6">Image Map</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.6.1" href="#r3_6_2_6_1">Specifying an Image Map</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.6.2" href="#r3_6_2_6_2">The Gamma Option</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.6.3" href="#r3_6_2_6_3">The Filter and Transmit Bitmap Modifiers</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.6.4" href="#r3_6_2_6_4">Using the Alpha Channel</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.6.2.7" href="#r3_6_2_7">Bitmap Modifiers</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.7.1" href="#r3_6_2_7_1">The once Option</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.7.2" href="#r3_6_2_7_2">The map_type Option</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.6.2.7.3" href="#r3_6_2_7_3">The interpolate Option</a></div></td>
</tr>
<tr>
  <td><div class="divh1">&nbsp;</div></td>
</tr>
<tr>
  <td><div class="divh1">&nbsp;</div></td>
</tr>
</table>
</div>
<!-- NavPanel End -->

<div class="Content">
<table class="HeaderFooter" width="100%">
<tr>
  <td colspan=5 align="left" class="HeaderFooter">
    POV-Ray for Unix <strong class="HeaderFooter">version 3.8</strong>
  </td>
</tr>
<tr >
  <td colspan=5>
    <hr align="right" width="70%">
  </td>
</tr>
<tr>
  <td width="30%"></td>
  <td class="NavBar"><a href="index.html" title="The Front Door">Home</a></td>
  <td class="NavBar"><a href="u1_0.html" title="Unix Table of Contents">POV-Ray for Unix</a></td>
  <td class="NavBar"><a href="t2_0.html" title="Tutorial Table of Contents">POV-Ray Tutorial</a></td>
  <td class="NavBar"><a href="r3_0.html" title="Reference Table of Contents">POV-Ray Reference</a></td>
</tr>
</table>

<a name="r3_6"></a>
<div class="content-level-h2" contains="Embellishments" id="r3_6">
<h2>3.6 Embellishments</h2>
<p>Quick Links:</p>

<ul>
  <li><a href="r3_6.html#r3_6_1">Texture</a></li>
    <ul>
      <li><a href="r3_6.html#r3_6_1_1">Pigment</a></li>
      <li><a href="r3_6.html#r3_6_1_2">Normal</a></li>
      <li><a href="r3_6.html#r3_6_1_3">Finish</a></li>
      <li><a href="r3_6.html#r3_6_1_4">Halo</a></li>
      <li><a href="r3_6.html#r3_6_1_5">Patterned Textures</a></li>
      <li><a href="r3_6.html#r3_6_1_6">Layered Textures</a></li>
      <li><a href="r3_6.html#r3_6_1_7">UV Mapping</a></li>
      <li><a href="r3_6.html#r3_6_1_8">Triangle Texture Interpolation</a></li>
      <li><a href="r3_6.html#r3_6_1_9">Interior Texture</a></li>
      <li><a href="r3_6.html#r3_6_1_10">Cutaway Textures</a></li>
    </ul>
  <li><a href="r3_6.html#r3_6_2">Pattern</a></li>
    <ul>
      <li><a href="r3_6.html#r3_6_2_1">General Patterns</a></li>
      <li><a href="r3_6.html#r3_6_2_2">Discontinuous Patterns</a></li>
      <li><a href="r3_6.html#r3_6_2_3">Normal-Dependent Patterns</a></li>
      <li><a href="r3_6.html#r3_6_2_4">Special Patterns</a></li>
      <li><a href="r3_6.html#r3_6_2_5">Pattern Modifiers</a></li>
      <li><a href="r3_6.html#r3_6_2_6">Image Map</a></li>
      <li><a href="r3_6.html#r3_6_2_7">Bitmaps Modifiers</a></li>
    </ul>
</ul></div>

<a name="r3_6_1"></a>
<div class="content-level-h3" contains="Texture" id="r3_6_1">
<h3>3.6.1 Texture</h3>



<p>The <code>texture</code> statement is an object modifier which describes
what the surface of an object looks like, i.e. its material. Textures are
combinations of pigments, normals, and finishes. Pigment is the color or
pattern of colors inherent in the material. Normal is a method of simulating
various patterns of bumps, dents, ripples or waves by modifying the surface
normal vector. Finish describes the reflective properties of a material.</p>
<p class="Note"><strong>Note:</strong> In previous versions of POV-Ray, the texture also contained
information about the interior of an object. This information has been moved
to a separate object modifier called <code>interior</code>. See
<a href="r3_7.html#r3_7_2_1">Interior</a> for details.</p>
<p>
There are three basic kinds of textures: plain, patterned, and layered. A
<em>plain texture</em> consists of a single pigment, an optional normal, and
a single finish. A <em>patterned texture</em> combines two or more textures
using a block pattern or blending function pattern. Patterned textures may be
made quite complex by nesting patterns within patterns. At the innermost
levels however, they are made up from plain textures. A <em>layered
texture</em> consists of two or more semi-transparent textures layered on top
of one another.</p>
<p class="Note"><strong>Note:</strong> Although we call a plain texture <em>plain</em> it
may be a very complex texture with patterned pigments and normals. The term
<em>plain</em> only means that it has a single pigment, normal, and
finish.</p>
<p>
The syntax for <code>texture</code> is as follows:</p>
<pre>
TEXTURE:
  PLAIN_TEXTURE | PATTERNED_TEXTURE | LAYERED_TEXTURE
PLAIN_TEXTURE:
  texture {
    [TEXTURE_IDENTIFIER]
    [PNF_IDENTIFIER...]
    [PNF_ITEMS...]
    }
PNF_IDENTIFIER:
  PIGMENT_IDENTIFIER | NORMAL_IDENTIFIER | FINISH_IDENTIFIER
PNF_ITEMS:
  PIGMENT | NORMAL | FINISH | TRANSFORMATION
LAYERED_TEXTURE:
  NON_PATTERNED_TEXTURE...
PATTERNED_TEXTURE:
  texture {
    [PATTERNED_TEXTURE_ID]
    [TRANSFORMATIONS...]
    } |
  texture {
    PATTERN_TYPE
    [TEXTURE_PATTERN_MODIFIERS...]
    } |
  texture {
    tiles TEXTURE tile2 TEXTURE
    [TRANSFORMATIONS...]
    } |
  texture {
    material_map {
      BITMAP_TYPE &quot;bitmap.ext&quot;
      [MATERIAL_MODS...] TEXTURE... [TRANSFORMATIONS...]
      }
    }
TEXTURE_PATTERN_MODIFIER:
  PATTERN_MODIFIER | TEXTURE_LIST |
  texture_map { TEXTURE_MAP_BODY }
</pre>

<p>In the <em>PLAIN_TEXTURE</em>, each of the items are optional but if they are present the <em>TEXTURE_IDENTIFIER</em> must be first. If no texture identifier is given, then POV-Ray creates a copy of the default texture.</p>
<p>Next are optional pigment, normal, and/or finish identifiers which fully override any pigment, normal and finish already specified in the previous texture identifier or default texture. Typically this is used for backward compatibility to allow things like:</p>
<pre>
texture { MyPigment }
</pre>
<p>where <code>MyPigment</code> is a pigment identifier.</p>
<p>Finally we have optional <code>pigment</code>, <code>normal</code> or <code>finish</code> statements which modify any pigment, normal and finish already specified in the identifier. If no texture identifier is specified the <code> pigment</code>, <code>normal</code> and <code>finish</code> statements modify the current default values. This is the typical plain texture:</p>
<pre>
texture {
  pigment { MyPigment }
  normal { MyNormal }
  finish { MyFinish }
  scale SoBig
  rotate SoMuch
  translate SoFar
  }
</pre>

<p>The <em>TRANSFORMATIONS</em> may be interspersed between the pigment, normal and finish statements but are generally specified last. If they are interspersed, then they modify only those parts of the texture already specified. For example:</p>
<pre>
texture {
  pigment { MyPigment }
  scale SoBig      //affects pigment only
  normal { MyNormal }
  rotate SoMuch    //affects pigment and normal
  finish { MyFinish }
  translate SoFar  //finish is never transformable no matter what.
                   //Therefore affects pigment and normal only
  }
</pre>

<p>Texture identifiers may be declared to make scene files more readable and to parameterize scenes so that changing a single declaration changes many values. An identifier is declared as follows.</p>
<pre>
TEXTURE_DECLARATION:
  #declare IDENTIFIER = TEXTURE |
  #local IDENTIFIER = TEXTURE
</pre>

<p>Where <em>IDENTIFIER</em> is the name of the identifier up to 40 characters long and <em>TEXTURE</em> is any valid <code>texture</code> statement. See <a href="r3_3.html#r3_3_2_2_2">#declare vs. #local</a> for information on identifier scope.</p>
<p>The sections below describe all of the options available for Pigment, Normal, and Finish. They are the main part of plain 
textures. There are also separate sections for <a href="r3_6.html#r3_6_1_5">Patterned Textures</a>
and <a href="r3_6.html#r3_6_1_6">Layered Textures</a> which are made up of plain textures.</p>
<p class="Note"><strong>Note:</strong> The <code><a href="r3_6.html#r3_6_1_5_2">tiles</a></code> and
<code><a href="r3_6.html#r3_6_1_5_3">material_map</a></code> versions of patterned textures are obsolete and are only supported for backwards compatibility.</p></div>

<a name="r3_6_1_1"></a>
<div class="content-level-h4" contains="Pigment" id="r3_6_1_1">
<h4>3.6.1.1 Pigment</h4>


<p>The color or pattern of colors for an object is defined by a <code>pigment</code> statement. All plain textures must have a pigment. If you do not specify one the default pigment is used. The color you define is the way you want the object to look if fully illuminated. You pick the basic color inherent in the object and POV-Ray brightens or darkens it depending on the lighting in the scene. The parameter is called <code>pigment</code> because we are defining the basic color the object actually is rather than how it looks.</p>
<p>The syntax for pigment is:</p>
<pre>
PIGMENT:
  pigment {
    [PIGMENT_IDENTIFIER]
    [PIGMENT_TYPE]
    [PIGMENT_MODIFIER...]
    }
PIGMENT_TYPE:
  PATTERN_TYPE | COLOR |
  image_map { 
    BITMAP_TYPE &quot;bitmap.ext&quot; [IMAGE_MAP_MODS...]
    }
PIGMENT_MODIFIER:
  PATTERN_MODIFIER | COLOR_LIST | PIGMENT_LIST | 
  color_map { COLOR_MAP_BODY } | colour_map { COLOR_MAP_BODY } | 
  pigment_map { PIGMENT_MAP_BODY } | quick_color COLOR |
  quick_colour COLOR
</pre>

<p>Each of the items in a pigment are optional but if they are present, they must be in the order shown. Any items after the <em> PIGMENT_IDENTIFIER</em> modify or override settings given in the identifier. If no identifier is specified then the items modify the pigment values in the current default texture. The <em>PIGMENT_TYPE</em> fall into roughly four categories. Each category is discussed the sub-sections which follow. The four categories are solid color and <code><a href="r3_6.html#r3_6_2_6">image_map</a></code> patterns which are specific to <code>pigment</code> statements or color list patterns, color mapped patterns which use POV-Ray's wide selection of general patterns. See <a href="r3_6.html#r3_6_2">Patterns</a> for details about specific patterns.</p>
<p>The pattern type is optionally followed by one or more pigment modifiers. In addition to general pattern modifiers such as transformations, turbulence, and warp modifiers, pigments may also have a <em>COLOR_LIST</em>, <em>PIGMENT_LIST</em>, <code><a href="r3_6.html#r3_6_1_1_2">color_map</a></code>, <code><a href="r3_6.html#r3_6_1_1_3">pigment_map</a></code>, and <code>quick_color</code> which are specific to pigments. See <a href="r3_6.html#r3_6_2_5">Pattern Modifiers</a> for information on general modifiers. The pigment-specific modifiers are described in sub-sections which follow. Pigment modifiers of any kind apply only to the pigment and not to other parts of the texture. Modifiers must be specified last.</p>
<p>A pigment statement is part of a <code>texture</code> specification. However it can be tedious to use a <code>texture</code> statement just to add a color to an object. Therefore you may attach a pigment directly to an object without explicitly specifying that it as part of a texture. For example instead of this:</p>
<pre>
object { My_Object texture {pigment { color Red } } }
</pre>
<p>you may shorten it to:</p>
<pre>
object { My_Object pigment {color Red } }
</pre>
<p>Doing so creates an entire <code>texture</code> structure with default <code>normal</code> and <code>finish</code> statements just as if you had explicitly typed the full <code> texture {...}</code> around it.</p>
<p class="Note"><strong>Note:</strong> an explicit texture statement is required, if you want to layer pigments.</p>
<p>Pigment identifiers may be declared to make scene files more readable and to parameterize scenes so that changing a single declaration changes many values. An identifier is declared as follows.</p>
<pre>
PIGMENT_DECLARATION:
  #declare IDENTIFIER = PIGMENT |
  #local IDENTIFIER = PIGMENT
</pre>
<p>Where <em>IDENTIFIER</em> is the name of the identifier up to 40 characters long and <em>PIGMENT</em> is any valid <code>pigment</code> statement. See <a href="r3_3.html#r3_3_2_2_2">#declare vs. #local</a> for information on identifier scope.</p>

</div>
<a name="r3_6_1_1_1"></a>
<div class="content-level-h5" contains="Solid Color Pigments" id="r3_6_1_1_1">
<h5>3.6.1.1.1 Solid Color Pigments</h5>
<p>The simplest type of pigment is a solid color. To specify a solid color you simply put a color specification inside a <code>pigment</code> statement. For example:</p>
<pre>
pigment { color Orange }
</pre>
<p>A color specification consists of the optional keyword <code> color</code> followed by a color identifier or by a specification of the amount of red, green, blue, filtered and unfiltered transparency in the surface. See section <a href="r3_3.html#r3_3_1_7">Specifying Colors</a> for more details about colors. Any pattern modifiers used with a solid color are ignored because there is no pattern to modify.</p>

</div>
<a name="r3_6_1_1_4"></a>
<div class="content-level-h5" contains="Color List Pigments" id="r3_6_1_1_4">
<h5>3.6.1.1.4 Color List Pigments</h5>
<p>There are four color list patterns: <code>checker</code>, <code>hexagon</code>, <code>brick</code> and <code>object</code>. The result is a pattern of solid colors with distinct edges rather than a blending of colors as with color
mapped patterns. Each of these patterns is covered in more detail in a later section. The syntax is:</p>
<pre>
COLOR_LIST_PIGMENT:
  pigment {brick [COLOR_1, [COLOR_2]] [PIGMENT_MODIFIERS...] }|
  pigment {checker [COLOR_1, [COLOR_2]] [PIGMENT_MODIFIERS...]}|
  pigment { 
    hexagon [COLOR_1, [COLOR_2, [COLOR_3]]] [PIGMENT_MODIFIERS...] 
    }|
  pigment {object OBJECT_IDENTIFIER | OBJECT {} [COLOR_1, COLOR_2]}
</pre>
<p>Each <em>COLOR_n</em> is any valid color specification. There should be a comma between each color or the <code>color</code> keyword should be used as a separator so that POV-Ray can determine where each color specification
starts and ends. The <code>brick</code> and <code>checker</code> pattern expects two colors and <code>hexagon</code> expects three. If an insufficient number of colors is specified then default colors are used.</p>

</div>
<a name="r3_6_1_1_5"></a>
<div class="content-level-h5" contains="Quick Color" id="r3_6_1_1_5">
<h5>3.6.1.1.5 Quick Color</h5>
<p>When developing POV-Ray scenes it is often useful to do low quality test runs that render faster. The <code>+Q</code> command line switch or <code>Quality</code> INI option can be used to turn off some time consuming color pattern and lighting calculations to speed things up. See <a href="r3_2.html#r3_2_8_3">Quality Settings</a> for details. However all settings of <code>+Q5</code> or <code>Quality=5</code> or lower turns off pigment calculations and creates gray objects.</p>
<p>By adding a <code>quick_color</code> to a pigment you tell POV-Ray what solid color to use for quick renders instead of a patterned pigment. For example:</p>
<pre>
pigment {
  gradient x
  color_map {
    [0.0 color Yellow]
    [0.3 color Cyan]
    [0.6 color Magenta]
    [1.0 color Cyan]
    }
  turbulence 0.5
  lambda 1.5
  omega 0.75
  octaves 8
  quick_color Neon_Pink
  }
</pre>
<p>This tells POV-Ray to use solid <code>Neon_Pink</code> for test runs at quality <code>+Q5</code> or lower but to use the turbulent gradient pattern for rendering at <code>+Q6</code> and higher. Solid color pigments such as</p>
<pre>
pigment {color Magenta}
</pre>
<p>automatically set the <code>quick_color</code> to that value. You may override this if you want. Suppose you have 10 spheres on the screen and all are yellow. If you want to identify them individually you could give each a different <code>quick_color</code>. Foe example:</p>
<pre>
sphere {
  &lt;1,2,3&gt;,4
  pigment { color Yellow  quick_color Red }
  }

sphere {
  &lt;-1,-2,-3&gt;,4
  pigment { color Yellow  quick_color Blue }
  }
</pre>
<p>and so on. At <code>+Q6</code> or higher they will all be yellow but at <code>+Q5</code> or lower each would be different colors so you could identify them.</p>
<p>The alternate spelling <code>quick_colour</code> is also supported.</p></div>

<a name="r3_6_1_1_2"></a>
<div class="content-level-h5" contains="Color Map" id="r3_6_1_1_2">
<h5>3.6.1.1.2 Color Map</h5>
<p>Most of the color patterns do not use abrupt color changes of just two or three colors like those in the <code>brick</code>, <code>checker</code> or <code>hexagon</code> patterns. They instead use smooth transitions of many colors that gradually change from one point to the next. The colors are defined in a pigment modifier called a <code>color_map</code> that describes how the pattern blends from one color to the next. <font class="New">New</font> in version 3.8 non-linear color map interpolation support has been added.</p>
<p>Each of the various pattern types available is in fact a mathematical function that takes any x, y, z location and turns it into a number between 0.0 and 1.0 inclusive. That number is used to specify what mix of colors to use from the color map.</p>
<p>The syntax for <code> color_map</code> is as follows:</p>

<pre>
COLOR_MAP:
  color_map { COLOR_MAP_BODY } |
  colour_map { COLOR_MAP_BODY }
COLOR_MAP_BODY:
  COLOR_MAP_IDENTIFIER |
  [BLEND_MAP_MODIFIERS...] COLOR_MAP_ENTRY...
BLEND_MAP_MODIFIERS:
  blend_mode BLEND_MODE |
  blend_gamma FLOAT
BLEND_MODE:
  0 | 1 | 2 | 3
COLOR_MAP_ENTRY:
  [ Value COLOR ] | 
  [ Value_1, Value_2 color COLOR_1 color COLOR_2 ]
</pre>

<p>Where each <em><code>Value_n</code></em> is a float values between 0.0 and 1.0 inclusive and each <em>COLOR_n</em>, are color specifications.</p>

<p>The possible values for <code>blend_mode</code> and their descriptions are as follows:</p>
<ul>
  <li><strong>0:</strong> Color interpolation is performed in the working gamma space as defined by <code>assumed_gamma</code> (default)</li>
  <li><strong>1:</strong> Color interpolation is performed in the linear color space</li>
  <li><strong>2:</strong> Color interpolation is performed in the gamma space defined by <code>blend_gamma</code> (default is 2.5)</li>
  <li><strong>3:</strong> Chromatic interpolation is performed in the linear space while brightness interpolation is performed in the gamma space defined by <code>blend_gamma</code></li>
</ul>

<p class="Note"><strong>Note:</strong> The <code>[]</code> brackets that are part of the actual <em>COLOR_MAP_ENTRY</em> should not confused with the symbols denoting optional syntax.</p>

<p>In <em>previous</em> versions there <em>had</em> to be from 2 to 256 entries in the map. A <font class="Change">Change</font> in version 3.8 has removed the upper restriction. The alternate spelling <code>colour_map</code> can also be used.</p>
<p>Here's a simple example:</p>
<pre>
sphere {
  &lt;0,1,2&gt;, 2
  pigment {
    gradient x       //this is the PATTERN_TYPE
    color_map {
      [0.1  color Red]
      [0.3  color Yellow]
      [0.6  color Blue]
      [0.6  color Green]
      [0.8  color Cyan]
      }
    }
  }
</pre>
<p>The pattern function <code>gradient x</code> is evaluated and the result is a value from 0.0 to 1.0. If the value is less than the first entry (in this case 0.1) then the first color (red) is used. Values from 0.1 to 0.3 use a blend of red and yellow using linear interpolation of the two colors. Similarly values from 0.3 to 0.6 blend from yellow to blue.</p>
<p>The 3rd and 4th entries both have values of 0.6. This causes an immediate abrupt shift of color from blue to green. Specifically a value that is less than 0.6 will be blue but exactly equal to 0.6 will be green. Moving along, values from 0.6 to 0.8 will be a blend of green and cyan. Finally any value greater than or equal to 0.8 will be cyan.</p>
<p>If you want areas of unchanging color you simply specify the same color for two adjacent entries.</p>
<p>For example:</p>
<pre>
color_map {
  [0.1  color Red]
  [0.3  color Yellow]
  [0.6  color Yellow]
  [0.8  color Green]
  }
</pre>
<p>In this case any value from 0.3 to 0.6 will be pure yellow.</p>
<p>The first syntax version of <em>COLOR_MAP_ENTRY</em> with one float and one color is the current standard. The other double entry version is obsolete and should be avoided. The previous example would look as follows using the old syntax.</p>
<pre>
color_map {
  [0.0 0.1  color Red color Red]
  [0.1 0.3  color Red color Yellow]
  [0.3 0.6  color Yellow color Yellow]
  [0.6.0.8  color Yellow color Green]
  [0.8 1.0  color Green color Green]
  }
</pre>
<p>You may use <code>color_map</code> with any patterns except <code>brick</code>, <code>checker</code>, <code>hexagon</code>, <code>object</code> and <code>image_map</code>. You may also declare and use <code>color_map</code> identifiers.</p>
<p>For example:</p>
<pre>
#declare Rainbow_Colors=
color_map {
  [0.0   color Magenta]
  [0.33  color Yellow]
  [0.67  color Cyan]
  [1.0   color Magenta]
  }
object {
  My_Object
  pigment {
    gradient x
    color_map { Rainbow_Colors }
    }
  }
</pre>

<p>See also: <a href="r3_6.html#r3_6_1_1_3">Pigment Maps</a>.</p></div>

<a name="r3_6_1_1_3"></a>
<div class="content-level-h5" contains="Pigment Map" id="r3_6_1_1_3">
<h5>3.6.1.1.3 Pigment Map</h5>
<p>In addition to specifying blended colors with a color map you may create a blend of pigments using a  <code>pigment_map</code>. The syntax for a pigment map is identical to a color map except you specify a pigment in each map
entry and not a color. <font class="New">New</font> in version 3.8 non-linear pigment map interpolation support has been added.</p>

<p>The syntax for <code>pigment_map</code> is as follows:</p>
<pre>
PIGMENT_MAP:
  pigment_map { PIGMENT_MAP_BODY }
PIGMENT_MAP_BODY:
  PIGMENT_MAP_IDENTIFIER |
  [BLEND_MAP_MODIFIERS...] PIGMENT_MAP_ENTRY...
BLEND_MAP_MODIFIERS:
  blend_mode BLEND_MODE |
  blend_gamma FLOAT
BLEND_MODE:
  0 | 1 | 2 | 3
PIGMENT_MAP_ENTRY:
  [ Value PIGMENT_BODY ]
</pre>

<p>Where <em><code>Value</code></em> is a float value between 0.0 and 1.0 inclusive and each <em>PIGMENT_BODY</em> is anything which can be inside a <code>pigment{...}</code> statement. The <code>pigment</code> keyword and <code>{}</code> braces need not be specified.</p>

<p>The possible values for <code>blend_mode</code> and their descriptions are as follows:</p>
<ul>
  <li><strong>0:</strong> Color interpolation is performed in the working gamma space as defined by <code>assumed_gamma</code> (default)</li>
  <li><strong>1:</strong> Color interpolation is performed in the linear color space</li>
  <li><strong>2:</strong> Color interpolation is performed in the gamma space defined by <code>blend_gamma</code> (default is 2.5)</li>
  <li><strong>3:</strong> Chromatic interpolation is performed in the linear space while brightness interpolation is performed in the gamma space defined by <code>blend_gamma</code></li>
</ul>

<p class="Note"><strong>Note:</strong> The <code>[]</code> brackets that are part of the actual <em>PIGMENT_MAP_ENTRY</em> should not confused with the symbols denoting optional syntax.</p>

<p>In <em>previous</em> versions there <em>had</em> to be from 2 to 256 entries in the map. A <font class="Change">Change</font> in version 3.8 has removed the upper restriction.</p>

<p>Here's a simple example:</p>

<pre>
sphere {
  &lt;0,1,2&gt;, 2
  pigment {
    gradient x       //this is the PATTERN_TYPE
    pigment_map {
      [0.3 wood scale 0.2]
      [0.3 Jade]     //this is a pigment identifier
      [0.6 Jade]
      [0.9 marble turbulence 1]
      }
    }
  }
</pre>

<p>When the <code>gradient x</code> function returns values from 0.0 to 0.3 the scaled wood pigment is used. From 0.3 to 0.6 the pigment identifier Jade is used. From 0.6 up to 0.9 a blend of Jade and a turbulent marble is used. From 0.9 on up only the turbulent marble is used.</p>

<p>Pigment maps may be nested to any level of complexity you desire. The pigments in a map may have color maps or pigment maps or any type of pigment you want. Any entry of a pigment map may be a solid color however if all entries are solid colors you should use a <code>color_map</code> which will render slightly faster.</p>

<p>Entire pigments may also be used with the block patterns <code>checker</code>, <code>hexagon</code> and <code>brick</code> as shown below:</p>

<pre>
pigment {
  checker
    pigment { Jade scale .8 }
    pigment { White_Marble scale .5 }
    }
</pre>

<p class="Note"><strong>Note:</strong> In the case of block patterns the <code>pigment</code> wrapping is required around the pigment information.</p>

<p>A pigment map is also used with the <code>average</code> pigment type. See <a href="r3_6.html#r3_6_2_4_1">Average</a> for details.</p>

<p>You may not use <code>pigment_map</code> or individual pigments with an <code>image_map</code>. See section <a href="r3_6.html#r3_6_1_5_1">Texture Maps</a> for an alternative way to do this.</p>

<p>You may declare and use pigment map identifiers but the only way to declare a pigment block pattern list is to declare a pigment identifier for the entire pigment.</p>

<p>See also: <a href="r3_6.html#r3_6_1_1_2">Color Maps</a>.</p></div>

<a name="r3_6_1_2"></a>
<div class="content-level-h4" contains="Normal" id="r3_6_1_2">
<h4>3.6.1.2 Normal</h4>


<p>Ray-tracing is known for the dramatic way it depicts reflection, refraction and lighting effects. Much of our perception depends on the reflective properties of an object. Ray tracing can exploit this by playing tricks on our perception to make us see complex details that are not really there.</p>
<p>Suppose you wanted a very bumpy surface on the object. It would be very difficult to mathematically model lots of bumps. We can however simulate the way bumps look by altering the way light reflects off of the surface. Reflection calculations depend on a vector called a <em> surface normal</em> vector. This is a vector which points away from the surface and is perpendicular to it. By artificially modifying (or perturbing) this normal vector you can simulate bumps. This is done by adding an optional <code>normal</code> statement.</p>
<p class="Note"><strong>Note:</strong> Attaching a normal pattern does not really modify the surface. It only affects the way light reflects or refracts at the surface so that it looks bumpy.</p>
<p> The syntax is:</p>
<pre>
NORMAL:
  normal { [NORMAL_IDENTIFIER] [NORMAL_TYPE] [NORMAL_MODIFIER...] }
NORMAL_TYPE:
  PATTERN_TYPE Amount |
  bump_map { BITMAP_TYPE &quot;bitmap.ext&quot; [BUMP_MAP_MODS...]}
NORMAL_MODIFIER:
  PATTERN_MODIFIER | NORMAL_LIST | normal_map { NORMAL_MAP_BODY } |
  slope_map{ SLOPE_MAP_BODY } | bump_size Amount |
  no_bump_scale Bool | accuracy Float
</pre>
<p>Each of the items in a normal are optional but if they are present, they must be in the order shown. Any items after the <em>NORMAL_IDENTIFIER</em> modify or override settings given in the identifier. If no identifier is specified then the items modify the normal values in the current default texture. The <em>PATTERN_TYPE</em> may optionally be followed by a float value that controls the apparent depth of the bumps. Typical values range from 0.0 to 1.0 but any value may be used. Negative values invert the
pattern. The default value if none is specified is 0.5.</p>
<p>There are four basic types of <em>NORMAL_TYPE</em>s. They are block pattern normals, continuous pattern normals, specialized normals and bump maps. They differ in the types of modifiers you may use with them. The pattern type is optionally followed by one or more normal modifiers. In addition to general pattern modifiers such as transformations, turbulence, and warp modifiers, normals may also have a <em>NORMAL_LIST</em>, <code><a href="r3_6.html#r3_6_1_2_2">slope_map</a></code>, <code><a href="r3_6.html#r3_6_1_2_1">normal_map</a></code>, and <code>bump_size</code> which are specific to normals. See <a href="r3_6.html#r3_6_2_5">Pattern Modifiers</a> for information on general modifiers. The normal-specific modifiers are described in sub-sections which follow. Normal modifiers of any kind apply only to the normal and not to other parts of the texture. Modifiers must be specified last.</p>
<p>Originally POV-Ray had some patterns which were exclusively used for pigments while others were exclusively used for normals. Since POV-Ray 3.0 you can use any pattern for either pigments or normals. For example it is now valid to use <code>ripples</code> as a pigment or <code>wood</code> as a normal type. The patterns <code>bumps</code>, <code>dents</code>, <code>ripples</code>, <code>waves</code>, <code> wrinkles</code>, and <code><a href="r3_6.html#r3_6_1_2_3">bump_map</a></code> were once exclusively normal patterns which could not be used as pigments. Because these six types use specialized normal modification calculations they cannot have <code><a href="r3_6.html#r3_6_1_2_2">slope_map</a></code>, <code><a href="r3_6.html#r3_6_1_2_1">normal_map</a></code> or wave shape modifiers. All other normal pattern types may use them. Because block patterns <code> checker</code>, <code>hexagon</code>, <code>object</code> and <code>brick</code> do not return a continuous series of values, they cannot use these modifiers either. See <a href="r3_6.html#r3_6_2">Patterns</a> for details about specific patterns.</p>
<p>A <code> normal</code> statement is part of a <code>texture</code> specification. However it can be tedious to use a <code>texture</code> statement just to add bumps to an object. Therefore you may attach a normal directly to an object without explicitly specifying that it as part of a texture. For example instead of this:</p>
<pre>
object  {My_Object texture { normal { bumps 0.5 } } }
</pre>
<p>you may shorten it to:</p>
<pre>
object { My_Object normal { bumps 0.5 } }
</pre>
<p>Doing so creates an entire <code>texture</code> structure with default <code>pigment</code> and <code>finish</code>
statements just as if you had explicitly typed the full <code>texture {...}</code> around it. Normal identifiers may be declared to make scene files more readable and to parameterize scenes so that changing a single declaration changes many values. An identifier is declared as follows.</p>
<pre>
NORMAL_DECLARATION:
  #declare IDENTIFIER = NORMAL |
  #local IDENTIFIER = NORMAL
</pre>
<p>Where <em>IDENTIFIER</em> is the name of the identifier that is at least one character long and <em>NORMAL</em> is any valid <code>normal</code> statement. See <a href="r3_3.html#r3_3_2_2_2">#declare vs. #local</a> for information on identifier scope.</p>
<p class="Note"><strong>Note:</strong> In previous versions identifier names <em>were</em> limited to 40 characters. There has been a <font class="Change">Change</font> removing that restriction.</p></div>

<a name="r3_6_1_2_1"></a>
<div class="content-level-h5" contains="Normal Map" id="r3_6_1_2_1">
<h5>3.6.1.2.1 Normal Map</h5>
<p>Most of the time you will apply single normal pattern to an entire surface but you may also create a pattern or blend of normals using a <code>normal_map</code>. The syntax for a <code>normal_map</code> is identical to a <code>pigment_map</code> except you specify a <code> normal</code> in each map entry. The syntax for <code>normal_map</code> is as follows:</p>
<pre>
NORMAL_MAP:
  normal_map { NORMAL_MAP_BODY }
NORMAL_MAP_BODY:
  NORMAL_MAP_IDENTIFIER | NORMAL_MAP_ENTRY...
NORMAL_MAP_ENTRY:
  [ Value NORMAL_BODY ]
</pre>
<p>Where <em><code>Value</code></em> is a float value between 0.0 and 1.0 inclusive and each <em>NORMAL_BODY</em> is anything which can be inside a <code>normal{...}</code> statement. The <code>normal</code> keyword and <code>{}</code> braces need not be specified.</p>
<p class="Note"><strong>Note:</strong> The <code>[]</code> brackets are part of the actual <em>NORMAL_MAP_ENTRY</em>. They are not notational symbols denoting optional parts. The brackets surround each entry in the normal map.</p>
<p>In <em>previous</em> versions there <em>had</em> to be from 2 to 256 entries in the map. A <font class="Change">Change</font> in version 3.8 has removed the upper restriction.</p>
<p>For example:</p>
<pre>
normal {
  gradient x       //this is the PATTERN_TYPE
  normal_map {
    [0.3  bumps scale 2]
    [0.3  dents]
    [0.6  dents]
    [0.9  marble turbulence 1]
    }
  }
</pre>
<p>When the <code>gradient x</code> function returns values from 0.0 to 0.3 then the scaled bumps normal is used. From 0.3 to 0.6 dents pattern is used. From 0.6 up to 0.9 a blend of dents and a turbulent marble is used. From 0.9 on up only the turbulent marble is used.</p>
<p>Normal maps may be nested to any level of complexity you desire. The normals in a map may have slope maps or normal maps or any type of normal you want.</p>
<p>A normal map is also used with the <code>average</code> normal type. See <a href="r3_6.html#r3_6_2_4_1">Average</a> for details.</p>
<p>Entire normals in a normal list may also be used with the block patterns such as <code>checker</code>, <code>hexagon</code> and <code>brick</code>. For example:</p>
<pre>
normal {
  checker
  normal { gradient x scale .2 }
  normal { gradient y scale .2 }
  }
</pre>
<p class="Note"><strong>Note:</strong> In the case of block patterns the <code>normal</code> wrapping is required around the normal information.</p>
<p>You may not use <code>normal_map</code> or individual normals with a <code>bump_map</code>. See section <a href="r3_6.html#r3_6_1_5_1">Texture Maps</a> for an alternative way to do this.</p>
<p>You may declare and use normal map identifiers but the only way to declare a normal block pattern list is to declare a normal identifier for the entire normal.</p></div>

<a name="r3_6_1_2_2"></a>
<div class="content-level-h5" contains="Slope Map" id="r3_6_1_2_2">
<h5>3.6.1.2.2 Slope Map</h5>
<p>A <code>slope_map</code> is a normal pattern modifier which gives the user a great deal of control over the exact shape of the bumpy features. Each of the various pattern types available is in fact a mathematical function that takes any x, y, z location and turns it into a number between 0.0 and 1.0 inclusive. That number is used to specify where the various high and low spots are. The <code>slope_map</code> lets you further shape the contours. It is best illustrated with a gradient normal pattern. For example:</p>
<pre>
plane{ z, 0
  pigment{ White }
  normal { gradient x }
  }
</pre>
<p>Gives a ramp wave pattern that looks like small linear ramps that climb from the points at x=0 to x=1 and then abruptly drops to 0 again to repeat the ramp from x=1 to x=2. A slope map turns this simple linear ramp into almost any wave shape you want. The syntax is as follows:</p>
<pre>
SLOPE_MAP:
  slope_map { SLOPE_MAP_BODY }
SLOPE_MAP_BODY:
  SLOPE_MAP_IDENTIFIER | SLOPE_MAP_ENTRY...
SLOPE_MAP_ENTRY:
  [ Value, &lt;Height, Slope&gt; ]
</pre>
<p class="Note"><strong>Note:</strong> The <code>[]</code> brackets are part of the actual <em>SLOPE_MAP_ENTRY</em>. They are not notational symbols denoting optional parts. The brackets surround each entry in the slope map.</p>
<p>In <em>previous</em> versions there <em>had</em> to be from 2 to 256 entries in the map. A <font class="Change">Change</font> in version 3.8 has removed the upper restriction.</p>
<p>Each <em><code>Value</code></em> is a float value between 0.0 and 1.0 inclusive and each <em><code> &lt;Height</code></em>, <em><code>Slope&gt;</code></em> is a 2 component vector such as &lt;0,1&gt; where the first value represents the apparent height of the wave and the second value represents the slope of the wave at that point. The height should range between 0.0 and 1.0 but any value could be used.</p>
<p>The slope value is the change in height per unit of distance. For example a slope of zero means flat, a slope of 1.0 means slope upwards at a 45 degree angle and a slope of -1 means slope down at 45 degrees. Theoretically a slope straight up would have infinite slope. In practice, slope values should be kept in the range -3.0 to +3.0. Keep in mind that this is only the visually apparent slope. A normal does not actually change the surface.</p>
<p>For example here is how to make the ramp slope up for the first half and back down on the second half creating a triangle wave with a sharp peak in the center.</p>
<pre>
normal {
  gradient x             // this is the PATTERN_TYPE
  slope_map {
    [0   &lt;0, 1&gt;]   // start at bottom and slope up
    [0.5 &lt;1, 1&gt;]   // halfway through reach top still climbing
    [0.5 &lt;1,-1&gt;]   // abruptly slope down
    [1   &lt;0,-1&gt;]   // finish on down slope at bottom
    }
}
</pre>
<p>The pattern function is evaluated and the result is a value from 0.0 to 1.0. The first entry says that at x=0 the apparent height is 0 and the slope is 1. At x=0.5 we are at height 1 and slope is still up at 1. The third entry also specifies that at x=0.5 (actually at some tiny fraction above 0.5) we have height 1 but slope -1 which is downwards. Finally at x=1 we are at height 0 again and still sloping down with slope -1.</p>
<p>Although this example connects the points using straight lines the shape is actually a cubic spline. This example creates a smooth sine wave.</p>
<pre>
normal {
  gradient x                // this is the PATTERN_TYPE
  slope_map {
    [0    &lt;0.5, 1&gt;]   // start in middle and slope up
    [0.25 &lt;1.0, 0&gt;]   // flat slope at top of wave
    [0.5  &lt;0.5,-1&gt;]   // slope down at mid point
    [0.75 &lt;0.0, 0&gt;]   // flat slope at bottom
    [1    &lt;0.5, 1&gt;]   // finish in middle and slope up
    }
}
</pre>
<p>This example starts at height 0.5 sloping up at slope 1. At a fourth of the way through we are at the top of the curve at height 1 with slope 0 which is flat. The space between these two is a gentle curve because the start and end slopes are different. At half way we are at half height sloping down to bottom out at 3/4ths. By the end we are climbing at slope 1 again to complete the cycle. There are more examples in <code> slopemap.pov</code> in the sample scenes.</p>
<p>A <code>slope_map</code> may be used with any pattern except <code>brick</code>, <code>checker</code>, <code>object</code>, <code>hexagon</code>, <code>bumps</code>, <code>dents</code>, <code> ripples</code>, <code>waves</code>, <code>wrinkles</code> and <code>bump_map</code>.</p>
<p>You may declare and use slope map identifiers. For example:</p>
<pre>
#declare Fancy_Wave =
slope_map {             // Now let's get fancy
  [0.0  &lt;0, 1&gt;]   // Do tiny triangle here
  [0.2  &lt;1, 1&gt;]   //  down
  [0.2  &lt;1,-1&gt;]   //     to
  [0.4  &lt;0,-1&gt;]   //       here.
  [0.4  &lt;0, 0&gt;]   // Flat area
  [0.5  &lt;0, 0&gt;]   //   through here.
  [0.5  &lt;1, 0&gt;]   // Square wave leading edge
  [0.6  &lt;1, 0&gt;]   //   trailing edge
  [0.6  &lt;0, 0&gt;]   // Flat again
  [0.7  &lt;0, 0&gt;]   //   through here.
  [0.7  &lt;0, 3&gt;]   // Start scallop
  [0.8  &lt;1, 0&gt;]   //   flat on top
  [0.9  &lt;0,-3&gt;]   //     finish here.
  [0.9  &lt;0, 0&gt;]   // Flat remaining through 1.0
  }

object{ My_Object
  pigment { White }
  normal {
    wood
    slope_map { Fancy_Wave }
    }
  }
</pre>

</div>
<a name="r3_6_1_2_2_1"></a>
<div class="content-level-h6" contains="Normals, Accuracy" id="r3_6_1_2_2_1">
<h6>3.6.1.2.2.1 Normals, Accuracy</h6>
<p>Surface normals that use patterns that were not designed for use with normals (anything other than bumps, dents, waves, ripples, and wrinkles) uses a <code>slope_map</code> whether you specify one or not. To create a perturbed normal from a pattern, POV-Ray samples the pattern at four points in a pyramid surrounding the desired point to determine the gradient of the pattern at the center of the pyramid. The distance that these points are from the center point determines the accuracy of the approximation. Using points too close together causes floating-point inaccuracies. However, using points too far apart can lead to artefacts as well as smoothing out features that should not be smooth.</p>

<p>Usually, points very close together are desired. POV-Ray currently uses a delta or accuracy distance of 0.02. Sometimes it is necessary to decrease this value to get better accuracy if you are viewing a close-up of the texture. Other times, it is nice to increase this value to smooth out sharp edges in the normal (for example, when using a 'solid' crackle pattern). For this reason, a new property, <code>accuracy</code>, has been added to normals. It only makes a difference if the normal uses a <code>slope_map</code> (either specified or implied).</p> 

<p>You can specify the value of this accuracy (which is the distance between the sample points when determining the gradient of the pattern for slope_map) by adding <code>accuracy &lt;float&gt;</code> to your normal. For all patterns, the default is 0.02.</p>
<p>For more on <code>slope_map</code> see the <a href="t2_3.html#t2_3_5_2_3">Slope Map Tutorial</a></p></div>

<a name="r3_6_1_2_3"></a>
<div class="content-level-h5" contains="Bump Map" id="r3_6_1_2_3">
<h5>3.6.1.2.3 Bump Map</h5>
<p>When all else fails and none of the normal pattern types meets your needs you can use a <code>bump_map</code> to wrap a 2-D bit-mapped bump pattern around your 3-D objects.</p>
<p>Instead of placing the color of the image on the shape like an <code>image_map</code> a <code>bump_map</code> perturbs the surface normal based on the color of the image at that point. The result looks like the image has been embossed into the surface. By default, a bump map uses the brightness of the actual color of the pixel. Colors are converted to gray scale internally before calculating height. Black is a low spot, white is a high spot. The image's index values may be used instead. See the sections <a href="r3_6.html#r3_6_1_2_3_3">Use_Index</a>
and <a href="r3_6.html#r3_6_1_2_3_3">Use_Color</a> below.</p>

</div>
<a name="r3_6_1_2_3_1"></a>
<div class="content-level-h6" contains="Specifying a Bump Map" id="r3_6_1_2_3_1">
<h6>3.6.1.2.3.1 Specifying a Bump Map</h6>
<p>The syntax for a <code>bump_map</code> is:</p>
<pre>
BUMP_MAP:
  normal {
    bump_map {
      BITMAP_TYPE &quot;bitmap.ext&quot; [gamma GAMMA] [premultiplied BOOL]
      [BUMP_MAP_MODs...]
      }
  [NORMAL_MODFIERS...]
  }
BITMAP_TYPE:
  exr | gif | hdr | iff | jpeg | pgm | png | ppm | sys | tga | tiff
GAMMA:
  Float_Value | srgb | bt709 | bt2020
BUMP_MAP_MODS:
  map_type Type | once | interpolate Type | use_color | 
  use_colour | bump_size Value
</pre>

<p>After the required <em>BITMAP_TYPE</em> keyword is a string expression containing the name of a bitmapped bump file of the specified type. Several optional modifiers may follow the file specification. The modifiers are described below.</p>
<p class="Note"><strong>Note:</strong> Earlier versions of POV-Ray allowed some modifiers before the <em>BITMAP_TYPE</em> but that syntax is being phased out in favor of the syntax described here.</p>
<p>Filenames specified in the <code>bump_map</code> statements will be searched for in the home (current) directory first and, if not found, will then be searched for in directories specified by any <code>+L</code> or <code>Library_Path</code> options active. This would facilitate keeping all your bump maps files in a separate sub-directory and giving a <code>Library_Path</code> option to specify where your library of bump maps are. See <a href="r3_2.html#r3_2_5_3">Library Paths</a> for details.</p>
<p>By default, the bump pattern is mapped onto the x-y-plane. The bump pattern is <em>projected</em> onto the object as though there were a slide projector somewhere in the -z-direction. The pattern exactly fills the square area from (x,y) coordinates (0,0) to (1,1) regardless of the pattern's original size in pixels. If you would like to change this default you may translate, rotate or scale the pigment or texture to map it onto the object's surface as desired. If you would like to change this default orientation you may translate, rotate or scale the pigment or texture to map it onto the object's surface as desired.</p>
<p>
While POV-Ray will normally interpret the bump map input file as a container of linear data irregardless of file type, this can be overridden for any individual bump map input file by specifying <code>gamma</code> GAMMA immediately after the file name. For example:</p>
<pre>
bump_map {
  jpeg "foobar.jpg" gamma 1.8
  }
</pre>
<p>This will cause POV-Ray to perform gamma adjustment or decoding on the input file data before building the bump map. Alternatively to a numerical value, <code>srgb</code> may be specified to denote that the file is pre-corrected or encoded using the <em>sRGB transfer function</em> instead of a power-law gamma function. <font class="New">New</font> in version 3.8, other valid special values are <code>bt709</code> and <code>bt2020</code>, denoting that the file is encoded or pre-corrected using the ITU-R BT.709 or BT.2020 transfer function, respectively. See section <a href="t2_3.html#t2_3_4">Gamma Handling</a> for more details.</p>
<p>The file name is optionally followed by one or more <em>BITMAP_MODIFIERS</em>. The <code>bump_size</code>, <code>use_color</code> and <code>use_index</code> modifiers are specific to bump maps and are discussed in the following sections. See the section <a href="r3_6.html#r3_6_2_7">Bitmap Modifiers</a> where the generic bitmap modifiers <code>map_type</code>, <code>once</code> and <code>interpolate</code> are described.</p>

</div>
<a name="r3_6_1_2_3_2"></a>
<div class="content-level-h6" contains="Bump_Size" id="r3_6_1_2_3_2">
<h6>3.6.1.2.3.2 Bump_Size</h6>
<p>The relative bump size can be scaled using the <code>bump_size</code> modifier. The bump size number can be any number other than 0 but typical values are from about 0.1 to as high as 4.0 or 5.0.</p>
<pre>
normal {
  bump_map {
    gif &quot;stuff.gif&quot;
    bump_size 5.0
    }
  }
</pre>
<p>Originally <code>bump_size</code> could only be used inside a bump map but it can now be used with any normal. Typically it is used to override a previously defined size. For example:</p>
<pre>
normal {
  My_Normal   //this is a previously defined normal identifier
  bump_size 2.0
  }
</pre>

</div>
<a name="r3_6_1_2_3_3"></a>
<div class="content-level-h6" contains="Use_Index and Use_Color" id="r3_6_1_2_3_3">
<h6>3.6.1.2.3.3 Use_Index and Use_Color</h6>
<p>Usually the bump map converts the color of the pixel in the map to a gray scale intensity value in the range 0.0 to 1.0 and calculates the bumps based on that value. If you specify <code>use_index</code>, the bump map uses the color's palette number to compute as the height of the bump at that point. So, color number 0 would be low and color number 255 would be high (if the image has 256 palette entries). The actual color of the pixels doesn't matter when using the index. This option is only available on
palette based formats. The <code>use_color</code> keyword may be specified to explicitly note that the color methods should be used instead. The alternate spelling <code>use_colour</code> is also valid. These modifiers may only be used inside the <code>bump_map</code> statement.</p></div>

<a name="r3_6_1_2_4"></a>
<div class="content-level-h5" contains="Scaling normals" id="r3_6_1_2_4">
<h5>3.6.1.2.4 Scaling normals</h5>
<p>When scaling a normal, or when scaling an object after a normal is applied to it, the depth of the normal is affected by the scaling. This is not always wanted. If you want to turn off bump scaling for a texture or normal, you can do this by adding the keyword <code>no_bump_scale</code> to the texture's or normal's modifiers. This modifier will get passed on to all textures or normals contained in that texture or normal. Think of this like the way no_shadow gets passed on to objects contained in a CSG.</p>

<p>It is also important to note that if you add <code>no_bump_scale</code> to a normal or texture that is contained within another pattern (such as within a <code>texture_map</code> or <code>normal_map</code>), then the only scaling that will be ignored is the scaling of that texture or normal. Scaling of the parent texture or normal or of the object will affect the depth of the bumps, unless <code>no_bump_scale</code> is specified at the top-level of the texture (or normal, if the normal is not wrapped in a texture).</p>

<p class="Note"><strong>Note:</strong> See the section <a href="r3_6.html#r3_6_2_6_4">Using the Alpha Channel</a> for some important information regarding the use of <code><a href="r3_6.html#r3_6_1_2_3">bump_map</a></code>.</p></div>

<a name="r3_6_1_3"></a>
<div class="content-level-h4" contains="Finish" id="r3_6_1_3">
<h4>3.6.1.3 Finish</h4>



<p>How does light reflect, what happens in shadows and what kind of highlights are visible? The <code>finish</code> properties of a surface can greatly affect its appearance.</p>

<p>The syntax for <code>finish</code> is as follows:</p>

<pre>
FINISH:
  finish { [FINISH_IDENTIFIER] [FINISH_ITEMS...] }
FINISH_ITEMS:
  fresnel FLOAT
  ambient COLOR | diffuse [albedo] Amount [, Amount] |
  emission COLOR | brilliance Amount | phong [albedo] Amount | phong_size Amount |
  specular [albedo] Amount | roughness Amount | 
  metallic [Amount] | reflection COLOR |
  crand Amount | conserve_energy BOOL |
  reflection { Color_Reflecting_Min [REFLECTION_ITEMS...] } |
  subsurface { translucency COLOR } |
  irid { Irid_Amount [IRID_ITEMS...] |
  use_alpha BOOL
  }
REFLECTION_ITEMS:
  COLOR_REFLECTION_MAX | fresnel BOOL |
  falloff FLOAT_FALLOFF | exponent FLOAT_EXPONENT |
  metallic FLOAT_METALLIC
IRID_ITEMS:
  thickness Amount | turbulence Amount
</pre>

<p class="Note"><strong>Note:</strong> In previous versions identifier names <em>were</em> limited to 40 characters. There has been a <font class="Change">Change</font> removing that restriction.</p>

<p>The <em>FINISH_IDENTIFIER</em> is optional but should proceed all other items. Any items after the <em>FINISH_IDENTIFIER</em> modify or override settings given in the <em>FINISH_IDENTIFIER</em>. If no identifier is specified then the items modify the finish values in the current default texture.</p>

<p class="Note"><strong>Note:</strong> Transformations are not allowed inside a finish because finish items cover the entire surface uniformly. Each of the <em>FINISH_ITEMS</em> listed above is described in sub-sections below.</p>

<p>In earlier versions of POV-Ray, the <code>refraction</code>, <code>ior</code>, and <code>caustics</code> keywords were part of the <code>finish</code> statement but they are now part of the <code>interior</code> statement. They are still supported under <code>finish</code> for backward compatibility but the results may not be 100% identical to previous versions. See <a href="r3_7.html#r3_7_2_1_1">Why are Interior and Media Necessary?</a> for more details.</p>

<p>A <code>finish</code> statement is part of a <code>texture</code> specification. However it can be tedious to use a <code>texture</code> statement just to add a highlights or other lighting properties to an object. Therefore you may attach a finish directly to an object without explicitly specifying it as part of a texture. For example instead of this:</p>

<pre>
object { My_Object texture { finish { phong 0.5 } } }
</pre>
<p>you may shorten it to:</p>
<pre>
object { My_Object finish { phong 0.5 } }
</pre>

<p>Doing so creates an entire <code>texture</code> structure with default <code>pigment</code> and <code>normal</code>
statements just as if you had explicitly typed the full <code>texture {...}</code> around it.</p>
<p>Finish identifiers may be declared to make scene files more readable and to parameterize scenes so that changing a single declaration changes many values. An identifier is declared as follows.</p>
<pre>
FINISH_DECLARATION:
  #declare IDENTIFIER = FINISH |
  #local IDENTIFIER = FINISH
</pre>
<p>Where <em>IDENTIFIER</em> is the name of the identifier and <em>FINISH</em> is any valid <code>finish</code> statement. See <a href="r3_3.html#r3_3_2_2_2">#declare vs. #local</a> for information on identifier scope.</p>

<p class="Note"><strong>Note:</strong> For more physical realism a <font class="Change">Change</font> in version 3.8 expands <code>fresnel</code> angle-dependent attenuation use to now include the <code>ambient</code>, <code>diffuse</code>, <code>emission</code>, <code>specular</code> and <code>phong</code> components. The details are as follows:</p>

<p>When used directly in the <code>finish</code> block the <code>fresnel</code> keyword activates <em>Fresnel</em> effects for all of the <code>ambient</code>, <code>diffuse</code>, <code>emission</code>, <code>specular</code> and <code>phong</code> attributes. At steep viewing and/or light source angles it decreases the brightness of the <code>specular</code> and <code>phong</code> components. At shallow viewing angles and/or light source angles it instead decreases the brightness of the <code>ambient</code>, <code>diffuse</code> and <code>emission</code> components. The <code>fresnel</code> parameter can also be set to an intermediate value, in order to allow for the approximate modelling of anti-reactive coatings.</p>

<p>In the following example the <code>diffuse</code>, <code>phong</code> and <code>specular</code> syntax, which is normally used to specify the effective <em>bi-hemispheric albedo</em> of that respective component, does not work as advertised when finish-level <code>fresnel</code> is set to non-zero. Instead, <code>diffuse</code> will specify the <em>albedo</em> that the object would exhibit if it had a refractive index of 1, while <code>phong</code> and <code>specular</code> will specify the <em>albedo</em> that the object would exhibit if it had an infinitely large refractive index. As a result, while you would normally want to choose parameters such that <em>D_Value + P_Value + S_Value &lt;= 1</em>. With finish-level <code>fresnel</code> set to a non-zero value you would want to choose parameters such that <em>D_Value &lt;= 1</em> and <em>P_Value + S_Value &lt;= 1</em>. For optimal realism, you should specify the settings as noted below, and control the brightness of the <code>diffuse</code> component via the layer pigment.</p>

<pre>
// general values
finish {
  diffuse albedo D_Value
  phong albedo P_Value
  specular albedo S_Value
  }

// optimal realism
finish {
  diffuse albedo 1
  phong albedo 0
  specular albedo 1
  }
</pre>

<p>Setting finish-level <code>fresnel</code> will automatically activate (if set to a non-zero value) or deactivate (if set to zero) the reflection-level <code>fresnel</code> parameter. This can be overridden by specifying the reflection parameters <em>after</em> the finish-level <code>fresnel</code> parameter. For optimal realism, the maximum reflection should be set equal to the finish-level <code>fresnel</code> parameter, while the minimum reflection should be set to zero.</p>

<p>When subsurface light transport is enabled, the finish-level <code>fresnel</code> parameter will have no effect on the <code>diffuse</code> attribute; instead, the feature will always act as if the parameter had been set to 1.</p>

<p>Radiosity-based illumination currently does not account for the <em>Fresnel</em> effect on incoming light, regardless of the finish-level <code>fresnel</code> parameter.</p>

<p><font class="New">New</font> in version 3.8 you can now specify <code>use_alpha</code> in the <code>finish</code> block. If set to <code>off</code>, the default and also the old behavior, then <code>pigment</code> <em>filter</em> and <em>transmit</em> only hide the surface's <code>diffuse</code>, <code>ambient</code> and <code>emission</code> components. If set to <code>on</code> then <code>pigment</code> <em>filter</em> and <em>transmit</em> also hide the surface's highlights and <code>specular</code> reflection.</p>

</div>
<a name="r3_6_1_3_1"></a>
<div class="content-level-h5" contains="Ambient" id="r3_6_1_3_1">
<h5>3.6.1.3.1 Ambient</h5>
<p>The light you see in dark shadowed areas comes from diffuse reflection off of other objects. This light cannot be modeled directly using ray-tracing, however, the <a href="t2_3.html#t2_3_8">radiosity</a> feature can do a realistic approximation at the cost of higher render times. For most scenes, especially in-door scenes, this is will greatly improve the end result.</p>

<p>The classic way to simulate <em>Ambient Lighting</em> in shadowed areas is to assume that light is scattered
everywhere in the room equally. The effect can simply be calculated by adding a small amount of light to each texture,
whether or not a light is actually shining on that texture. This renders very fast, but has the disadvantage that shadowed
areas look flat.</p>

<p class="Note"><strong>Note:</strong> Without radiosity ambient light does not account for the color of surrounding objects. For instance, when entering a room where the walls, floor and ceiling are red, your white clothing will look pink from the reflected light. POV-Ray's ambient shortcut does <em>not</em> account for this.</p>

<p>The <code>ambient</code> keyword controls the amount of ambient light used for each object. In some situations the ambient light <em>might</em> also be tinted. In that case a color value can be specified as in the example below:</p>
<pre>
finish { ambient rgb &lt;0.3,0.1,0.1&gt; } //a pink ambient
</pre>

<p>If all color components are equal, a single float value may be used. In other words a single float value of 0.3 is treated as &lt;0.3,0.3,0.3&gt;. The default value is 0.1, which gives very little ambient light. As with light sources, physically meaningful values are typically greater than 0, but negative values work too. Lastly the value can also be arbitrarily high to simulate a very bright light.</p>

<p>You may also specify the overall ambient light level used when calculating the ambient lighting of an object using the global <code>ambient_light</code> setting.</p>

<p>The total light defined as: <strong><em>Ambient = Finish_Ambient * Global_Ambient_Light_Source</em></strong>. See also: <a href="r3_4.html#r3_4_1_2">Ambient Light</a> for more details.</p>

<p>Ambient light affects both shadowed and non-shadowed areas, so if you turn up the <code>ambient</code> value, you may want to turn down the <code>diffuse</code> and <code>reflection</code> values.</p>

<p>There has been a <font class="Change">Change</font> as of version 3.7 in that the <em>ambient</em> mechanism is now automatically turned off when <code>radiosity</code> is enabled, provided that <code>#version</code> is set to 3.7 or higher. This will allow use of the same material definitions in both <em>radiosity and non-radiosity</em> scenes. As a consequence, the practice of co-opting <code>ambient</code> to model glowing materials will no longer work in <code>radiosity</code> scenes and is therefore strongly discouraged altogether; instead, the new <code>emission</code> keyword has been added specifically for this purpose.</p>

<p class="Note"><strong>Note:</strong> Specular reflected indirect illumination like a flashlight shining in a mirror cannot modeled by either ambient light or radiosity. Use <a href="r3_4.html#r3_4_3_4">photons</a> instead.</p>

<p>There has been an important <font class="Change">Change</font> in version 3.8 regarding the default <code>ambient</code> setting. When <code><a href="r3_3.html#r3_3_2_5">#version</a></code> is set as <em>either</em> the first statement of the scene file or via <a href="r3_2.html#r3_2_5_4">command-line option</a> and the version is 3.8 or greater the default setting is now <code>ambient 0</code> as opposed to the <code>ambient 0.1</code> value used in previous versions.</p>

</div>
<a name="r3_6_1_3_2"></a>
<div class="content-level-h5" contains="Emission" id="r3_6_1_3_2">
<h5>3.6.1.3.2 Emission</h5>
<p>The <code>emission</code> keyword <font class="New">New</font> in version 3.7 can be used to model glowing materials, eliminating the need to co-opt <code>ambient</code> for this purpose.
</p>
<p>The syntax and effect are virtually identical to <code>ambient</code>, <em>except</em> that <code>emission</code> is unaffected by the global <code>ambient_light</code> parameter, and is <em>not</em> turned off when using radiosity.</p>
<p>See also: <a href="r3_6.html#r3_6_1_3_1">Ambient</a></p>

</div>
<a name="r3_6_1_3_3"></a>
<div class="content-level-h5" contains="Diffuse Reflection Items" id="r3_6_1_3_3">
<h5>3.6.1.3.3 Diffuse Reflection Items</h5>
<p>When light reflects off of a surface the laws of physics say that it should leave the surface at the exact same angle it came in. This is similar to the way a billiard ball bounces off a bumper of a pool table. This perfect reflection is called <em>specular reflection</em>. However only very smooth polished surfaces reflect light in this way. Most of the time, light reflects and is scattered in all directions by the roughness of the surface. This scattering is called <em>diffuse reflection</em> because the light diffuses
or spreads in a variety of directions. It accounts for the majority of the reflected light we see.</p>

</div>
<a name="r3_6_1_3_3_1"></a>
<div class="content-level-h6" contains="Diffuse" id="r3_6_1_3_3_1">
<h6>3.6.1.3.3.1 Diffuse</h6>
<p>The keyword <code>diffuse</code> is used in a <code>finish</code> statement to control how much of the light coming directly from any light sources is reflected via diffuse reflection. The optional keyword <code>albedo</code> can be used right after diffuse to specify that the parameter is to be taken as the total diffuse/specular reflectance, rather than peak reflectance.</p>

<p class="Note"><strong>Note:</strong> When <code>brilliance</code> is equal to 1 <code>albedo</code> will have no effect on the diffuse parameter.</p>

<p>For example:</p>
<pre>
finish { diffuse albedo 0.7 fresnel }
</pre>

<p>Means that 70% of the light seen comes from direct illumination from light sources. The default value for diffuse is 0.6.</p>

<p>To model thin, diffusely-translucent objects (e.g. paper, curtains, leaves etc.), an optional 2nd float parameter has been added to the <code>diffuse</code> finish statement to control the effect of illumination from the back of the surface. The default value is 0.0, i.e. no diffuse backside illumination. For realistic results, the sum of both parameters should be between 0.0 and 1.0, and the 2nd parameter should be the smaller of the two.</p>

<p class="Note"><strong>Note:</strong> This feature is currently experimental and may be subject to change. In particular, the syntax as well as inter-operation with <code>double_illuminate</code>, multi-layered textures or <code>conserve_energy</code> are still under investigation.</p>

<p>A new sample scene, <code>~scenes/advanced/diffuse_back.pov</code>, has been provided to illustrate this new feature.</p>

</div>
<a name="r3_6_1_3_3_2"></a>
<div class="content-level-h6" contains="Brilliance" id="r3_6_1_3_3_2">
<h6>3.6.1.3.3.2 Brilliance</h6>
<p>The amount of direct light that diffuses from an object depends upon the angle at which it hits the surface. When light hits at a shallow angle it illuminates less. When it is directly above a surface it illuminates more. The <code>brilliance</code> keyword can be used in a <code>finish</code> statement to vary the way light falls off depending upon the angle of incidence. This controls the tightness of the basic diffuse illumination on objects and slightly adjusts the appearance of surface shininess. Objects may appear more metallic by increasing their brilliance. The default value is 1.0. Higher values from 5.0 to about 10.0 cause the light to fall off less at medium to low angles. There are no limits to the brilliance value. Experiment to see what works best for a particular situation. This is best used in concert with highlighting.</p>

</div>
<a name="r3_6_1_3_3_3"></a>
<div class="content-level-h6" contains="Crand Graininess" id="r3_6_1_3_3_3">
<h6>3.6.1.3.3.3 Crand Graininess</h6>
<p>Very rough surfaces, such as concrete or sand, exhibit a dark graininess in their apparent color. This is caused by the shadows of the pits or holes in the surface. The <code>crand</code> keyword can be added to a <code>finish</code> to cause a minor random darkening in the diffuse reflection of direct illumination. Typical values range from <code>crand 0.01</code> to <code>crand 0.5</code> or higher. The default value is 0. For example:</p>

<pre>
finish { crand 0.05 }
</pre>
<p>The grain or noise introduced by this feature is applied on a pixel-by-pixel basis. This means that it will look the same on far away objects as on close objects. The effect also looks different depending upon the resolution you are using for the rendering.</p>
<p class="Note"><strong>Note:</strong> The <code>crand</code> should not be used when rendering animations. This is the one of a few truly random features in POV-Ray and will produce an annoying flicker of flying pixels on any textures animated with a <code>crand</code> value. For these reasons it is not a very accurate way to model the rough surface effect.</p>

</div>
<a name="r3_6_1_3_3_4"></a>
<div class="content-level-h6" contains="Subsurface Light Transport" id="r3_6_1_3_3_4">
<h6>3.6.1.3.3.4 Subsurface Light Transport</h6>
<p>The subsurface light transport feature, also know as subsurface scattering, is enabled <em>ONLY</em> when a <code>global_settings</code> subsurface block is present. For example, to enable SSLT and use it's default settings, you can specify an empty block.</p>
<pre>
  global_settings {
    subsurface {}
    }
</pre>
<p>To activate SSLT for a particular object you will also need to add the following statement to its finish block.</p>
<pre>
  material {
    texture {
      pigment { PIGMENT }
      finish {
        ...
        subsurface { translucency COLOR }
        }
      }
    interior { ior FLOAT }
    }
</pre>
<p>The pigment determines the SSLT material's overall appearance when applied to an object with sufficiently large structures. The <code>translucency</code> color, which can alternatively be a float, determines the strength of the subsurface light transport effect. The material's index of refraction also affects the appearance, and is <em>essential</em> for SSLT materials, but doesn't generate a warning at parse time if omitted.</p>
<p class="Note"><strong>Note:</strong> The effect doesn't scale with the object, and values may be greater than 1.0</p>
<p>To adjust materials to the dimensions of your scene, you <em>should</em> first determine the proper <code>mm_per_unit</code> setting (it should always match the actual scale of the object) to use in the global settings block, <em>then</em> adjust the materials <code>translucency</code> value.</p>
<p class="Note"><strong>Note:</strong> Any effect that can be achieved by changing <code>mm_per_unit</code> can also be achieved by adjusting the <code>translucency</code> value of materials.</p>
<p>The <code>mm_per_unit</code> algorithm is designed to give realistic results at a scale of 10 mm per POV-Ray unit by default. For other scales, you can place the following statement in the <code>global_settings</code> block:</p>
<pre>
  mm_per_unit INT
</pre>
<p class="Hint"><strong>Hint:</strong> Using these scaling examples as a guide you can easily come up with a suitable setting.</p>
<ul>
  <li>1 cm per unit, set it to 10 (the default)</li>
  <li>1 inch per unit, set it to 25.4</li>
  <li>1 m per unit, set it to 1000</li>
</ul>
<p>To tune the algorithm for quality or performance, the number of samples for the diffuse scattering and single-scattering approximation, respectively, can be specified by placing the following statement in the <code>global_settings</code> section. Both values default is 50.</p>
<pre>
  subsurface { samples INT, INT }
</pre>
<p>See the sample SSLT scene in <code>~scenes/subsurface/subsurface.pov</code> for more information. See also this PDF document, <a href="http://graphics.stanford.edu/papers/bssrdf/bssrdf.pdf">A Practical Model for Subsurface Light Transport</a>, for more in depth information about SSLT, including some sample values to use when defining new materials.</p>
<p>To specify whether subsurface light transport effects should be <em>applied</em> to incoming <code>radiosity</code> based diffuse illumination, you should place the following in the global settings <code>subsurface</code> block:</p>
<pre>
  global_settings {
    subsurface { radiosity BOOL }
    }
</pre> 
<p>If this setting is <code>off</code>, the default, subsurface light transport effects will only be applied to direct illumination from classic light sources. Setting this feature to <code>on</code> will improve realism especially for materials with high translucency, but at a significant cost in rendering time.</p>
<p>See the section <a href="r3_4.html#r3_4_3_3_4_6">Subsurface and Radiosity</a> for additional  configuration information.</p>
<p class="Note"><strong>Note:</strong> Subsurface scattering is disabled in all quality levels except <code>+Q9</code> or higher.</p> 
<p class="Warning"><strong>Warning:</strong> Be advised that the subsurface scattering feature is still experimental. These conditions, and possibly others, can apply. Usage and syntax is also subject to change!</p>
<ol>
  <li>Incorrect use may result in hard crashes instead of parse warnings.</li>
  <li>Pigments having any zero color components currently doesn't play nice with SSLT. For example use <code>rgb &lt;1,0.01,0.01&gt;</code> instead of <code>rgb &lt;1,0,0&gt;</code> as color literals or when declaring pigment identifiers.</li>
  <li>A diffuse finish attribute of zero can also cause povray to throw an assertion failure.</li>
  <li>Unions of overlapping objects will probably give unexpected results, however merge should work.</li>
  <li>Mesh objects need to be closed (not <em>perfectly</em>) for realism.</li>
    <li>To avoid seams between objects, they currently must <em>share</em> a common interior. It's not sufficient to have interiors with identical parameters, or even instances of the same defined interior. The only way to overcome this is to specify the interior in the parent CSG rather than the individual primitives. For the desired results:</li>
  <ul>
    <li><em>REMOVE</em> any interior statements from the material.</li>
    <li><em>ADD</em> the interior statement to the union or merge.</li>
    <li>For each part that needs a different <code>ior</code> (e.g. eyelashes or teeth) add an individual interior statement.</li>
  </ul>
</ol>

</div>
<a name="r3_6_1_3_4"></a>
<div class="content-level-h5" contains="Highlights" id="r3_6_1_3_4">
<h5>3.6.1.3.4 Highlights</h5>
<p>Highlights are the bright spots that appear when a light source reflects off of a smooth object. They are a blend of specular reflection and diffuse reflection. They are specular-like because they depend upon viewing angle and illumination angle. However they are diffuse-like because some scattering occurs. In order to exactly model a highlight you would have to calculate specular reflection off of thousands of microscopic bumps called micro facets. The more that micro facets are facing the viewer the shinier the object appears and the tighter the highlights become. POV-Ray uses two different models to simulate highlights without calculating micro facets. They are the <em>specular</em> and <em>Phong</em> models.</p>
<p class="Note"><strong>Note:</strong> Specular and phong highlights are <em>not</em> mutually exclusive. It is possible to specify both and they will both take effect. Normally, however, you will only specify one or the other.</p>

</div>
<a name="r3_6_1_3_4_1"></a>
<div class="content-level-h6" contains="Phong Highlights" id="r3_6_1_3_4_1">
<h6>3.6.1.3.4.1 Phong Highlights</h6>
<p>The <code>phong</code> keyword in the <code>finish</code> statement controls the amount of phong highlighting on the object. It causes bright shiny spots on the object that are the color of the light source being reflected. The <em>phong</em> method measures the average of the facets facing in the mirror direction from the light sources to the viewer.</p>

<p>Phong's value is typically from 0.0 to 1.0, where 1.0 causes complete saturation to the light source's color at the brightest area (center) of the highlight. The default value is 0.0 and gives no highlight. The size of the highlight spot is defined by the <code>phong_size</code> value. The larger the phong size the tighter, or smaller, the highlight and the shinier the appearance. The smaller the phong size the looser, or larger, the highlight and the less glossy the appearance. Typical values range from 1.0 (very dull) to 250 (highly polished) though any values may be used. The default value is 40 (plastic) if <code>phong_size</code> is not specified.</p>

<p>The optional keyword <code>albedo</code> can be used right after <code>phong</code> to specify that the parameter is to be taken as the total diffuse/specular reflectance, rather than peak reflectance.</p>

<p>For example:</p>
<pre>
finish { phong albedo 0.9 phong_size 60 fresnel }
</pre>
<p>If <code>phong</code> is not specified <code>phong_size</code> has no effect.</p>

</div>
<a name="r3_6_1_3_4_2"></a>
<div class="content-level-h6" contains="Specular Highlight" id="r3_6_1_3_4_2">
<h6>3.6.1.3.4.2 Specular Highlight</h6>
<p>The <code>specular</code> keyword in a <code>finish</code> statement produces a highlight which is very similar to phong highlighting but it uses slightly different model. The specular model more closely resembles real specular reflection and provides a more credible spreading of the highlights occurring near the object horizons.</p>

<p>The <code>specular</code> value is typically from 0.0 to 1.0, where 1.0 causes complete saturation to the light source's color at the brightest area (center) of the highlight. The default value is 0.0 and gives no highlight. The size of the spot is defined by the value given the <code>roughness</code> keyword. Typical values range from 1.0 (very rough - large highlight) to 0.0005 (very smooth - small highlight). The default value, if roughness is not specified, is 0.05 (plastic).</p>

<p>It is possible to specify wrong values for <code>roughness</code> that will generate an error. Do not use 0! If you get errors, check to see if you are using a very, very small roughness value that may be causing the error.</p>

<p>The optional keyword <code>albedo</code> can be used right after specular to specify that the parameter is to be taken as the total diffuse/specular reflectance, rather than peak reflectance.</p>

<p>For example:</p>
<pre>
finish { specular albedo 0.9 roughness 0.02 fresnel }
</pre>
<p>If <code>specular</code> is not specified <code>roughness</code> has no effect.</p>

<p class="Note"><strong>Note:</strong> When light is reflected by a surface such as a mirror, it is called <em>specular reflection</em> however such reflection is not controlled by the <code>specular</code> keyword. The <code>reflection</code> keyword controls mirror-like specular reflection.</p>

</div>
<a name="r3_6_1_3_4_3"></a>
<div class="content-level-h6" contains="Metallic Highlight Modifier" id="r3_6_1_3_4_3">
<h6>3.6.1.3.4.3 Metallic Highlight Modifier</h6>
<p>The keyword <code>metallic</code> may be used with <code>phong</code> or <code>specular</code> highlights. This keyword indicates that the color of the highlights will be calculated by an empirical function that models the reflectivity of metallic
surfaces.</p>

<p>Normally highlights are the color of the light source. Adding this keyword filters the highlight so that white light reflected from a metallic surface takes the color specified by the pigment</p>

<p>The <code>metallic</code> keyword may optionally be follow by a numeric value to specify the influence the amount of the effect. If no keyword is specified, the default value is zero. If the keyword is specified without a value, the default value is 1.</p>

<p>For example:</p>

<pre>
finish {
  phong 0.9
  phong_size 60
  metallic
  }
</pre>

<p>If <code>phong</code> or <code>specular</code> keywords are not specified then <code>metallic</code> has no effect.</p>

</div>
<a name="r3_6_1_3_5"></a>
<div class="content-level-h5" contains="Specular Reflection" id="r3_6_1_3_5">
<h5>3.6.1.3.5 Specular Reflection</h5>
<p>When light does not diffuse and it <em>does</em> reflect at the same angle as it hits an object, it is called <em>specular reflection</em>. Such mirror-like  reflection is controlled by the <code>reflection {...}</code> block in a <code>finish</code> statement.</p>

<p>Syntax:</p>
<pre>
finish {
  reflection {
    [COLOR_REFLECTION_MIN,] COLOR_REFLECTION_MAX
    [fresnel BOOL]
    [falloff FLOAT_FALLOFF]
    [exponent FLOAT_EXPONENT]
    [metallic FLOAT_METALLIC]
    }
  }

[interior { ior IOR }]
</pre>

<p>The simplest use would be a perfect mirror:</p>

<pre>
finish { reflection {1.0} ambient 0 diffuse 0 }
</pre>
 
<p>This gives the object a mirrored finish. It will reflect all other elements in the scene. Usually a single float value is specified after the keyword even though the syntax calls for a color. For example a float value of 0.3 gets promoted to the full color vector &lt;0.3,0.3,0.3,0.3,0.3&gt; which is acceptable because only the red, green and blue parts are used.</p>

<p>The value can range from 0.0 to 1.0. By default there is no reflection.</p>

<p class="Note"><strong>Note:</strong> You should be aware that:</p>

<ul>
  <li>Adding reflection to a texture makes it take longer to render because additional rays must be traced.</li>	  
  <li>The reflected light may be tinted by specifying a color rather than a float. For example, <code>finish { reflection rgb &lt;1,0,0&gt; }</code> gives a red mirror that only reflects red light.</li>
  <li>Although such reflection is called specular it is not controlled by the <code>specular</code> keyword. That keyword controls a specular highlight.</li>
  <li>The old syntax for simple reflection: <code>reflection COLOR</code> and <code>reflection_exponent FLOAT</code> (without braces) is still supported for backward compatibility.</li>
</ul> 

<p><code>falloff</code> sets a falloff exponent in the variable reflection. This is the exponent telling how fast the reflectivity will fall off, i.e. linear, squared, cubed, etc.</p>

<p>The <code>metallic</code> keyword is similar in function to the metallic keyword used for highlights in finishes: it simulates the reflective properties of metallic surfaces, where reflected light takes on the colour of the surface. When <code>metallic</code> is used, the reflection color is multiplied by the pigment color at each point. You can specify an optional float value, which is the amount of influence the <code>metallic</code> keyword has on the reflected color. <code>metallic</code> uses the <em>fresnel</em> equation so that the color of the light is reflected at glancing angles, and the color of the metal is reflected for angles close to the surface's normal.</p>

<p><strong>exponent</strong><br>
This property predates the introduction of <em>proper</em> gamma handling. People found that it was difficult to model partially reflective surfaces in a realistic way, as middle and lower brightness objects typically looked too bright when reflected. As a means to work around the phenomenon the optional <code>exponent</code> keyword was added, producing non-linear reflection intensities. The default value of 1.0 produces a linear curve. Lower values darken middle and low intensities and keep high intensity reflections bright. While this feature may still be used for artistic effects, it is strongly discouraged for renders aiming at realism. The original phenomenon is well understood by now, and using <code>assumed_gamma 1.0</code> as recommended will avoid it entirely.
</p>

<p><strong>Variable reflection</strong><br>
Many materials, such as water, ceramic glaze, and linoleum are more reflective when viewed at shallow angles. This can be simulated by also specifying a minimum reflection in the <code>reflection {...}</code> statement.
<br>For example:
</p> 
<pre>
finish { reflection { 0.03, 1 }}
</pre>
<p>
uses the same function as the standard reflection, but the first parameter sets the minimum reflectivity.
It could be a color vector or a float (which is automatically promoted to a gray vector). This minimum
value is how reflective the surface will be when viewed from a direction parallel to its normal.
<br>
The second parameter sets the maximum reflectivity, which could also be a color vector or a float 
(which is automatically promoted to a gray vector). This maximum parameter is how reflective the 
surface will be when viewed at a 90-degree angle to its normal.</p>
<p class="Note"><strong>Note:</strong> You can make maximum reflection less than minimum reflection if you want, although the result 
is something that does not occur in nature.
</p>

<p>When adding the <code>fresnel</code> keyword, the Fresnel reflectivity function is used instead of 
standard reflection. It calculates reflectivity using the finish's IOR. So with a fresnel reflection_type 
an <code>interior { ior IOR }</code> statement is required, even with opaque pigments. Remember that 
in real life many opaque objects have a thin layer of transparent glaze on their surface, and it 
is the glaze (which -does- have an IOR) that is reflective.
</p>

</div>
<a name="r3_6_1_3_6"></a>
<div class="content-level-h5" contains="Conserve Energy for Reflection" id="r3_6_1_3_6">
<h5>3.6.1.3.6 Conserve Energy for Reflection</h5>
<p>One of the features in POV-Ray is variable reflection, including realistic Fresnel
reflection (see the section on <a href="r3_6.html#r3_6_1_3_5">Variable Reflection</a>). Unfortunately, when this is coupled with constant transmittance, the texture
can look unrealistic. This unreal-ism is caused by the scene breaking the law of
conservation of energy. As the amount of light reflected changes, the amount of light
transmitted should also change (in a give-and-take relationship).</p>

<p>This can be achieved by adding the <code>conserve_energy</code> keyword
to the object's <code>finish {}</code>.
<br>When conserve_energy is enabled, POV-Ray will multiply the amount filtered
and transmitted by what is left over from reflection (for example, if reflection is 80%,
filter/transmit will be multiplied by 20%).</p>

</div>
<a name="r3_6_1_3_7"></a>
<div class="content-level-h5" contains="Iridescence" id="r3_6_1_3_7">
<h5>3.6.1.3.7 Iridescence</h5>
<p><em>Iridescence</em>, or Newton's thin film interference, simulates
the effect of light on surfaces with a microscopic transparent film overlay.
The effect is like an oil slick on a puddle of water or the rainbow hues of a
soap bubble. This effect is controlled by the <code>irid</code> statement
specified inside a <code>finish</code> statement.</p>

<p>This parameter modifies the surface color as a function of the angle between
the light source and the surface. Since the effect works in conjunction with
the position and angle of the light sources to the surface it does not behave
in the same ways as a procedural pigment pattern.</p>
<p>
The syntax is:</p>
<pre>
IRID:
  irid { Irid_Amount [IRID_ITEMS...] }
IRID_ITEMS:
  thickness Amount | turbulence Amount
</pre>

<p>The required <em><code>Irid_Amount</code></em> parameter is the
contribution of the iridescence effect to the overall surface color. As a
rule of thumb keep to around 0.25 (25% contribution) or less, but experiment.
If the surface is coming out too white, try lowering the <code>
diffuse</code> and possibly the <code>ambient</code> values of the
surface.</p>

<p>The <code>thickness</code> keyword represents the film's thickness. This
is an awkward parameter to set, since the thickness value has no relationship
to the object's scale. Changing it affects the scale or <em>
busy-ness</em> of the effect. A very thin film will have a high frequency of
color changes while a thick film will have large areas of color. The default
value is zero.</p>

<p>The thickness of the film can be varied with the <code>turbulence</code>
keyword. You can only specify the amount of turbulence with iridescence. The
octaves, lambda, and omega values are internally set and are not adjustable
by the user at this time. This parameter varies only a single value: the
thickness. Therefore the value must be a single float value. It cannot be a
vector as in other uses of the <code>turbulence</code> keyword.</p>

<p>In addition, perturbing the object's surface normal through the use of
bump patterns will affect iridescence.</p>

<p>For the curious, thin film interference occurs because, when the ray hits
the surface of the film, part of the light is reflected from that surface,
while a portion is transmitted into the film. This <em>subsurface</em> ray
travels through the film and eventually reflects off the opaque substrate.
The light emerges from the film slightly out of phase with the ray that was
reflected from the surface.</p>

<p>This phase shift creates interference, which varies with the wavelength of
the component colors, resulting in some wavelengths being reinforced, while
others are cancelled out. When these components are recombined, the result is
iridescence. See also the global setting <a href="r3_4.html#r3_4_1_5">Irid_Wavelength</a> for additional information.</p>

<p class="Note"><strong>Note:</strong> The version 3.7 iridescence feature has had a major overhaul. The syntax remains the same, however, <em>both</em> the thickness and amount values are now specified in microns. Consequently, iridescence effects will vary from previous versions.</p>

<p>The concept used for this feature came from the book <em>Fundamentals of
Three-Dimensional Computer Graphics</em> by Alan Watt (Addison-Wesley).</p></div>

<a name="r3_6_1_4"></a>
<div class="content-level-h4" contains="Halo" id="r3_6_1_4">
<h4>3.6.1.4 Halo</h4>


<p>Earlier versions of POV-Ray used a feature called <code>halo</code> to
simulate fine particles such as smoke, steam, fog, or flames. The <code>
halo</code> statement was part of the <code>texture</code> statement. This
feature has been discontinued and replaced by the <code>interior</code> and
<code>media</code> statements which are object modifiers outside the <code>
texture</code> statement.</p>

<p>See <a href="r3_7.html#r3_7_2_1_1">Why are Interior and Media Necessary?</a> for a detailed explanation on the reasons for the change. See also <a href="r3_7.html#r3_7_2">Media</a> for details on <code>media</code>.</p></div>

<a name="r3_6_1_5"></a>
<div class="content-level-h4" contains="Patterned Textures" id="r3_6_1_5">
<h4>3.6.1.5 Patterned Textures</h4>


<p>Patterned textures are complex textures made up of multiple textures. The
component textures may be plain textures or may be made up of patterned
textures. A plain texture has just one pigment, normal and finish statement.
Even a pigment with a pigment map is still one pigment and thus considered a
plain texture as are normals with normal map statements.</p>

<p>Patterned textures use either a <code>texture_map</code> statement to
specify a blend or pattern of textures or they use block textures such as
<code>checker</code> with a texture list or a bitmap similar to an image map
called a <em>material map</em> specified with a <code>material_map</code>
statement.</p>

<p>The syntax is...</p>
<pre>
PATTERNED_TEXTURE:
  texture {
    [PATTERNED_TEXTURE_ID]
    [TRANSFORMATIONS...]
    } |
  texture {
    PATTERN_TYPE
    [TEXTURE_PATTERN_MODIFIERS...]
    } |
  texture {
    tiles TEXTURE tile2 TEXTURE
    [TRANSFORMATIONS...]
    } |
  texture {
    material_map {
      BITMAP_TYPE &quot;bitmap.ext&quot;
      [BITMAP_MODS...] TEXTURE... [TRANSFORMATIONS...]
      }
    }

TEXTURE_PATTERN_MODIFIER:
  PATTERN_MODIFIER | TEXTURE_LIST |
  texture_map {
    TEXTURE_MAP_BODY
    }
</pre>

<p>There are restrictions on using patterned textures. A patterned texture
may not be used as a default texture, see the section: <a href="r3_3.html#r3_3_2_4">The #default Directive</a>.
A patterned texture cannot be used as a layer in a layered texture however 
you may use layered textures as any of the textures contained within a 
patterned texture.</p>

</div>
<a name="r3_6_1_5_1"></a>
<div class="content-level-h5" contains="Texture Maps" id="r3_6_1_5_1">
<h5>3.6.1.5.1 Texture Maps</h5>
<p>In addition to specifying blended color with a color map or a pigment map
you may create a blend of textures using <code>texture_map</code>. The syntax
for a texture map is identical to the pigment map except you specify a
texture in each map entry.</p>
<p>
The syntax for <code>texture_map</code> is as follows:</p>
<pre>
TEXTURE_MAP:
  texture_map { TEXTURE_MAP_BODY }
TEXTURE_MAP_BODY:
  TEXTURE_MAP_IDENTIFIER | TEXTURE_MAP_ENTRY...
TEXTURE_MAP_ENTRY:
  [ Value TEXTURE_BODY ]
</pre>

<p>Where <em><code>Value</code></em> is a float value between 0.0 and 1.0
inclusive and each <em>TEXTURE_BODY</em> is anything which can be inside a
<code>texture{...}</code> statement. The <code>texture</code> keyword and
<code>{}</code> braces need not be specified.</p>
<p class="Note"><strong>Note:</strong> The <code>[]</code> brackets are part of the actual <em>
TEXTURE_MAP_ENTRY</em>. They are not notational symbols denoting optional
parts. The brackets surround each entry in the texture map.</p>
<p>In <em>previous</em> versions there <em>had</em> to be from 2 to 256 entries in the map. A <font class="Change">Change</font> in version 3.8 has removed the upper restriction.</p>
<p>
For example:</p>
<pre>
texture {
  gradient x           //this is the PATTERN_TYPE
  texture_map {
    [0.3  pigment{Red} finish{phong 1}]
    [0.3  T_Wood11]    //this is a texture identifier
    [0.6  T_Wood11]
    [0.9  pigment{DMFWood4} finish{Shiny}]
    }
  }
</pre>

<p>When the <code>gradient x</code> function returns values from 0.0 to 0.3
the red highlighted texture is used. From 0.3 to 0.6 the texture identifier
<code>T_Wood11</code> is used. From 0.6 up to 0.9 a blend of <code>
T_Wood11</code> and a shiny <code>DMFWood4</code> is used. From 0.9 on up
only the shiny wood is used.</p>
<p>
Texture maps may be nested to any level of complexity you desire. The
textures in a map may have color maps or texture maps or any type of texture
you want.</p>
<p>
The blended area of a texture map works by fully calculating both
contributing textures in their entirety and then linearly interpolating the
apparent colors. This means that reflection, refraction and lighting
calculations are done twice for every point. This is in contrast to using a
pigment map and a normal map in a plain texture, where the pigment is
computed, then the normal, then reflection, refraction and lighting are
calculated once for that point.</p>
<p>
Entire textures may also be used with the block patterns such as <code>
checker</code>, <code>hexagon</code> and <code>brick</code>. For
example...</p>
<pre>
texture {
  checker
    texture { T_Wood12 scale .8 }
    texture {
      pigment { White_Marble }
      finish { Shiny }
      scale .5
      }
    }
  }
</pre>

<p class="Note"><strong>Note:</strong> In the case of block patterns the <code>texture</code> wrapping is required around the texture information. Also note that this syntax prohibits the use of a layered texture however you can work around this by declaring a texture identifier for the layered texture and referencing the identifier.</p>
<p>
A texture map is also used with the <code>average</code> texture type. See <a href="r3_6.html#r3_6_2_4_1">Average</a> for more details.</p>
<p>
You may declare and use texture map identifiers but the only way to declare
a texture block pattern list is to declare a texture identifier for the
entire texture.</p>

</div>
<a name="r3_6_1_5_2"></a>
<div class="content-level-h5" contains="Tiles" id="r3_6_1_5_2">
<h5>3.6.1.5.2 Tiles</h5>
<p>Earlier versions of POV-Ray had a patterned texture called a <em>tiles
texture</em>. It used the <code>tiles</code> and <code>tile2</code> keywords
to create a checkered pattern of textures.</p>
<pre>
TILES_TEXTURE:
  texture {
    tiles TEXTURE tile2 TEXTURE
    [TRANSFORMATIONS...]
    }
</pre>

<p>Although it is still supported for backwards compatibility you should use a <code>checker</code> block texture pattern described in the <a href="r3_6.html#r3_6_1_5_1">Texture Maps</a> section rather than tiles textures.</p>

</div>
<a name="r3_6_1_5_3"></a>
<div class="content-level-h5" contains="Material Maps" id="r3_6_1_5_3">
<h5>3.6.1.5.3 Material Maps</h5>
<p>The <code>material_map</code> patterned texture extends the concept of
image maps to apply to entire textures rather than solid colors. A material
map allows you to wrap a 2-D bit-mapped texture pattern around your 3-D
objects.</p>
<p>
Instead of placing a solid color of the image on the shape like an image
map, an entire texture is specified based on the index or color of the image
at that point. You must specify a list of textures to be used like a <em>
texture palette</em> rather than the usual color palette.</p>
<p>
When used with mapped file types such as GIF, and some PNG and TGA images,
the index of the pixel is used as an index into the list of textures you
supply. For unmapped file types such as some PNG and TGA images the 8 bit
value of the red component in the range 0-255 is used as an index.</p>
<p>
If the index of a pixel is greater than the number of textures in your list
then the index is taken modulo N where N is the length of your list of
textures.</p>
<p class="Note"><strong>Note:</strong> The <code>material_map</code> statement has nothing to do with the <code>material</code> statement. A <code>material_map</code> is <em>not</em> a way to create patterned <code>material</code>. See <a href="r3_5.html#r3_5_1_5_3">Material</a> for an explanation of this unrelated, yet similarly named, older feature.</p>

</div>
<a name="r3_6_1_5_3_1"></a>
<div class="content-level-h6" contains="Specifying a Material Map" id="r3_6_1_5_3_1">
<h6>3.6.1.5.3.1 Specifying a Material Map</h6>
<p>The syntax for a <code>material_map</code> is:</p>
<pre>
MATERIAL_MAP:
  texture {
    material_map {
      BITMAP_TYPE &quot;bitmap.ext&quot;
      [BITMAP_MODS...] TEXTURE... [TRANSFORMATIONS...]
      }
    }
BITMAP_TYPE:
  exr | gif | hdr | iff | jpeg | pgm | png | ppm | sys | tga | tiff
BITMAP_MOD:
  map_type Type | once | interpolate Type
</pre>

<p>After the required <em>BITMAP_TYPE</em> keyword is a string expression
containing the name of a bitmapped material file of the specified type.
Several optional modifiers may follow the file specification. The modifiers
are described below.</p>
<p class="Note"><strong>Note:</strong> Earlier versions of POV-Ray allowed some modifiers before the <em>BITMAP_TYPE</em> but that syntax is being phased out in favor of the syntax described here.</p>
<p>
Filenames specified in the <code>material_map</code> statements will be
searched for in the home (current) directory first and, if not found, will
then be searched for in directories specified by any <code>+L</code> or
<code>Library_Path</code> options active. This would facilitate keeping all
your material maps files in a separate subdirectory and giving a <code>
Library_Path</code> option to specify where your library of material maps
are. See the section <a href="r3_2.html#r3_2_5_3">Library Paths</a> for details.</p>
<p>
By default, the material is mapped onto the x-y-plane. The material is <em>
projected</em> onto the object as though there were a slide projector
somewhere in the -z-direction. The material exactly fills the square area
from (x,y) coordinates (0,0) to (1,1) regardless of the material's
original size in pixels. If you would like to change this default you may
translate, rotate or scale the texture to map it onto the
object's surface as desired.</p>
<p>
The file name is optionally followed by one or more <em>BITMAP_MODIFIERS</em>. There are no modifiers which are unique to a <code>material_map</code>. It only uses the generic bitmap modifiers <code>map_type</code>, <code>once</code> and <code>interpolate</code> described in <em>BITMAP_MODIFIERS</em>.</p>
<p>
Although <code>interpolate</code> is legal in material maps, the color
index is interpolated before the texture is chosen. It does not interpolate
the final color as you might hope it would. In general, interpolation of
material maps serves no useful purpose but this may be fixed in future
versions.</p>
<p>
Next is one or more <code>texture</code> statements. Each texture in the
list corresponds to an index in the bitmap file. For example:</p>
<pre>
texture {
  material_map {
    png &quot;povmap.png&quot;
      texture {  //used with index 0
        pigment {color red 0.3 green 0.1 blue 1}
        normal  {ripples 0.85 frequency 10 }
        finish  {specular 0.75}
        scale 5
        }
      texture {  //used with index 1
        pigment {White}
        finish {
        ambient 0 diffuse 0 
        reflection 0.9 specular 0.75
        }
      }
      // used with index 2
      texture {pigment{NeonPink} finish{Luminous}}
      texture {  //used with index 3
        pigment {
          gradient y
          color_map {
            [0.00 rgb &lt; 1 , 0 , 0&gt;]
            [0.33 rgb &lt; 0 , 0 , 1&gt;]
            [0.66 rgb &lt; 0 , 1 , 0&gt;]
            [1.00 rgb &lt; 1 , 0 , 0&gt;]
            }
          }
        finish{specular 0.75}
        scale 8
        }
    }
  scale 30
  translate &lt;-15, -15, 0&gt;
  }
</pre>

<p>After a <code>material_map</code> statement but still inside the texture
statement you may apply any legal texture modifiers. </p>
<p class="Note"><strong>Note:</strong> No other pigment, normal, or finish statements may be added to the texture outside the
material map.</p>
<p> The following is illegal:</p>
<pre>
texture {
  material_map {
    gif &quot;matmap.gif&quot;
    texture {T1}
    texture {T2}
    texture {T3}
    }
  finish {phong 1.0}
  }
</pre>

<p>The finish must be individually added to each texture. Earlier
versions of POV-Ray allowed such specifications but they were ignored. The
above restrictions on syntax were necessary for various bug fixes. This means
some POV-Ray 1.0 scenes using material maps many need minor modifications
that cannot be done automatically with the version compatibility mode.</p>
<p>
If particular index values are not used in an image then it may be necessary
to supply dummy textures. It may be necessary to use a paint program or other
utility to examine the map file's palette to determine how to arrange the
texture list.</p>
<p>
The textures within a material map texture may be layered but material map
textures do not work as part of a layered texture. To use a layered texture
inside a material map you must declare it as a texture identifier and invoke
it in the texture list.</p></div>

<a name="r3_6_1_6"></a>
<div class="content-level-h4" contains="Layered Textures" id="r3_6_1_6">
<h4>3.6.1.6 Layered Textures</h4>


<p>It is possible to create a variety of special effects using layered
textures. A layered texture consists of several textures that are partially
transparent and are laid one on top of the other to create a more complex
texture. The different texture layers show through the transparent portions
to create the appearance of one texture that is a combination of several
textures.</p>
<p>
You create layered textures by listing two or more textures one right after
the other. The last texture listed will be the top layer, the first one
listed will be the bottom layer. All textures in a layered texture other than
the bottom layer should have some transparency. For example:</p>
<pre>
object {
  My_Object
  texture {T1}  // the bottom layer
  texture {T2}  // a semi-transparent layer
  texture {T3}  // the top semi-transparent layer
  }
</pre>

<p>In this example T2 shows only where T3 is transparent and T1 shows only
where T2 and T3 are transparent.</p>
<p>
The color of underlying layers is filtered by upper layers but the results
do not look exactly like a series of transparent surfaces. If you had a stack
of surfaces with the textures applied to each, the light would be filtered
twice: once on the way in as the lower layers are illuminated by filtered
light and once on the way out. Layered textures do not filter the
illumination on the way in. Other parts of the lighting calculations work
differently as well. The results look great and allow for fantastic looking
textures but they are simply different from multiple surfaces. See <code>
stones.inc</code> in the standard include files directory for some
magnificent layered textures.</p>
<p class="Note"><strong>Note:</strong> In versions predating POV-Ray 3.5, <code>filter</code> used to work the same
as <code>transmit</code> in layered textures. It has been changed to work as filter should. This can change the appearance of &quot;pre 3.5&quot; textures a lot. The <code>#version</code> directive can be used to get the &quot;pre 3.5&quot; behavior.</p>
<p class="Note"><strong>Note:</strong> Layered textures must use the <code>texture</code> wrapped around any pigment, normal or finish statements. Do not use multiple pigment, normal or finish statements without putting them inside the texture statement.</p>
<p>
Layered textures may be declared. For example</p>
<pre>
#declare Layered_Examp =
  texture {T1}
  texture {T2}
  texture {T3}
</pre>

<p>may be invoked as follows:</p>
<pre>
object {
  My_Object
  texture {
    Layer_Examp
    // Any pigment, normal or finish here
    // modifies the bottom layer only.
    }
  }
</pre>

<p class="Note"><strong>Note:</strong> No macros are allowed in layered textures.  The problem is that if a macro would contain a declare the parser could no longer guess that two or more texture identifiers are supposed to belong to the layered texture and not some other declare.</p>

<p>If you wish to use a layered texture in a block pattern, such as <code>
checker</code>, <code>hexagon</code>, or <code>brick</code>, or in a <code>
material_map</code>, you must declare it first and then reference it inside a
single texture statement. A patterned texture cannot be used as a layer in a
layered texture however you may use layered textures as any of the textures
contained within a patterned texture.</p></div>

<a name="r3_6_1_7"></a>
<div class="content-level-h4" contains="UV Mapping" id="r3_6_1_7">
<h4>3.6.1.7 UV Mapping</h4>


<p>All textures in POV-Ray are defined in 3 dimensions. Even planar image mapping is
done this way. However, it is sometimes more desirable to have the texture defined for
the surface of the object. This is especially true for bicubic_patch objects and mesh
objects, that can be stretched and compressed. When the object is stretched or
compressed, it would be nice for the texture to be <em>glued</em> to the object's
surface and follow the object's deformations.</p>

<p>When uv_mapping is used, then that object's texture will be mapped to it using
surface coordinates (u and v) instead of spatial coordinates (x, y, and z). This is
done by taking a slice of the object's regular 3D texture from the XY plane (Z=0) and
wrapping it around the surface of the object, following the object's surface coordinates.</p>
<p class="Note"><strong>Note:</strong> Some textures should be rotated to fit the slice in the XY plane.</p>

<p>Syntax:</p>
<pre>
texture {
  uv_mapping pigment{PIGMENT_BODY} | pigment{uv_mapping PIGMENT_BODY}
  uv_mapping normal {NORMAL_BODY } | normal {uv_mapping NORMAL_BODY }
  uv_mapping texture{TEXTURE_BODY} | texture{uv_mapping TEXTURE_BODY)
  }
</pre>

</div>
<a name="r3_6_1_7_1"></a>
<div class="content-level-h5" contains="Supported Objects" id="r3_6_1_7_1">
<h5>3.6.1.7.1 Supported Objects</h5>
<p><font class="New">New</font> for version 3.8 the <code>cone</code>, <code>cylinder</code> and <code>lemon</code> were added to the growing list of objects that support UV mapping:</p>
<p class="Note"><strong>Note:</strong> A <font class="Change">Change</font> in version 3.8 improves <code>ovus</code> mapping as noted below. Backward compatibility can be obtained by simply using a <em>spherical</em> <code>warp</code> instead.</p>
<ul>
  <li><strong>bicubic_patch:</strong> UV coordinates are based on the patch's parametric coordinates. They stretch with the control points. The default range is (0..1) and can be changed.</li>
  <li><strong>box:</strong> the image is <em>wrapped</em> around the box, as shown below.</li>
  <li><strong>cone, cylinder:</strong> mapping is the same as the lemon object listed below, however, keep in mind that a <em>true</em> cone is <em>not</em> a cylinder.</li>
  <li><strong>lathe, sor:</strong> modified spherical mapping... the u coordinate (0..1) wraps around the y axis, while the v coordinate is linked to the object's control points (also ranging 0..1). Surface of Revolution also has special disc mapping on the end caps if the object is not <em>open</em>.</li>
   <li><strong>lemon:</strong> wrapped around the object axis (<em>u coordinate</em>) from the base point to the cap point in these (<em>v coordinate</em>) proportions: [0 to 0.25] base (center to radius) [0.25 to 0.75] spindle and [0.75 to 1.0] cap (radius to center).</li>
  <li><strong>mesh, mesh2:</strong> UV coordinates are defined for each vertex and interpolated between.</li>
  <li><strong>ovus:</strong> uses a slightly bulging conical mapping scheme that has rounded end caps with the same proportions as the aforementioned lemon.</li>
  <li><strong>parametric:</strong> in this case the map is not taken from a fixed set of coordinates but the map is taken from the area defined by the boundaries of the uv-space, in which the parametric surface has to be calculated.</li>
  <li><strong>sphere:</strong> traditional spherical mapping.</li>
  <li><strong>torus:</strong> the map is taken from the area &lt;0,0&gt;&lt;1,1&gt; where the u-coordinate is wrapped around the major radius and the the v-coordinate is wrapped around the minor radius. </li>
</ul>

<p class="Note"><strong>Note:</strong> Recent additions revealed <code>torus</code> mapping to be reversed with respect to the u-coordinate. For backward compatibility reasons it remains the same in this release, however this <em>may</em> change in the future.</p> 

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/4/48/RefImgBoxmap.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">UV Boxmap</p>
  </td>
</tr>
</table>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/5/56/RefImgUvmapping.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Additional UV Examples</p>
  </td>
</tr>
</table>

</div>
<a name="r3_6_1_7_2"></a>
<div class="content-level-h5" contains="UV Vectors" id="r3_6_1_7_2">
<h5>3.6.1.7.2 UV Vectors</h5>
<p>With the keyword <code>uv_vectors</code>, the UV coordinates of the corners can be
controlled for bicubic patches and standard triangle mesh.</p>

<p>For bicubic patches the UV coordinates can be specified for each of
the four corners of the patch. This goes right before the control points.
<br>The syntax is:</p>
<p><code>&nbsp;&nbsp;uv_vectors &lt;corner1&gt;,&lt;corner2&gt;,&lt;corner3&gt;,
&lt;corner4&gt;</code>
<br>with default
<br><code>&nbsp;&nbsp;uv_vectors &lt;0,0&gt;,&lt;1,0&gt;,&lt;1,1&gt;,&lt;0,1&gt;</code></p>


<p>For standard triangle meshes (not mesh2) you can specify the UV coordinates for each
of the three vertices <code>uv_vectors &lt;uv1&gt;,&lt;uv2&gt;,&lt;uv3&gt;</code> inside each
mesh triangle. This goes right after the coordinates (or coordinates &amp; normals with
smooth triangles) and right before the texture. 
<br>Example:</p>
<pre>
mesh {
  triangle {
    &lt;0,0,0&gt;, &lt;0.5,0,0&gt;, &lt;0.5,0.5,0&gt;
    uv_vectors &lt;0,0&gt;, &lt;1,0&gt;, &lt;1,1&gt;
    }
  triangle {
    &lt;0,0,0&gt;, &lt;0.5,0.5,0&gt;, &lt;0,0.5,0&gt;
    uv_vectors &lt;0,0&gt;, &lt;1,1&gt;, &lt;0,1&gt;
    }
  texture {
    uv_mapping
    pigment {
      image_map {
      sys &quot;SomeImage&quot;
      map_type 0
      interpolate 0
      }
    }
  }
}
</pre></div>

<a name="r3_6_1_8"></a>
<div class="content-level-h4" contains="Triangle Texture Interpolation" id="r3_6_1_8">
<h4>3.6.1.8 Triangle Texture Interpolation</h4>


<p>This feature is utilized in a number of visualization approaches: triangles with
individual textures for each vertex, which are interpolated during rendering.</p>

<p>Syntax:</p>
<pre>
MESH_TRIANGLE:
triangle { 
  &lt;Corner_1&gt;,
  &lt;Corner_2&gt;,
  &lt;Corner_3&gt;
  [MESH_TEXTURE]
  }   |
smooth_triangle { 
  &lt;Corner_1&gt;, &lt;Normal_1&gt;, 
  &lt;Corner_2&gt;, &lt;Normal_2&gt;, 
  &lt;Corner_3&gt;, &lt;Normal_3&gt; 
  [MESH_TEXTURE] 
  }

MESH_TEXTURE:
  texture { TEXTURE_IDENTIFIER } |
  texture_list {
    TEXTURE_IDENTIFIER TEXTURE_IDENTIFIER TEXTURE_IDENTIFIER
    }
</pre>
<p>To specify three vertex textures for the triangle, simply use <code>texture_list</code>
instead of texture.</p></div>

<a name="r3_6_1_9"></a>
<div class="content-level-h4" contains="Interior Texture" id="r3_6_1_9">
<h4>3.6.1.9 Interior Texture</h4>


<p>Syntax:</p>
<pre>
object {
  texture { TEXTURE_ITEMS... }
  interior_texture { TEXTURE_ITEMS...}
  }
</pre>
<p>All surfaces have an exterior and interior surface. The
<code>interior_texture</code> simply allows to specify a separate texture for the
interior surface of the object. For objects with no well defined
inside/outside (bicubic_patch, triangle, ...) the <code>interior_texture</code> is
applied to the backside of the surface.
Interior surface textures use exactly the same syntax and should work in
exactly the same way as regular surface textures, except that they use
the keyword <code>interior_texture</code> instead of <code>texture</code>.</p>

<p class="Note"><strong>Note:</strong> Do not confuse <code>interior_texture {}</code> with <code>interior {}</code>:
the first one specifies surface properties, the second one specifies volume properties.</p></div>

<a name="r3_6_1_10"></a>
<div class="content-level-h4" contains="Cutaway Textures" id="r3_6_1_10">
<h4>3.6.1.10 Cutaway Textures</h4>


<p>Syntax:</p>
<pre>
difference | intersection {
  OBJECT_1_WITH_TEXTURES
  OBJECT_2_WITH_NO_TEXTURE
  cutaway_textures
  }
</pre>

<p>When using a CSG difference or intersection to <em>cut</em> away parts of an
object, it is sometimes desirable to allow the object to retain its original texture. Generally,
however, the texture of the surface that was used to do the cutting will be displayed.
<br>Also, if the cutting object was not given a texture by the user, the default texture
is assigned to it.</p>

<p>By using the <code>cutaway_textures</code> keyword in a CSG difference or
intersection, you specify that you do not want the default texture on the intersected
surface, but instead, the textures of the parent objects in the CSG should be used.
<br>POV-Ray will determine which texture(s) to use by doing insidedness tests on
the objects in the difference or intersection. If the intersection point is inside an object,
that object's texture will be used (and evaluated at the interior point).
<br>If the parent object is a CSG of objects with different textures, then the textures on
overlapping parts will be averaged together.</p></div>

<a name="r3_6_2"></a>
<div class="content-level-h3" contains="Pattern" id="r3_6_2">
<h3>3.6.2 Pattern</h3>


<p>POV-Ray uses a method called <em>three-dimensional solid texturing</em> to
define the color, bumpiness and other properties of an object. You specify
the way that the texture varies over a surface by specifying a <em>
pattern</em>. Patterns are used in pigments, normals and texture maps as well
as media density.</p>
<p>
All patterns in POV-Ray are three dimensional. For every point in space,
each pattern has a unique value. Patterns do not wrap around a surface like
putting wallpaper on an object. The patterns exist in 3d and the objects are
carved from them like carving an object from a solid block of wood or
stone.</p>
<p>
Consider a block of wood. It contains light and dark bands that are
concentric cylinders being the growth rings of the wood. On the end of the
block you see these concentric circles. Along its length you see lines that
are the veins. However the pattern exists throughout the entire block. If you
cut or carve the wood it reveals the pattern inside. Similarly an onion
consists of concentric spheres that are visible only when you slice it.
Marble stone consists of wavy layers of colored sediments that harden into
rock.</p>
<p>
These solid patterns can be simulated using mathematical functions. Other
random patterns such as granite or bumps and dents can be generated using a
random number system and a noise function.</p>
<p>
In each case, the x, y, z coordinate of a point on a surface is used to
compute some mathematical function that returns a float value. When used with
color maps or pigment maps, that value looks up the color of the pigment to
be used. In normal statements the pattern function result modifies or
perturbs the surface normal vector to give a bumpy appearance. Used with a
texture map, the function result determines which combinations of entire
textures to be used. When used with media density it specifies the density of
the particles or gasses.</p>
<p>
The following sections describe each pattern. See the sections <a href="r3_6.html#r3_6_1_1">Pigment</a>, <a href="r3_6.html#r3_6_1_2">Normal</a>, <a href="r3_6.html#r3_6_1_5">Patterned Textures</a> and <a href="r3_6.html#r3_6_2_1_8">Density</a> for more details on how to use patterns. Unless mentioned otherwise, all patterns use the <code>ramp_wave</code> wave type by default but may use any wave type and may be used with <code>color_map</code>,
<code>pigment_map</code>, <code>normal_map</code>, <code>slope_map</code>, <code>texture_map</code>, <code>density</code>, and <code>density_map</code>.</p>

<p class="Note"><strong>Note:</strong> Some patterns have a built in default color_map that does not result in a
grey-scale pattern. This may lead to unexpected results  when one of these
patterns is used without a user specified color_map, for example in
functions or media.</p>
<p> These patterns are:</p>
<ul>
<li><code>agate</code></li>
<li><code>bozo</code></li>
<li><code>brick</code></li>
<li><code>checker</code></li>
<li><code>hexagon</code></li>
<li><code>mandel</code></li>
<li><code>marble</code></li>
<li><code>radial</code></li>
<li><code>square</code></li>
<li><code>triangular</code></li>
<li><code>wood</code></li>
</ul>

<p>See the following sections for more <em>pattern</em> and <em>pattern related topics</em>:</p>
<ul>
  <li><a href="r3_6.html#r3_6_2_1">General Patterns</a></li>
  <li><a href="r3_6.html#r3_6_2_2">Discontinuous Patterns</a></li>
  <li><a href="r3_6.html#r3_6_2_3">Normal-Dependent Patterns</a></li>
  <li><a href="r3_6.html#r3_6_2_4">Special Patterns</a></li>
  <li><a href="r3_6.html#r3_6_2_5">Pattern Modifiers</a></li>
</ul></div>

<a name="r3_6_2_1"></a>
<div class="content-level-h4" contains="General Patterns" id="r3_6_2_1">
<h4>3.6.2.1 General Patterns</h4>
<p>These general patterns can be used with textures, normals or media:</p>
<table class="tablelist">
<tr valign="top">
<td width="33%">
<code><a href="r3_6.html#r3_6_2_1_1">agate</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_2">boxed</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_3">bozo</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_5">bumps</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_6">cubic</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_7">cylindrical</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_9">dents</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_11">fractal</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_12">function</a></code><br>
</td>
<td width="33%">
<code><a href="r3_6.html#r3_6_2_1_13">gradient</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_14">granite</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_15">leopard</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_16">marble</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_17">onion</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_20">planar</a></code><br>
<code><a href="r3_6.html#r3_6_2_4_3">potential</a></code> <font class="New">New</font> in 3.8<br>
<code><a href="r3_6.html#r3_6_2_1_21">quilted</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_22">radial</a></code><br>
</td>
<td width="33%">
<code><a href="r3_6.html#r3_6_2_1_23">ripples</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_24">spherical</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_25">spiral1</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_26">spiral2</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_27">spotted</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_29">waves</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_30">wood</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_31">wrinkles</a></code><br>
</td>
</tr>
</table></div>

<a name="r3_6_2_1_1"></a>
<div class="content-level-h5" contains="Agate Pattern" id="r3_6_2_1_1">
<h5>3.6.2.1.1 Agate Pattern</h5>

<p>The <code>agate</code> pattern is a banded pattern similar to marble but
it uses a specialized built-in turbulence function that is different from the
traditional turbulence. The traditional turbulence can be used as well but it
is generally not necessary because agate is already very turbulent. You may
control the amount of the built-in turbulence by adding the optional <code>
agate_turb</code> keyword followed by a float value. For example:</p>
<pre>
pigment {
  agate
  agate_turb 0.5
  color_map {MyMap}
  }
</pre>
<p>The <code>agate</code> pattern has a default color_map built in that results
in a brown and white pattern with smooth transitions.</p>
<p>Agate as used in a normal:</p>
<pre>
normal {
  agate [Bump_Size]
  [MODIFIERS...]
  }
</pre>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/7/7a/RefImgAgatePigment.png"></td>
  <td><img class="centered" width="200px" src="images/d/d9/RefImgAgateNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">agate pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_2"></a>
<div class="content-level-h5" contains="Boxed Pattern" id="r3_6_2_1_2">
<h5>3.6.2.1.2 Boxed Pattern</h5>

<p>The <code>boxed</code> pattern creates a 2x2x2 unit cube centered at the
origin. It is computed by: <em> value =1.0- min(1, max(abs(X), abs(Y),
abs(Z)))</em> It starts at 1.0 at the origin and decreases to a minimum value
of 0.0 as it approaches any plane which is one unit from the origin. It
remains at 0.0 for all areas beyond that distance. This pattern was
originally created for use with <code>halo</code> or <code>media</code> but
it may be used anywhere any pattern may be used.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/6/6e/RefImgBoxedMedia.png"></td>
  <td><img class="centered" width="200px" src="images/f/f8/RefImgBoxedeNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">boxed pattern used as media and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_3"></a>
<div class="content-level-h5" contains="Bozo Pattern" id="r3_6_2_1_3">
<h5>3.6.2.1.3 Bozo Pattern</h5>

<p>The <code>bozo</code> pattern is a very smooth, random noise function that
is traditionally used with some turbulence to create clouds. The <code>
spotted</code> pattern is identical to <code>bozo</code> but in early
versions of POV-Ray spotted did not allow turbulence to be added. Turbulence
can now be added to any pattern so these are redundant but both are retained
for backwards compatibility. The <code>bumps</code> pattern is also identical
to <code>bozo</code> when used anywhere except in a <code>normal</code>
statement. When used as a normal pattern, <code>bumps</code> uses a slightly
different method to perturb the normal with a similar noise function.</p>
<p>
The <code>bozo</code> noise function has the following properties:</p>

<p> 1. It is defined over 3D space i.e., it takes x, y, and z and returns
the noise value there.</p>
<p>
2. If two points are far apart, the noise values at those points are
relatively random.</p>
<p>
3. If two points are close together, the noise values at those points are
close to each other.</p>

<p>You can visualize this as having a large room and a thermometer that
ranges from 0.0 to 1.0. Each point in the room has a temperature. Points that
are far apart have relatively random temperatures. Points that are close
together have close temperatures. The temperature changes smoothly but
randomly as we move through the room.</p>
<p>
Now let's place an object into this room along with an artist. The
artist measures the temperature at each point on the object and paints that
point a different color depending on the temperature. What do we get? A
POV-Ray bozo texture!</p>

<p>The <code>bozo</code> pattern has a default color_map built in that results
in a green, blue, red and white pattern with sharp transitions.</p>

<p class="Note"><strong>Note:</strong> The appearance of the bozo pattern depends on the noise generator used.
The default type is 2. This may be changed using the <code>noise_generator</code> keyword. See the section Pattern Modifiers: <a href="r3_6.html#r3_6_2_5_4">noise_generator</a>.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/6/6a/RefImgBozoPigment.png"></td>
  <td><img class="centered" width="200px" src="images/e/e1/RefImgBozoNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">bozo pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_4"></a>
<div class="content-level-h5" contains="Brick Pattern" id="r3_6_2_1_4">
<h5>3.6.2.1.4 Brick Pattern</h5>

<p>The <code>brick</code> pattern generates a pattern of bricks. The bricks
are offset by half a brick length on every other row in the x- and
z-directions. A layer of mortar surrounds each brick. The syntax is given
by</p>
<pre>
pigment {
  brick COLOR_1, COLOR_2
  [brick_size &lt;Size&gt;] [mortar Size]
  }
</pre>

<p>where <em>COLOR_1</em> is the color of the mortar and <em>COLOR_2</em> is
the color of the brick itself. If no colors are specified a default deep red
and dark gray are used. The default size of the brick and mortar together is
&lt;8, 3, 4.5&gt; units. The default thickness of the mortar is 0.5 units.
These values may be changed using the optional <code>brick_size</code> and
<code>mortar</code> pattern modifiers. You may also use pigment statements in
place of the colors. For example:</p>
<pre>
pigment {
  brick pigment{Jade}, pigment{Black_Marble}
  }
</pre>

<p>This example uses normals:</p>
<pre>
normal { brick 0.5 }
</pre>

<p>The float value is an optional bump size. You may also use full normal
statements. For example:</p>
<pre>
normal {
  brick normal{bumps 0.2}, normal{granite 0.3}
  }
</pre>

<p>When used with textures, the syntax is</p>
<pre>
texture {
  brick texture{T_Gold_1A}, texture{Stone12}
  }
</pre>

<p>This is a block pattern which cannot use wave types, <code>
color_map</code>, or <code>slope_map</code> modifiers.</p>
<p>The <code>brick</code> pattern has a default color_map built in that 
results in red bricks and grey mortar.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/3/37/RefImgBrickPigment.png"></td>
  <td><img class="centered" width="200px" src="images/2/2e/RefImgBrickNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">brick pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_5"></a>
<div class="content-level-h5" contains="Bumps Pattern" id="r3_6_2_1_5">
<h5>3.6.2.1.5 Bumps Pattern</h5>

<p>The <code>bumps</code> pattern was originally designed only to be used as
a normal pattern. It uses a very smooth, random noise function that creates
the look of rolling hills when scaled large or a bumpy orange peel when
scaled small. Usually the bumps are about 1 unit apart.</p>
<p>
When used as a normal pattern, this pattern uses a specialized normal
perturbation function. This means that the pattern cannot be used with <code>
normal_map</code>, <code>slope_map</code> or wave type modifiers in a <code>
normal</code> statement.</p>
<p>
When used as a pigment pattern or texture pattern, the <code>bumps</code>
pattern is identical to <code>bozo</code> or <code>spotted</code> and is
similar to normal bumps but is not identical as are most normals when
compared to pigments.</p>

<p class="Note"><strong>Note:</strong> The appearance of the bumps pattern depends on the noise generator used.
The default type is 2. This may be changed using the <code>noise_generator</code> keyword. See the section Pattern Modifiers: <a href="r3_6.html#r3_6_2_5_4">noise_generator</a>.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/6/6d/RefImgBumpsPigment.png"></td>
  <td><img class="centered" width="200px" src="images/b/b1/RefImgBumpsNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">bumps pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_6"></a>
<div class="content-level-h5" contains="Cubic Pattern" id="r3_6_2_1_6">
<h5>3.6.2.1.6 Cubic Pattern</h5>

<p>The <code>cubic</code> pattern takes six texture elements and maps each one to each of the six pyramids centered at each half-axis, effectively mapping each texture element to each side of a origin-centered cube.</p>
<table class="centered" width="670px" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <p class="caption">The cubic pattern and the order of texture elements</p>
    <p class="tabletext">The first group of elements map to the positive half-axis, in the X, Y and Z axes respectively. The same order is applied to the last group of elements, except on the negative half-axis.</p>
  </td>
  <td>
    <img class="right" width="120px" src="images/4/4b/RefImgCubic.png">
  </td>
</tr>
</table>
<p>The syntax is:</p>
<pre>
texture {
  cubic
    TEXTURE_ELEMENT_1
    ...
    TEXTURE_ELEMENT_6
  }
</pre></div>

<a name="r3_6_2_1_7"></a>
<div class="content-level-h5" contains="Cylindrical Pattern" id="r3_6_2_1_7">
<h5>3.6.2.1.7 Cylindrical Pattern</h5>

<p>The <code>cylindrical</code> pattern creates a one unit radius cylinder
along the Y axis. It is computed by: <em> value = 1.0-min(1, sqrt(X^2 +
Z^2))</em> It starts at 1.0 at the origin and decreases to a minimum value of
0.0 as it approaches a distance of 1 unit from the Y axis. It remains at 0.0
for all areas beyond that distance. This pattern was originally created for
use with <code>halo</code> or <code>media</code> but it may be used anywhere
any pattern may be used.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/f/f9/RefImgCylindricalPigment.png"></td>
  <td><img class="centered" width="200px" src="images/5/5f/RefImgCylindricalNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">cylindrical pattern used as media and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_8"></a>
<div class="content-level-h5" contains="Density File Pattern" id="r3_6_2_1_8">
<h5>3.6.2.1.8 Density File Pattern</h5>

<p>The <code>density_file</code> pattern is a 3-D bitmap pattern that
occupies a unit cube from location &lt;0,0,0&gt; to &lt;1,1,1&gt;. The data
file is a raw binary file format created for POV-Ray called <code>df3</code>
format. The syntax provides for the possibility of implementing other formats
in the future. This pattern was originally created for use with <code>
halo</code> or <code>media</code> but it may be used anywhere any pattern may
be used. The syntax is:</p>
<pre>
pigment {
  density_file df3 &quot;filename.df3&quot;
  [interpolate Type] [PIGMENT_MODIFIERS...]
  }
</pre>

<p>where <em><code>&quot;filename.df3&quot;</code></em> is a file name of the
data file.</p>
<p>
As a normal pattern, the syntax is</p>
<pre>
normal {
  density_file df3 &quot;filename.df3&quot; [, Bump_Size]
  [interpolate Type]
  [NORMAL_MODIFIERS...]
  }
</pre>

<p>The optional float <em><code>Bump_Size</code></em> should follow the file
name and any other modifiers follow that.</p>

<p>The density pattern occupies the unit cube regardless of the dimensions in voxels.
It remains at 0.0 for all areas beyond the unit cube. The data in the range of 0 to 255,
in case of 8 bit resolution, are scaled into a float value in the range 0.0 to 1.0.</p>

<p> The <code>interpolate</code> keyword may be specified to add interpolation
of the data. The default value of zero specifies no interpolation. A value of
one specifies tri-linear interpolation, a value of two specifies tri-cubic
interpolation</p>

<p> See the sample scenes for data file <code>include\spiral.df3</code>,and
the scenes which use it: <code>~scenes\textures\patterns\densfile.pov</code>,
<code>~scenes\interior\media\galaxy.pov</code> for examples.</p>

</div>
<a name="r3_6_2_1_8_1"></a>
<div class="content-level-h6" contains="df3 file format" id="r3_6_2_1_8_1">
<h6>3.6.2.1.8.1 df3 file format</h6>
<dl>
<dt>Header:</dt>
<dd> The <code>df3</code> format consists of a 6 byte header of three
16-bit integers with high order byte first. These three values give the
x,y,z size of the data in pixels (or more appropriately called <em>voxels
</em>).</dd>
<dt>Data:</dt>
<dd> The header is followed by x*y*z unsigned integer bytes of data with a
resolution of 8, 16 or 32 bit. The data are written with high order byte
first (big-endian). The resolution of the data is determined by the size
of the df3-file. That is, if the file is twice (minus header, of course)
as long as an 8 bit file then it is assumed to contain 16 bit ints and
if it is four times as long 32 bit ints.</dd>
</dl></div>

<a name="r3_6_2_1_9"></a>
<div class="content-level-h5" contains="Dents Pattern" id="r3_6_2_1_9">
<h5>3.6.2.1.9 Dents Pattern</h5>

<p>The <code>dents</code> pattern was originally designed only to be used as
a normal pattern. It is especially interesting when used with metallic
textures. It gives impressions into the metal surface that look like dents
have been beaten into the surface with a hammer. Usually the dents are about
1 unit apart.</p>

<p>When used as a normal pattern, this pattern uses a specialized normal
perturbation function. This means that the pattern cannot be used with <code>
normal_map</code>, <code>slope_map</code> or wave type modifiers in a <code>
normal</code> statement.</p>

<p>When used as a pigment pattern or texture pattern, the <code>dents</code>
pattern is similar to normal dents but is not identical as are most normals
when compared to pigments.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/3/36/RefImgDentsPigment.png"></td>
  <td><img class="centered" width="200px" src="images/b/b2/RefImgDentsNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">dents pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_10"></a>
<div class="content-level-h5" contains="Facets Pattern" id="r3_6_2_1_10">
<h5>3.6.2.1.10 Facets Pattern</h5>

<pre>
normal {
  facets [coords SCALE_VALUE | size FACTOR]
  [NORMAL_ITEMS...]
  }
</pre>
<p>The <code>facets</code> pattern is designed to be used as a normal,
it is not suitable for use as a pigment: it will cause an error.
<br> There are two forms of the facets pattern. One is most suited for use with rounded surfaces,
and one is most suited for use with flat surfaces.</p>

<p>If <code>coords</code> is specified, the facets pattern creates facets with a size on the same order
as the specified SCALE_VALUE. This version of facets is most suited for use with flat surfaces, but will
also work with curved surfaces. The boundaries of the facets coincide with the boundaries of the cells in
the standard crackle pattern. The coords version of this pattern may be quite similar to a crackle normal
pattern with solid specified.</p>

<p>If <code>size</code> is specified, the facets texture uses a different function that creates facets
only on curved surfaces. The FACTOR determines how many facets are created, with smaller values
creating more facets, but it is not directly related to any real-world measurement. The same factor
will create the same pattern of facets on a sphere of any size.
<br>This pattern creates facets by snapping normal vectors to the closest vectors in a perturbed grid
of normal vectors. Because of this, if a surface has normal vectors that do not vary along one or more
axes, there will be no facet boundaries along those axes.</p>


<table class="centered" width="220px" cellpadding="0" cellspacing="10">
<tr>

  <td><img class="centered" width="200px" src="images/7/70/RefImgFactesNormal.png"></td>
</tr>
<tr>
  <td><p class="caption">facets pattern used as normal</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_11"></a>
<div class="content-level-h5" contains="Fractal Pattern" id="r3_6_2_1_11">
<h5>3.6.2.1.11 Fractal Pattern</h5>

<p>Fractal patterns supported in POV-Ray:</p>
<ul>
<li>The Mandelbrot set with exponents up to 33. The formula for these is: <code>z(n+1) = z(n)^p + c</code>, where <code>p</code> is the correspondent exponent.</li>
<li>The equivalent Julia sets.</li>
<li>The magnet1 and magnet2 fractals (which are derived from some magnetic renormalization transformations; see the fractint help for more details). Both 'Mandelbrot' and 'Julia' versions of them are supported.</li>
</ul>
<p>For the Mandelbrot and Julia sets, higher exponents will be slower for two reasons:</p>
<ol>
<li> For the exponents 2,3 and 4 an optimized algorithm is used. Higher exponents use a generic algorithm for raising a complex number to an integer exponent, and this is a bit slower than an optimized version for a certain exponent.</li>
<li> The higher the exponent, the slower it will be. This is because the amount of operations needed to raise a complex number to an integer exponent is directly proportional to the exponent. This means that exponent 10 will be (very) roughly twice as slow as exponent 5.</li>
</ol>
<table class="centered" width="700px" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="centered" width="680px" src="images/1/14/RefImgMandelExponents.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Mandelbrot and Julia fractal patterns of exponents 2 to 5</p>
  </td>
</tr>
</table>
<p>The syntax is:</p>
<pre>
MANDELBROT:
  mandel ITERATIONS [, BUMP_SIZE]
  [exponent EXPONENT]
  [exterior EXTERIOR_TYPE, FACTOR]
  [interior INTERIOR_TYPE, FACTOR]

JULIA:
  julia COMPLEX, ITERATIONS [, BUMP_SIZE]
  [exponent EXPONENT]
  [exterior EXTERIOR_TYPE, FACTOR]
  [interior INTERIOR_TYPE, FACTOR]

MAGNET MANDEL:
  magnet MAGNET_TYPE mandel ITERATIONS [, BUMP_SIZE]
  [exterior EXTERIOR_TYPE, FACTOR]
  [interior INTERIOR_TYPE, FACTOR]

MAGNET JULIA:
  magnet MAGNET_TYPE julia COMPLEX, ITERATIONS [, BUMP_SIZE]
  [exterior EXTERIOR_TYPE, FACTOR]
  [interior INTERIOR_TYPE, FACTOR]
</pre>
<p>Where:</p>
<p><code>ITERATIONS</code> is the number of times to iterate (up to 2^32-1) the algorithm.</p>
<p><code>COMPLEX</code> is a 2D vector denoting a complex number.</p>
<p><code>MAGNET_TYPE</code> is either 1 or 2.</p>
<p><code>exponent</code> is an integer between 2 and 33. If not given, the default is 2.</p>
<p><code>interior</code> and <code>exterior</code> specify special coloring algorithms. You can specify one of them or both at the same time. They only work with the fractal patterns.
<br><code>EXTERIOR_TYPE</code> and <code>INTERIOR_TYPE</code> are integer
values between 0 and 6 (inclusive). When not specified, the default value of INTERIOR_TYPE
is 0 and for EXTERIOR_TYPE  1.
<br><code>FACTOR</code> is a float. The return value of the pattern is multiplied by
<code>FACTOR</code> before returning it. This can be used to scale the value range
of the pattern when using interior and exterior coloring (this is often needed to get the
desired effect). The default value of FACTOR is 1.</p>

<table class="centered" width="700px" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="centered" width="320px" src="images/a/a4/RefImgMagnet.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Magnet mandel and julia type 1 and 2 fractal patterns</p>
  </td>
</tr>
</table>

<p>The different values of <code>EXTERIOR_TYPE</code> and <code>INTERIOR_TYPE</code> have the following
meaning:</p>
<ul>
<li>0: Returns just 1</li>
<li>1: For exterior: The number of iterations until bailout divided by ITERATIONS.
<br><p class="Note"><strong>Note:</strong> This is not scaled by FACTOR (since it is internally
scaled by 1/ITERATIONS instead).</p>&nbsp;&nbsp;&nbsp;&nbsp;For interior: The absolute value of the smallest point in the orbit of the calculated point</li>
<li>2: Real part of the last point in the orbit</li>
<li>3: Imaginary part of the last point in the orbit</li>
<li>4: Squared real part of the last point in the orbit</li>
<li>5: Squared imaginary part of the last point in the orbit</li>
<li>6: Absolute value of the last point in the orbit</li>
<li>7: For exterior only: the number of iterations modulo FACTOR and divided by FACTOR.
<br><p class="Note"><strong>Note:</strong> This is of course not scaled by FACTOR. The covered range is 0 to FACTOR-1/FACTOR.</p></li>
<li>8: For exterior only: the number of iterations modulo FACTOR+1 and divided by FACTOR.
<br><p class="Note"><strong>Note:</strong> This is of course not scaled by FACTOR. The covered range is 0 to 1.</p></li>
</ul>

<p>Example:</p>
<pre>
box {&lt;-2, -2, 0&gt;, &lt;2, 2, 0.1&gt;
  pigment {
    julia &lt;0.353, 0.288&gt;, 30
    interior 1, 1
    color_map { 
      [0 rgb 0]
      [0.2 rgb x]
      [0.4 rgb x+y]
      [1 rgb 1]
      [1 rgb 0]
      }
    }
  }
</pre>
<table class="centered" width="700px" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="centered" width="680px" src="images/a/a0/RefImgJuliaColorings.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Different exterior and interior coloring types of fractal patterns</p>
  </td>
</tr>
</table></div>

<a name="r3_6_2_1_12"></a>
<div class="content-level-h5" contains="Function Pattern" id="r3_6_2_1_12">
<h5>3.6.2.1.12 Function Pattern</h5>

<p>Allows you to use a function { } block as pattern.</p>
<pre>
pigment {
  function { USER_DEFINED_FUNCTIONS }
  [PIGMENT_MODIFIERS...]
  }
</pre>

<p>Declaring a function:<br>
By default a function takes three parameters (x,y,z) and you do not have
to explicitly specify the parameter names when declaring it. When using
the identifier, the parameters must be specified.</p>
<pre>
#declare Foo = function { x + y + z}

pigment {
  function { Foo(x, y, z) }
  [PIGMENT_MODIFIERS...]
  }
</pre>

<p>On the other hand, if you need more or less than three parameters when
declaring a function, you also have to explicitly specify the parameter
names.</p> 
<pre>
#declare Foo = function(x,y,z,t) { x + y + z + t}

pigment {
  function { Foo(x, y, z, 4) }
  [PIGMENT_MODIFIERS...]
  }
</pre>

<p>Using function in a normal:</p>
<pre>
#declare Foo = function { x + y + z}

normal {
  function { Foo(x, y, z) } [Bump_Size]
  [MODIFIERS...]
  }
</pre>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/6/6f/RefImgFunctionPigment.png"></td>
  <td><img class="centered" width="200px" src="images/2/26/RefImgFunctionNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">function pattern used as pigment and normal respectively</p></td>
</tr>
</table>

</div>
<a name="r3_6_2_1_12_1"></a>
<div class="content-level-h6" contains="What can be used" id="r3_6_2_1_12_1">
<h6>3.6.2.1.12.1 What can be used</h6>
<p>All float expressions and operators. See the section <a href="r3_3.html#r3_3_1_5_4">User-Defined Functions</a> for what is legal in POV-Ray. Of special interest here is the <code>pattern</code> option, that makes it possible to use patterns as functions</p>
<pre>
#declare FOO = function {
  pattern {
    checker
    }
  }
</pre>

<p>User defined functions (like equations).</p>

<p>Since pigments can be declared as functions, they can also be used in
functions. They must be declared first. When using the identifier, you
have to specify which component of the color vector should be used. To
do this, the dot notation is used: Function(x,y,z).red</p>
<pre>
#declare FOO = function {pigment { checker } }
  pigment {
    function { FOO(x,y,z).green }
    [PIGMENT_MODIFIERS...]
    }
</pre>

<p>POV-Ray has a large amount of pre-defined functions. These are mainly
algebraic surfaces but there is also a mesh function and noise3d
function. See section <a href="r3_8.html#r3_8_1_1_8">Internal Functions</a> for a complete list and some
explanation on the parameters to use. These internal functions can be
included through the functions.inc include file.</p>
<pre> 
#include &quot;functions.inc&quot;
#declare FOO = function {pigment { checker } }
  pigment {
    function { FOO(x,y,z).green &amp; f_noise3d(x*2, y*3,z)}
    [PIGMENT_MODIFIERS...]
    }
</pre>

</div>
<a name="r3_6_2_1_12_2"></a>
<div class="content-level-h6" contains="Function Image" id="r3_6_2_1_12_2">
<h6>3.6.2.1.12.2 Function Image</h6>
<p>Syntax :</p>

<code>function Width, Height { FUNCTION_BODY }</code>

<p>Not a real pattern, but listed here for convenience. This keyword defines
a new 'internal' bitmap image type. The pixels of the image are derived
from the Function_Body, with Function_Body either being a regular
function, a pattern function or a pigment function.  In case of a pigment
function the output image will be in color, in case of a pattern or regular
function the output image will be grayscale.  All variants of grayscale
pigment functions are available using the regular function syntax, too.
In either case the image will use 16 bit per component</p>

<p class="Note"><strong>Note:</strong> Functions are evaluated on the x-y plane.  This is different from
the pattern image type for the reason that it makes using uv functions
easier.</p>

<p>Width and Height specify the resolution of the resulting 'internal' bitmap image.
The image is taken from the square region <code>&lt;0,0,0&gt;, &lt;1,1,0&gt;</code></p>

<p>The <code>function</code> statement can be used wherever an image specifier
like <code>tga</code> or <code>png</code> may be used. Some uses include
creating heightfields from procedural textures or wrapping a slice of a 3d
texture or function around a cylinder or extrude it along an axis.</p>

<p>Examples:</p>
<pre>
plane {y, -1 
  pigment { 
    image_map { 
      function 10,10 { 
        pigment { checker 1,0 scale .5  }
        }
      }
    rotate x*90
    } 
  }
</pre>
<pre>
height_field {
  function 200,200 {
    pattern {
      bozo
      }
    }
  translate -0.5
  scale 10
  pigment {rgb 1}
  }
</pre>

<p class="Note"><strong>Note:</strong> For height fields and other situations where color is not needed
it is easier to use <code>function n,n {pattern{...}}</code> than <code>function n,n {pigment{...}}</code>.
The pattern functions are returning a scalar, not a color vector, thus a pattern is grayscale.</p></div>

<a name="r3_6_2_1_13"></a>
<div class="content-level-h5" contains="Gradient Pattern" id="r3_6_2_1_13">
<h5>3.6.2.1.13 Gradient Pattern</h5>

<p>One of the simplest patterns is the <code>gradient</code> pattern. It is
specified as</p>
<pre>
pigment {
  gradient &lt;Orientation&gt;
  [PIGMENT_MODIFIERS...]
  }
</pre>

<p>where <em><code>&lt;Orientation&gt;</code></em> is a vector pointing in
the direction that the colors blend. For example</p>
<pre>
pigment { gradient x } // bands of color vary as you move
                       // along the &quot;x&quot; direction.
</pre>

<p>produces a series of smooth bands of color that look like layers of colors
next to each other. Points at x=0 are the first color in the color map. As
the x location increases it smoothly turns to the last color at x=1. Then it
starts over with the first again and gradually turns into the last color at
x=2. In POV-Ray versions older than 3.5 the pattern reverses for negative values of x. 
As per POV-Ray 3.5 this is not the case anymore. Using <code>gradient
y</code> or <code>gradient z</code> makes the colors blend along the y- or
z-axis. Any vector may be used but x, y and z are most common.</p>
<p>
As a normal pattern, gradient generates a saw-tooth or ramped wave
appearance. The syntax is</p>
<pre>
normal {
  gradient &lt;Orientation&gt; [, Bump_Size]
  [NORMAL_MODIFIERS...]
  }
</pre>

<p>where the vector <em><code>&lt;Orientation&gt;</code></em> is a required
parameter but the float <em><code>Bump_Size</code></em> which follows is
optional.</p>
<p class="Note"><strong>Note:</strong> The comma is required especially if <em>Bump_Size</em> is
negative.</p>

<p>If only the range -1 to 1 was used of the old gradient, for example in a
<code>sky_sphere</code>, it can be replaced by the <code>planar</code> or <code>marble</code>
pattern and revert the color_map. Also rotate the pattern for other orientations than <code>y</code>.
A more general solution is to use <code>function{abs(x)}</code> as a pattern instead
of <code>gradient x</code> and similar for <code>gradient y</code> and <code>gradient z</code>.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/c/c0/RefImgGradientPigment.png"></td>
  <td><img class="centered" width="200px" src="images/9/9b/RefImgGradientNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">gradient pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_14"></a>
<div class="content-level-h5" contains="Granite Pattern" id="r3_6_2_1_14">
<h5>3.6.2.1.14 Granite Pattern</h5>

<p>The <code>granite</code> pattern uses a simple 1/f fractal noise function
to give a good granite pattern. This pattern is used with creative color maps
in <code>stones.inc</code> to create some gorgeous layered stone
textures.</p>
<p>
As a normal pattern it creates an extremely bumpy surface that looks like a
gravel driveway or rough stone.</p>

<p class="Note"><strong>Note:</strong> The appearance of the granite pattern depends on the noise generator used.
The default type is 2. This may be changed using the <code>noise_generator</code> keyword. See the Pattern Modifiers section: <a href="r3_6.html#r3_6_2_5_4">noise_generator</a>.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/0/0e/RefImgGranitePigment.png"></td>
  <td><img class="centered" width="200px" src="images/8/8d/RefImgGraniteNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">granite pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_15"></a>
<div class="content-level-h5" contains="Leopard Pattern" id="r3_6_2_1_15">
<h5>3.6.2.1.15 Leopard Pattern</h5>

<p>Leopard creates regular geometric pattern of circular spots. The formula
used is: <em> value = Sqr((sin(x)+sin(y)+sin(z))/3)</em></p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/5/5e/RefImgLeopardPigment.png"></td>
  <td><img class="centered" width="200px" src="images/8/84/RefImgLeopardNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">leopard pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_16"></a>
<div class="content-level-h5" contains="Marble Pattern" id="r3_6_2_1_16">
<h5>3.6.2.1.16 Marble Pattern</h5>

<p>The <code>marble</code> pattern is very similar to the <code>gradient
x</code> pattern. The gradient pattern uses a default <code>ramp_wave</code>
wave type which means it uses colors from the color map from 0.0 up to 1.0 at
location x=1 but then jumps back to the first color for x &gt; 1 and repeats
the pattern again and again. However the <code>marble</code> pattern uses
the <code>triangle_wave</code> wave type in which it uses the color map from
0 to 1 but then it reverses the map and blends from 1 back to zero. For
example:</p>
<pre>
pigment {
  gradient x
  color_map {
    [0.0  color Yellow]
    [1.0  color Cyan]
    }
  }
</pre>

<p>This blends from yellow to cyan and then it abruptly changes back to
yellow and repeats. However replacing <code>gradient x</code> with <code>
marble</code> smoothly blends from yellow to cyan as the x coordinate goes
from 0.0 to 0.5 and then smoothly blends back from cyan to yellow by
x=1.0.</p>
<p>
Earlier versions of POV-Ray did not allow you to change wave types. Now that
wave types can be changed for most any pattern, the distinction between
<code>marble</code> and <code>gradient x</code> is only a matter of default
wave types.</p>
<p>
When used with turbulence and an appropriate color map, this pattern looks
like veins of color of real marble, jade or other types of stone. By default,
marble has no turbulence.</p>

<p>The <code>marble</code> pattern has a default color_map built in that results
in a red, black and white pattern with smooth and sharp transitions.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/5/5e/RefImgMarblePigment.png"></td>
  <td><img class="centered" width="200px" src="images/7/78/RefImgMarbleNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">marble pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_17"></a>
<div class="content-level-h5" contains="Onion Pattern" id="r3_6_2_1_17">
<h5>3.6.2.1.17 Onion Pattern</h5>

<p>The <code>onion</code> is a pattern of concentric spheres like the layers
of an onion. <em> Value = mod(sqrt(Sqr(X)+Sqr(Y)+Sqr(Z)), 1.0)</em> Each
layer is one unit thick.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/a/a3/RefImgOnionPigment.png"></td>
  <td><img class="centered" width="200px" src="images/b/b7/RefImgOnionNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">onion pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_18"></a>
<div class="content-level-h5" contains="Pavement Pattern" id="r3_6_2_1_18">
<h5>3.6.2.1.18 Pavement Pattern</h5>

<p>The <code>pavement</code> is a pattern which paves the x-z plane with a single polyform tile. A polyform is a plane figure constructed by joining together identical basic polygons. The <code>number_of_sides</code> is used to choose that basic polygon: an equilateral triangle (3), a square (4) or a hexagon (6). The <code>number_of_tiles</code> is used to choose the number of basic polygons in the tile while <code>pattern</code> is used to choose amongst the variants.</p>

<p>The syntax is:</p>
<pre>
pigment {
  pavement 
  [PAVEMENT_MODIFIERS...]
  }

PAVEMENT_MODIFIERS:
  number_of_sides SIDES_VALUE | number_of_tiles TILES_VALUE | pattern PATTERN_VALUE |
  exterior EXTERIOR_VALUE | interior INTERIOR_VALUE | form FORM_VALUE |
  PATTERN_MODIFIERS
</pre>

<p>A table of the number of patterns:</p>
<table>
<tr><th rowspan="2">&nbsp;Sides&nbsp;</th><th colspan="6"><center>Tiles</center></th></tr>
<tr><th>1</th><th>2</th><th>3</th><th>4</th><th>&nbsp;5</th><th>&nbsp;6</th></tr>
<tr><th><center>3</center></th><td>1</td><td>1</td><td>1</td><td>3</td><td>&nbsp;4</td><td>12</td></tr>
<tr><th><center>4</center></th><td>1</td><td>1</td><td>2</td><td>5</td><td>12</td><td>35</td></tr>
<tr><th><center>6</center></th><td>1</td><td>1</td><td>3</td><td>7</td><td>22</td><td>&nbsp;</td></tr>
</table>

<table class="centered" width="650x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="630px" src="images/9/9e/RefImgPavement.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The various patterns with 6 squares.</p>
  </td>
</tr>
</table>

<p>There is no nomenclature for pattern, they are just numbered from 1 to the maximum relevant value.</p>

<dl>
<dt><code>form</code></dt>
<dd>0, 1 or 2, a special 3 is allowed for square only which copy the look of <code>interior</code> for some additional variations.</dd>
</dl>

<dl>
<dt><code>interior</code></dt>
<dd>0, 1 or 2</dd>
</dl>
<dl>

<dt><code>exterior</code></dt>
<dd>0, 1 or 2; Not used for hexagon.</dd>
</dl>

<p>The <code>form</code>, <code>exterior</code> and <code>interior</code> specify the look of angle used for respectively slow convex (turning side), quick convex (pointy tile) and concave angle (interior angle between many tiles).</p>

<ul><li>0 is a normal pointy angle. (a right angle for square)</li>
<li>1 is the same as 0, but the pointy angle is broken in two. For square, the two corners are broken so as to share middle angle.</li>
<li>2 is a smooth negotiation of the angle, without pointy part.</li>
</ul>

<p class="Note"><strong>Note: </strong> The case of paving the plane with tiles made of 6 hexagons is not supported because not all such tiles would pave the plane. For example, the ring made of six hexagons is not able to pave the plane.</p></div>

<a name="r3_6_2_1_19"></a>
<div class="content-level-h5" contains="Pigment Pattern" id="r3_6_2_1_19">
<h5>3.6.2.1.19 Pigment Pattern</h5>

<p>Use any pigment as a pattern. Instead of using the pattern directly on the object, a
pigment_pattern converts the pigment to gray-scale first. For each point, the gray-value
is checked against a list and the corresponding item is then used for the texture at
that particular point. For values between listed items, an averaged texture is calculated.
<br>Texture items can be color, pigment, normal or texture and are specified in a
color_map, pigment_map, normal_map or texture_map.
<br>It takes a standard pigment specification.</p>

<p>Syntax:</p>
<pre>
PIGMENT:
  pigment {
    pigment_pattern { PIGMENT_BODY }
    color_map { COLOR_MAP_BODY } |
    colour_map { COLOR_MAP_BODY } | 
    pigment_map { PIGMENT_MAP_BODY }
    }

NORMAL:
  normal {
    pigment_pattern { PIGMENT_BODY } [Bump_Size]
    normal_map { NORMAL_MAP_BODY }
    }

TEXTURE:
  texture {
    pigment_pattern { PIGMENT_BODY }
    texture_map { TEXTURE_MAP_BODY }
    }

ITEM_MAP_BODY:
  ITEM_MAP_IDENTIFIER | ITEM_MAP_ENTRY...
  ITEM_MAP_ENTRY:
  [ GRAY_VALUE  ITEM_MAP_ENTRY... ]
</pre>

<p>This pattern is also useful when parent and children patterns need to be
transformed independently from each other. Transforming the pigment_pattern
will not affect the child textures. When any of the child textures should be
transformed, apply it to the specific MAP_ENTRY.</p>

<p>This can be used with any pigments, ranging from a simple checker to very
complicated nested pigments. For example:</p>

<pre>
pigment {
  pigment_pattern {
    checker White, Black
    scale 2
    turbulence .5
    }
  pigment_map {
    [ 0, checker Red, Green scale .5 ]
    [ 1, checker Blue, Yellow scale .2 ]
    }
  }
</pre>

<p class="Note"><strong>Note:</strong> This pattern uses a pigment to get the gray values. If you want to
get the pattern from an image, you should use the <a href="r3_6.html#r3_6_2_4_2">image_pattern</a>.</p></div>

<a name="r3_6_2_1_20"></a>
<div class="content-level-h5" contains="Planar Pattern" id="r3_6_2_1_20">
<h5>3.6.2.1.20 Planar Pattern</h5>

<p>The <code>planar</code> pattern creates a horizontal stripe plus or minus
one unit above and below the X-Z plane. It is computed by: <em> value =1.0-
min(1, abs(Y))</em> It starts at 1.0 at the origin and decreases to a minimum
value of 0.0 as the Y values approaches a distance of 1 unit from the X-Z
plane. It remains at 0.0 for all areas beyond that distance. This pattern was
originally created for use with <code>halo</code> or <code>media</code> but
it may be used anywhere any pattern may be used.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/3/37/RefImgPlanarPigment.png"></td>
  <td><img class="centered" width="200px" src="images/4/4d/RefImgPlanarNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">planar pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_21"></a>
<div class="content-level-h5" contains="Quilted Pattern" id="r3_6_2_1_21">
<h5>3.6.2.1.21 Quilted Pattern</h5>

<p>The <code>quilted</code> pattern was originally designed only to be used
as a normal pattern. The quilted pattern is so named because it can create a
pattern somewhat like a quilt or a tiled surface. The squares are actually
3-D cubes that are 1 unit in size.</p>
<p>
When used as a normal pattern, this pattern uses a specialized normal
perturbation function. This means that the pattern cannot be used with <code>
normal_map</code>, <code>slope_map</code> or wave type modifiers in a <code>
normal</code> statement.</p>
<p>
When used as a pigment pattern or texture pattern, the <code>quilted</code>
pattern is similar to normal quilted but is not identical as are most normals
when compared to pigments.</p>
<p>

The two parameters <code>control0</code> and <code>control1</code> are used
to adjust the curvature of the <em>seam</em> or <em>gouge</em> area between
the <code>quilts</code>.</p>
<p>
The syntax is:</p>
<pre>
pigment {
  quilted
  [QUILTED_MODIFIERS...]
  }

QUILTED_MODIFIERS:
  control0 Value_0 | control1 Value_1 | PIGMENT_MODIFIERS
</pre>

<p>The values should generally be kept to around the 0.0 to 1.0 range. The
default value is 1.0 if none is specified. Think of this gouge between the
tiles in cross-section as a sloped line.</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/7/7d/RefImgQuiltpt1.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Quilted pattern with c0=0 and different values for c1.</p>
  </td>
</tr>
</table>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/b/b1/RefImgQuiltpt2.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Quilted pattern with c0=0.33 and different values for c1.</p>
  </td>
</tr>
</table>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/c/c8/RefImgQuiltpt3.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Quilted pattern with c0=0.67 and different values for c1.</p>
  </td>
</tr>
</table>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/e/e9/RefImgQuiltpt4.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">Quilted pattern with c0=1 and different values for c1.</p>
  </td>
</tr>
</table>

<p>This straight slope can be made to curve by adjusting the two control
values. The control values adjust the slope at the top and bottom of the
curve. A control values of 0 at both ends will give a linear slope, as shown
above, yielding a hard edge. A control value of 1 at both ends will give an
&quot;s&quot; shaped curve, resulting in a softer, more rounded edge.</p>

<p>The syntax for use as a normal is:</p>
<pre>
normal { 
  quilted [Bump_Size]
  [QUILTED_MODIFIERS...] 
  }

QUILTED_MODIFIERS:
  control0 Value_0 | control1 Value_1 | PIGMENT_MODIFIERS
</pre>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/7/79/RefImgQuiltedPigment.png"></td>
  <td><img class="centered" width="200px" src="images/0/07/RefImgQuiltedNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">quilted pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_22"></a>
<div class="content-level-h5" contains="Radial Pattern" id="r3_6_2_1_22">
<h5>3.6.2.1.22 Radial Pattern</h5>

<p>The <code>radial</code> pattern is a radial blend that wraps around the
+y-axis. The color for value 0.0 starts at the +x-direction and wraps the
color map around from east to west with 0.25 in the -z-direction, 0.5 in -x,
0.75 at +z and back to 1.0 at +x. Typically the pattern is used with a <code>
frequency</code> modifier to create multiple bands that radiate from the
y-axis. For example:</p>
<pre>
pigment {
  radial
  color_map {
    [0.5 Black]
    [0.5 White]
    }
  frequency 10
  }
</pre>

<p>creates 10 white bands and 10 black bands radiating from the y axis.</p>
<p>The <code>radial</code> pattern has a default color_map built in that results
in a yellow, magenta and cyan pattern with smooth transitions.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/c/c0/RefImgRadialPigment.png"></td>
  <td><img class="centered" width="200px" src="images/f/fa/RefImgRadialNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">radial pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_23"></a>
<div class="content-level-h5" contains="Ripples Pattern" id="r3_6_2_1_23">
<h5>3.6.2.1.23 Ripples Pattern</h5>

<p>The <code>ripples</code> pattern was originally designed only to be used
as a normal pattern. It makes the surface look like ripples of water. The
ripples radiate from 10 random locations inside the unit cube area
&lt;0,0,0&gt; to &lt;1,1,1&gt;. Scale the pattern to make the centers closer
or farther apart.</p>
<p>
Usually the ripples from any given center are about 1 unit apart. The <code>
frequency</code> keyword changes the spacing between ripples. The <code>
phase</code> keyword can be used to move the ripples outwards for realistic
animation.</p>
<p>
The number of ripple centers can be changed with the global parameter</p>
<pre>
global_settings { number_of_waves Count }
</pre>

<p>somewhere in the scene. This affects the entire scene. You cannot change the number of wave centers on individual patterns. See the section <a href="r3_4.html#r3_4_1_10">Number Of Waves</a> for details.</p>
<p>When used as a normal pattern, this pattern uses a specialized normal
perturbation function. This means that the pattern cannot be used with <code>
normal_map</code>, <code>slope_map</code> or wave type modifiers in a <code>normal</code> statement.</p>
<p>When used as a pigment pattern or texture pattern, the <code>ripples</code>
pattern is similar to normal ripples but is not identical as are most normals
when compared to pigments.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/d/da/RefImgRipplesPigment.png"></td>
  <td><img class="centered" width="200px" src="images/5/50/RefImgRipplesNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">ripples pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_24"></a>
<div class="content-level-h5" contains="Spherical Pattern" id="r3_6_2_1_24">
<h5>3.6.2.1.24 Spherical Pattern</h5>

<p>The <code>spherical</code> pattern creates a one unit radius sphere, with its center at 
the origin. It is computed by: <em> value = 1.0-min(1, sqrt(X^2 + Y^2 +
Z^2))</em> It starts at 1.0 at the origin and decreases to a minimum value of 0.0
as it approaches a distance of 1 unit from the origin in any direction. It
remains at 0.0 for all areas beyond that distance. This pattern was
originally created for use with <code>halo</code> or <code>media</code> but
it may be used anywhere any pattern may be used.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/b/bd/RefImgSphericalMedia.png"></td>
  <td><img class="centered" width="200px" src="images/2/2b/RefImgSphericalNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">spherical pattern used as media and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_25"></a>
<div class="content-level-h5" contains="Spiral1 Pattern" id="r3_6_2_1_25">
<h5>3.6.2.1.25 Spiral1 Pattern</h5>

<p>The <code>spiral1</code> pattern creates a spiral that winds around the
z-axis similar to a screw. When viewed sliced in the x-y plane, it looks like
the spiral arms of a galaxy. Its syntax is:</p>
<pre>
pigment {
  spiral1 Number_of_Arms
  [PIGMENT_MODIFIERS...]
  }
</pre>

<p>The <em><code>Number_of_Arms</code></em> value determines how may arms are
winding around the z-axis.</p>
<p>
As a normal pattern, the syntax is</p>
<pre>
normal {
  spiral1 Number_of_Arms [, Bump_Size]
  [NORMAL_MODIFIERS...]
  }
</pre>

<p>where the <code>Number_of_Arms</code> value is a required
parameter but the float <em><code>Bump_Size</code></em> which follows is
optional. </p>
<p class="Note"><strong>Note:</strong> The comma is required especially if <em>Bump_Size</em> is
negative.</p>
<p>The pattern uses the <code>triangle_wave</code> wave type by default but may
use any wave type.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/a/ac/RefImgSpiral1Pigment.png"></td>
  <td><img class="centered" width="200px" src="images/f/f3/RefImgSpiral1Normal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">spiral1 pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_26"></a>
<div class="content-level-h5" contains="Spiral2 Pattern" id="r3_6_2_1_26">
<h5>3.6.2.1.26 Spiral2 Pattern</h5>

<p>The <code>spiral2</code> pattern creates a double spiral that winds around
the z-axis similar to <code>spiral1</code> except that it has two overlapping spirals
which twist in opposite directions. The result sometimes looks like a basket
weave or perhaps the skin of pineapple. The center of a sunflower also has a
similar double spiral pattern. Its syntax is:</p>
<pre>
pigment {
  spiral2 Number_of_Arms
  [PIGMENT_MODIFIERS...]
  }
</pre>

<p>The <em><code>Number_of_Arms</code></em> value determines how may arms are
winding around the z-axis. As a normal pattern, the syntax is</p>
<pre>
normal {
  spiral2 Number_of_Arms [, Bump_Size]
  [NORMAL_MODIFIERS...]
  }
</pre>

<p>where the <code>Number_of_Arms</code> value is a required
parameter but the float <em><code>Bump_Size</code></em> which follows is
optional.</p>
<p class="Note"><strong>Note:</strong> The comma is required especially if <em>Bump_Size</em> is negative. The pattern uses the <code>triangle_wave</code> wave type by default but may use any wave type.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/e/e9/RefImgSpiral2Pigment.png"></td>
  <td><img class="centered" width="200px" src="images/5/51/RefImgSpiral2Normal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">spiral2 pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_27"></a>
<div class="content-level-h5" contains="Spotted Pattern" id="r3_6_2_1_27">
<h5>3.6.2.1.27 Spotted Pattern</h5>

<p>The <code>spotted</code> pattern is identical to the <code>bozo</code>
pattern. Early versions of POV-Ray did not allow turbulence to be used with
spotted. Now that any pattern can use turbulence there is no difference
between <code>bozo</code> and <code>spotted</code>. See the section <a href="r3_6.html#r3_6_2_1_3">Bozo</a> for details.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/0/00/RefImgSpottedPigment.png"></td>
  <td><img class="centered" width="200px" src="images/1/1a/RefImgSpottedNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">spotted pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_28"></a>
<div class="content-level-h5" contains="Tiling Pattern" id="r3_6_2_1_28">
<h5>3.6.2.1.28 Tiling Pattern</h5>

<p>The <code>tiling</code> pattern creates a series tiles in the x-z plane. See the image below for examples of the twenty-seven available patterns.</p>
<p>The syntax is as follows:</p>
<pre>
pigment {
  tiling Pattern_Number
  [PATTERN_MODIFIERS...]
  }
</pre>
<table class="centered" width="580px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="560px" src="images/d/d0/RefImgTiling2.gif"></td>
</tr>
<tr>
  <td><p class="caption">The various tiling patterns annotated by tiling pattern and tiling type respectively</p></td>
</tr>
</table>

<p>For each pattern, each individual tile of the pattern has the same beveling as the other tiles in that pattern, allowing regular caulking to be defined. For a pattern with N tile types (where N is the tiling type noted in the above image) the main color/texture of the tiles are at x/N with x going from 0 to N-1, and the extreme color/texture caulk for these tiles are at (x+1)/N. The bevel covers the range between these two values.</p>

<p>To begin exploring the <code>tiling</code> pattern right away, see the distribution file <code>~scenes/textures/pattern/tiling.pov</code>. It uses obvious colors to better illustrate how the feature works, and you can optionally write it's <code>color_map</code> to a text file. Once you get a feel for the break points, you can always define you own map!</p></div>

<a name="r3_6_2_1_29"></a>
<div class="content-level-h5" contains="Waves Pattern" id="r3_6_2_1_29">
<h5>3.6.2.1.29 Waves Pattern</h5>

<p>The <code>waves</code> pattern was originally designed only to be used as
a normal pattern. It makes the surface look like waves on water. The <code>
waves</code> pattern looks similar to the <code>ripples</code> pattern except
the features are rounder and broader. The effect is to make waves that look
more like deep ocean waves. The waves radiate from 10 random locations inside
the unit cube area &lt;0,0,0&gt; to &lt;1,1,1&gt;. Scale the pattern to make
the centers closer or farther apart.</p>
<p>Usually the waves from any given center are about 1 unit apart. The <code>
frequency</code> keyword changes the spacing between waves. The <code>
phase</code> keyword can be used to move the waves outwards for realistic
animation.</p>
<p>The number of wave centers can be changed with the global parameter</p>
<pre>
global_settings { number_of_waves Count }
</pre>

<p>somewhere in the scene. This affects the entire scene. You cannot change the number of wave centers on individual patterns. See the section <a href="r3_4.html#r3_4_1_10">Number Of Waves</a> for details.</p>
<p>When used as a normal pattern, this pattern uses a specialized normal
perturbation function. This means that the pattern cannot be used with <code>
normal_map</code>, <code>slope_map</code> or wave type modifiers in a <code>normal</code> statement.</p>
<p>When used as a pigment pattern or texture pattern, the <code>waves</code>
pattern is similar to normal waves but is not identical as are most normals
when compared to pigments.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/6/69/RefImgWavesPigment.png"></td>
  <td><img class="centered" width="200px" src="images/5/5c/RefImgWavesNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">waves pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_30"></a>
<div class="content-level-h5" contains="Wood Pattern" id="r3_6_2_1_30">
<h5>3.6.2.1.30 Wood Pattern</h5>

<p>The <code>wood</code> pattern consists of concentric cylinders centered on
the z-axis. When appropriately colored, the bands look like the growth rings
and veins in real wood. Small amounts of turbulence should be added to make
it look more realistic. By default, wood has no turbulence.</p>
<p>Unlike most patterns, the <code>wood</code> pattern uses the <code>
triangle_wave</code> wave type by default. This means that like marble, wood
uses color map values 0.0 to 1.0 then repeats the colors in reverse order
from 1.0 to 0.0. However you may use any wave type.</p>
<p>The <code>wood</code> pattern has a default color_map built in that results
in a light and dark brown pattern with sharp transitions.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/4/44/RefImgWoodPigment.png"></td>
  <td><img class="centered" width="200px" src="images/b/b9/RefImgWoodNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">wood pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_1_31"></a>
<div class="content-level-h5" contains="Wrinkles Pattern" id="r3_6_2_1_31">
<h5>3.6.2.1.31 Wrinkles Pattern</h5>

<p>The <code>wrinkles</code> pattern was originally designed only to be used
as a normal pattern. It uses a 1/f noise pattern similar to granite but the
features in wrinkles are sharper. The pattern can be used to simulate
wrinkled cellophane or foil. It also makes an excellent stucco texture.</p>
<p>When used as a normal pattern, this pattern uses a specialized normal
perturbation function. This means that the pattern cannot be used with <code>
normal_map</code>, <code>slope_map</code> or wave type modifiers in a <code>
normal</code> statement.</p>
<p>When used as a pigment pattern or texture pattern, the <code>wrinkles</code>
pattern is similar to normal wrinkles but is not identical as are most
normals when compared to pigments.</p>

<p class="Note"><strong>Note:</strong> The appearance of the wrinkles pattern depends on the noise generator used.
The default type is 2. This may be changed using the <code>noise_generator</code> keyword. See the section Pattern Modifiers: <a href="r3_6.html#r3_6_2_5_4">noise_generator</a>.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/3/3e/RefImgWrinklesPigment.png"></td>
  <td><img class="centered" width="200px" src="images/7/76/RefImgWrinklesNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">wrinkles pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_2"></a>
<div class="content-level-h4" contains="Discontinuous Patterns" id="r3_6_2_2">
<h4>3.6.2.2 Discontinuous Patterns</h4>
<p>Some patterns are discontinuous, meaning their slope is infinite. These patterns are <em>not</em> suitable for use as object normals. These patterns work best with textures and media:</p>
<table class="tablelist">
<tr valign="top">
<td width="33%">
<code><a href="r3_6.html#r3_6_2_1_4">brick</a></code><br>
<code><a href="r3_6.html#r3_6_2_2_1">cells</a></code><br>
<code><a href="r3_6.html#r3_6_2_2_2">checker</a></code><br>
<code><a href="r3_6.html#r3_6_2_2_3">crackle</a></code><br>
</td>
<td width="33%">
<code><a href="r3_6.html#r3_6_2_1_10">facets</a></code><br>
<code><a href="r3_6.html#r3_6_2_2_4">hexagon</a></code><br>
<code><a href="r3_6.html#r3_6_2_2_5">object</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_18">pavement</a></code><br>
</td>
<td width="33%">
<code><a href="r3_6.html#r3_6_2_2_6">square</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_28">tiling</a></code><br>
<code><a href="r3_6.html#r3_6_2_2_7">triangular</a></code><br>
</td>
</tr>
</table>
<p class="Note"><strong>Note:</strong> The <code>cells</code> and <code>crackle</code> patterns are mixed cases in that they are <em>discontinuous</em> at their respective boundaries. However, there is no limit to the different number of values, in the range of 0 to 1, that they can generate. When using the <code>solid</code> keyword with the <code>crackle</code> pattern it becomes <em>discontinuous</em>. The <code>pavement</code> and <code>tiling</code> patterns are also <em>discontinuous</em> at their respective boundaries, while other portions ramp.</p></div>

<a name="r3_6_2_2_1"></a>
<div class="content-level-h5" contains="Cells Pattern" id="r3_6_2_2_1">
<h5>3.6.2.2.1 Cells Pattern</h5>

<p>The <code>cells</code> pattern fills 3d space with unit cubes. Each cube gets a
random value from 0 to 1.</p>
<p><code>cells</code> is not very suitable as a normal as it has no smooth
transitions of one grey value to another.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/8/81/RefImgCellsPigment.png"></td>
  <td><img class="centered" width="200px" src="images/b/b9/RefImgCellsNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">cells pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_2_2"></a>
<div class="content-level-h5" contains="Checker Pattern" id="r3_6_2_2_2">
<h5>3.6.2.2.2 Checker Pattern</h5>

<p>The <code>checker</code> pattern produces a checkered pattern consisting
of alternating squares of two colors. The syntax is:</p>
<pre>
pigment { checker [COLOR_1 [, COLOR_2]] [PATTERN_MODIFIERS...] }
</pre>

<p>If no colors are specified then default blue and green colors are
used.</p>
<p>
The checker pattern is actually a series of cubes that are one unit in size.
Imagine a bunch of 1 inch cubes made from two different colors of modeling
clay. Now imagine arranging the cubes in an alternating check pattern and
stacking them in layer after layer so that the colors still alternate in
every direction. Eventually you would have a larger cube. The pattern of
checks on each side is what the POV-Ray checker pattern produces when applied
to a box object. Finally imagine cutting away at the cube until it is carved
into a smooth sphere or any other shape. This is what the checker pattern
would look like on an object of any kind.</p>
<p>
You may also use pigment statements in place of the colors. For example:</p>
<pre>
pigment { checker pigment{Jade}, pigment{Black_Marble} }
</pre>

<p>This example uses normals:</p>
<pre>
normal { checker 0.5 }
</pre>

<p>The float value is an optional bump size. You may also use full normal
statements. For example:</p>
<pre>
normal {
  checker normal{gradient x scale .2}, normal{gradient y scale .2}
  }
</pre>

<p>When used with textures, the syntax is</p>
<pre>
texture { checker texture{T_Wood_3A}, texture{Stone12} }
</pre>

<p>The <code>checker</code> pattern has a default color_map built in that
results in blue and green tiles.</p>

<p>This use of checker as a texture pattern replaces the special tiles
texture in previous versions of POV-Ray. You may still use <code>
tiles</code> but it may be phased out in future versions so checker textures
are best.</p>
<p>
This is a block pattern which cannot use wave types, <code>
color_map</code>, or <code>slope_map</code> modifiers.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/1/1b/RefImgCheckerPigment.png"></td>
  <td><img class="centered" width="200px" src="images/2/25/RefImgCheckerNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">checker pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_2_3"></a>
<div class="content-level-h5" contains="Crackle Pattern" id="r3_6_2_2_3">
<h5>3.6.2.2.3 Crackle Pattern</h5>

<p>The <code>crackle</code> pattern is a set of random tiled multifaceted cells. The crackle pattern is only semi-procedural, requiring random values to be computed and cached for subsequent queries, with a fixed amount of data per unit-cube in crackle pattern coordinate space. Scaled smaller than the density of actual ray-object-intersections computed, it will eventually lead to a separate crackle cache entry being created for each and every intersection. After the cache reaches a certain size (currently 30mb per thread), new entries for that particular block will be discarded after they are calculated. Starting a new block will allow the caching to resume working again. While discarding the data is of course inefficient, it's still preferable to chewing up 100% of the available physical RAM and then hitting the swap-file.</p>

<p>There is a choice between different types:</p>

<p><strong>Standard Crackle</strong></p>
<p>Mathematically, the set crackle(p)=0 is a 3D Voronoi diagram of a field of semi random points and crackle(p) &lt; 0 is the distance from the set along the shortest path (a Voronoi diagram is the locus of points equidistant from their two nearest neighbors from a set of disjoint points, like the membranes in suds are to the centers of the bubbles).</p>
<ul>
<li>With a large scale and no turbulence it makes a pretty good stone wall or floor.</li>
<li>With a small scale and no turbulence it makes a pretty good crackle ceramic glaze.</li>
<li>Using high turbulence it makes a good marble that avoids the problem of apparent
parallel layers in traditional marble.</li>
</ul>

<p><strong>Form</strong></p>
<pre>
pigment {
  crackle form &lt;FORM_VECTOR&gt;
  [PIGMENT_ITEMS ...]
  }

normal {
  crackle [Bump_Size]
  form &lt;FORM_VECTOR&gt;
  [NORMAL_ITEMS ...]
  }
</pre>
<p>Form determines the linear combination of distances used to create the pattern. Form is a vector.</p>
<ul>
<li>The first component determines the multiple of the distance to the closest point to be used in determining the value of the pattern at a particular point.</li>
<li>The second component determines the coefficient applied to the second-closest distance.</li>
<li>The third component corresponds to the third-closest distance.</li>
</ul>
<p>The standard form is &lt;-1,1,0&gt; (also the default), corresponding to the difference in the distances to the closest and second-closest points in the cell array. Another commonly-used form is &lt;1,0,0&gt;, corresponding to the distance to the closest point, which produces a pattern that looks roughly like a random collection of intersecting spheres or cells.</p>
<ul>
<li>Other forms can create very interesting effects, but it is best to keep the sum of the coefficients low.</li>
<li>If the final computed value is too low or too high, the resultant pigment will be saturated with the color at the low or high end of the <code>color_map</code>. In this case, try multiplying the form vector by a constant.</li>
</ul>

<p><strong>Metric</strong></p>
<pre>
pigment {
  crackle metric METRIC_VALUE
  [PIGMENT_ITEMS ...]
  }

normal {
  crackle [Bump_Size]
  metric METRIC_VALUE
  [NORMAL_ITEMS ...]
  }
</pre>
<p>Changing the metric changes the function used to determine which cell center is closer, for purposes of determining which cell a particular point falls in. The standard Euclidean distance function has a metric of 2. Changing the metric value changes the boundaries of the cells. A metric value of 3, for example, causes the boundaries to curve, while a very large metric constrains the boundaries to a very small set of possible orientations.</p>
<ul>
<li>The default for metric is 2, as used by the standard crackle texture.</li>
<li>Metrics other than 1 or 2 can lead to substantially longer render times, as the method used to calculate such metrics is not as efficient.</li>
</ul>

<p><strong>Offset</strong></p>
<pre>
pigment {
  crackle offset OFFSET_VALUE
  [PIGMENT_ITEMS ...]
  }

normal {
  crackle [Bump_Size]
  offset OFFSET_VALUE
  [NORMAL_ITEMS ...]
  }
</pre>
<p>The offset is used to displace the pattern from the standard xyz space along a fourth dimension.</p>
<ul>
<li>It can be used to round off the <em>pointy</em> parts of a cellular normal texture or procedural heightfield by keeping the distances from becoming zero.</li>
<li>It can also be used to move the calculated values into a specific range if the result is saturated at one end of the color_map.</li>
<li>The default offset is zero.</li>
</ul>

<p><strong>Repeat</strong></p>
<pre>
pigment {
  crackle repeat VECTOR
  [PIGMENT_ITEMS ...]
  }

normal {
  crackle [Bump_Size]
  repeat VECTOR
  [NORMAL_ITEMS ...]
  }
</pre>
<p><font class="New">New</font> to version 3.8 <code>repeat</code> causes the pattern to repeat seamlessly at regular intervals along the X, Y and/or Z axis, as specified by the corresponding components of the specified vector. Values of 0 indicate no repetition along the corresponding axis. For technical reasons, only integer intervals are supported. The default for this parameter is <code>&lt;0,0,0&gt;</code>, i.e. no repetition.</p>

<p><strong>Solid</strong></p>
<pre>
pigment {
  crackle solid
  [PIGMENT_ITEMS ...]
  }

normal {
  crackle [Bump_Size]
  solid
  [NORMAL_ITEMS ...]
  }
</pre>
<p>Causes the same value to be generated for every point within a specific cell. This has practical applications in making easy stained-glass windows or flagstones. There is no provision for mortar, but mortar may be created by layering or texture-mapping a
standard crackle texture with a solid one. The default for this parameter is off.</p>

<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/3/34/RefImgCracklePigment.png"></td>
  <td><img class="centered" width="200px" src="images/b/ba/RefImgCrackleNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">crackle pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_2_4"></a>
<div class="content-level-h5" contains="Hexagon Pattern" id="r3_6_2_2_4">
<h5>3.6.2.2.4 Hexagon Pattern</h5>

<p>The <code>hexagon</code> pattern is a block pattern that generates a
repeating pattern of hexagons in the x-z-plane. In this instance imagine tall
rods that are hexagonal in shape and are parallel to the y-axis and grouped
in bundles like shown in the example image. Three separate colors should be
specified as follows:</p>
<pre>
pigment {
  hexagon [COLOR_1 [, COLOR_2 [, COLOR_3]]]
  [PATTERN_MODIFIERS...]
  }
</pre>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <img class="center" width="640px" src="images/5/5b/RefImgHexpat.gif">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The hexagon pattern.</p>
  </td>
</tr>
</table>

<p>The three colors will repeat the hexagonal pattern with hexagon <em>
COLOR_1</em> centered at the origin, <em>COLOR_2</em> in the +z-direction and
<em>COLOR_3</em> to either side. Each side of the hexagon is one unit long.
The hexagonal rods of color extend infinitely in the +y- and -y-directions.
If no colors are specified then default blue, green and red colors are
used.</p>
<p>
You may also use pigment statements in place of the colors. For example:</p>
<pre>
pigment {
  hexagon 
  pigment { Jade },
  pigment { White_Marble },
  pigment { Black_Marble }
  }
</pre>

<p>This example uses normals:</p>
<pre>
normal { hexagon 0.5 }
</pre>

<p>The float value is an optional bump size. You may also use full normal
statements. For example:</p>
<pre>
normal {
  hexagon
  normal { gradient x scale .2 },
  normal { gradient y scale .2 },
  normal { bumps scale .2 }
  }
</pre>

<p>When used with textures, the syntax is...</p>
<pre>
texture {
  hexagon
  texture { T_Gold_3A },
  texture { T_Wood_3A },
  texture { Stone12 }
  }
</pre>
<p>The <code>hexagon</code> pattern has a default color_map built in that results
in red, blue and green tiles.</p>

<p>This is a block pattern which cannot use wave types, <code>
color_map</code>, or <code>slope_map</code> modifiers.</p></div>

<a name="r3_6_2_2_5"></a>
<div class="content-level-h5" contains="Object Pattern" id="r3_6_2_2_5">
<h5>3.6.2.2.5 Object Pattern</h5>

<p>The <code>object</code> pattern takes an object as input. It generates a, two item,
color list pattern. Whether a point is assigned to one item or the other depends on 
whether it is inside the specified object or not. </p>
<p>Object's used in the <code>object</code> pattern cannot have a texture and must
be solid - these are the same limitations as for <code>bounded_by</code> and
<code>clipped_by</code>.</p>

<p>Syntax:</p>
<pre>
object {
  OBJECT_IDENTIFIER | OBJECT {}
  LIST_ITEM_A, LIST_ITEM_B
  }
</pre>

<p>Where OBJ_IDENTIFIER is the target object (which must be declared), or use the
full object syntax. LIST_ITEM_A and LIST_ITEM_B are the colors, pigments, or whatever
the pattern is controlling. LIST_ITEM_A is used for all points outside the object,
and LIST_ITEM_B is used for all points inside the object.</p>
<p>Example:</p>
<pre>
pigment {
  object {
    myTextObject 
    color White 
    color Red
    }
  turbulence 0.15
  }
</pre>

<p class="Note"><strong>Note:</strong> This is a block pattern which <em>cannot</em> use wave types, <code>color_map</code>, or <code>slope_map</code> modifiers.</p></div>

<a name="r3_6_2_2_6"></a>
<div class="content-level-h5" contains="Square Pattern" id="r3_6_2_2_6">
<h5>3.6.2.2.6 Square Pattern</h5>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td width="200px">
    <img class="left" width="200px" src="images/4/4c/RefImgSquare.png">
  </td>
  <td>
    <p>The <code>square</code> pattern is a block pattern that generates a repeating pattern of squares in the x-z plane. In this instance imagine tall rods that are square in shape and are parallel to the y-axis and grouped in bundles like shown in the example image. Four separate colors should be specified as follows:</p>
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The square pattern.</p>
  </td>
  <td></td>
</tr>
</table>

<pre>
pigment {
  square [COLOR_1 [, COLOR_2 [, COLOR_3 [, COLOR_4]]]]
  [PATTERN_MODIFIERS...]
  }
</pre>

<p>Each side of the square is one unit long. The square rods of color extend infinitely in the +y and -y directions. If no colors are specified then default blue, green, red and yellow colors are used.</p>
<p>
You may also use pigment statements in place of the colors. For example:</p>
<pre>
pigment {
  square  
  pigment { Aquamarine },
  pigment { Turquoise },
  pigment { Sienna },
  pigment { SkyBlue }
}
</pre>

<p>When used with textures, the syntax is...</p>
<pre>
texture {
  square  
  texture{ T_Wood1 },
  texture{ T_Wood2 },
  texture{ T_Wood4 },
  texture{ T_Wood8 }
}
</pre>
<p>The <code>square</code> pattern has a default color map built in that results in red, blue, yellow and green tiles.</p>

<p>This is a block pattern so, use of wave types, <code>color_map</code>, or <code>slope_map</code> modifiers is <em>not</em> allowed.</p></div>

<a name="r3_6_2_2_7"></a>
<div class="content-level-h5" contains="Triangular Pattern" id="r3_6_2_2_7">
<h5>3.6.2.2.7 Triangular Pattern</h5>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td width="200px">
    <img class="right" width="200px" src="images/6/64/RefImgTriangular.png">
  </td>
  <td>
    <p>The <code>triangular</code> pattern is a block pattern that generates a repeating pattern of triangles in the x-z plane. In this instance imagine tall rods that are triangular in shape and are parallel to the y-axis and grouped in bundles like shown in the example image. Six separate colors should be specified as follows:</p>
  </td>
</tr>
<tr>
  <td>
    <p class="caption">The triangular pattern.</p>
  </td>
  <td></td>
</tr>
</table>

<pre>
pigment {
  triangular [COLOR_1 [, COLOR_2 [, COLOR_3 [, COLOR_4 [, COLOR_5  [, COLOR_6]]]]]]
  [PATTERN_MODIFIERS...]
  }
</pre>

<p>Each side of the triangle is one unit long. The triangular rods of color extend infinitely in the +y and -y directions. If no colors are specified then default blue, green, red, magenta, cyan and yellow colors are used.</p>
<p>
You may also use pigment statements in place of the colors. For example:</p>
<pre>
pigment { 
  triangular
  pigment { Aquamarine },
  pigment { Turquoise },
  pigment { Sienna },
  pigment { Aquamarine },
  pigment { Turquoise },
  pigment { SkyBlue }
}
</pre>

<p>When used with textures, the syntax is...</p>
<pre>
texture {
  triangular 
  texture{ T_Wood1 },
  texture{ T_Wood2 },
  texture{ T_Wood4 },
  texture{ T_Wood8 },
  texture{ T_Wood16 },
  texture{ T_Wood10 }
}
</pre>
<p>The <code>triangular</code> pattern has a default color map built in that results in red, blue, cyan, magenta, yellow and green tiles.</p>

<p>This is a block pattern so, use of wave types, <code>color_map</code>, or <code>slope_map</code> modifiers is <em>not</em> allowed.</p></div>

<a name="r3_6_2_3"></a>
<div class="content-level-h4" contains="Normal-Dependent Patterns" id="r3_6_2_3">
<h4>3.6.2.3 Normal-Dependent Patterns</h4>
<p>These patterns depend on the normal vector in addition to a position vector:</p>
<table class="tablelist">
<tr valign="top">
<td width="33%">
<code><a href="r3_6.html#r3_6_2_3_1">aoi</a></code><br>
</td>
<td width="33%">
<code><a href="r3_6.html#r3_6_2_1_10">facets</a></code><br>
</td>
<td width="33%">
<code><a href="r3_6.html#r3_6_2_3_2">slope</a></code><br>
</td>
</tr>
</table>
<p class="Note"><strong>Note:</strong> The <code>facets</code> pattern can <em>only</em> be used in a normal statement.</p></div>

<a name="r3_6_2_3_1"></a>
<div class="content-level-h5" contains="Aoi Pattern" id="r3_6_2_3_1">
<h5>3.6.2.3.1 Aoi Pattern</h5>

<p>The <code>aoi</code> pattern can be used with <code>pigment</code>, <code>normal</code> and <code>texture</code> statements. The syntax is as follows:</p>
<pre>
pigment {
  aoi
  pigment_map {
    [0.0 MyPigmentA]
    ...
    [1.0 MyPigmentZ]
    }
  }

normal {
  aoi
  normal_map {
    [0.0 MyNormalA]
    ...
    [1.0 MyNormalZ]
    }
  }

texture {
  aoi
  texture_map {
    [0.0 MyTextureA]
    ...
    [1.0 MyTextureZ]
    }
  }
</pre>
<p>It gives a value proportional to the angle between the ray and the  surface; for consistency with the slope pattern, values range from 0.5 where ray is tangent to the surface, to 1.0 where perpendicular; in practice, values below 0.5 may occur in conjunction with smooth triangles or meshes.</p>
<p class="Note"><strong>Note:</strong> This differs from the current MegaPOV implementation, where the values range from 0.5 down to 0.0 instead. If compatibility with MegaPOV is desired, it is recommended to mirror the gradient at 0.5, e.g.:</p>
<pre>
pigment {
  aoi
  pigment_map {
    [0.0 MyPigment3]
    [0.2 MyPigment2]
    [0.5 MyPigment1]
    [0.8 MyPigment2]
    [1.0 MyPigment3]
    }
  }
</pre></div>

<a name="r3_6_2_3_2"></a>
<div class="content-level-h5" contains="Slope Pattern" id="r3_6_2_3_2">
<h5>3.6.2.3.2 Slope Pattern</h5>

<p>The <code>slope</code> pattern uses the normal of a surface to calculate the slope
at a given point. It then creates the pattern value dependent on the slope and optionally
the altitude. It can be used for pigments, normals and textures, but not for media densities.For pigments the syntax is:</p>
<pre>
pigment {
  slope {
    &lt;Direction&gt; [, Lo_slope, Hi_slope ]
    [ altitude &lt;Altitude&gt; [, Lo_alt, Hi_alt ]]
    }
  [PIGMENT_MODIFIERS...]
  }
</pre>
<p>The slope value at a given point is dependent on the angle between the <code>&lt;Direction&gt;</code> vector and the normal of the surface at that point.</p>
<p>For example:</p>
<ul>
<li> When the surface normal points in the opposite direction of the <code>&lt;Direction&gt;</code> vector (180 degrees), the slope is 0.0.</li>
<li> When the surface normal is perpendicular to the <code>&lt;Direction&gt;</code> vector (90 degrees), the slope is 0.5.</li>
<li> When the surface normal is parallel to the <code>&lt;Direction&gt;</code> vector (0 degrees), the slope is 1.0.</li>
</ul>
<p>When using the simplest variant of the syntax:</p>
<pre>
slope { &lt;Direction&gt; }
</pre>
<p>the pattern value for a given point is the same as the slope value. <code>&lt;Direction&gt;</code> is a 3-D vector and will usually be <code>&lt;0,-1,0&gt;</code> for landscapes, but any direction can be used.</p>
<p>By specifying <code>Lo_slope</code> and <code>Hi_slope</code> you get more control:</p>
<pre>
slope { &lt;Direction&gt;, Lo_slope, Hi_slope }
</pre>
<p><code>Lo_slope</code> and <code>Hi_slope</code> specifies which range of slopes are used, so you can control which slope values return which pattern values. <code>Lo_slope</code> is the slope value that returns 0.0 and <code>Hi_slope</code> is the slope value that returns 1.0.</p>
<p>For example, if you have a height_field and <code>&lt;Direction&gt;</code> is set to <code>&lt;0,-1,0&gt;</code>, then the slope values would only range from 0.0 to 0.5 because height_fields cannot have overhangs. If you do not specify <code>Lo_slope</code> and <code>Hi_slope</code>, you should keep in mind that the texture for the flat (horizontal) areas must be set at 0.0 and the texture for the steep (vertical) areas at 0.5 when designing the texture_map. The part from 0.5 up to 1.0 is not used then. But, by setting <code>Lo_slope</code> and <code>Hi_slope</code> to 0.0 and 0.5 respectively, the slope range will be stretched over the entire map, and the texture_map can then be defined from 0.0 to 1.0.</p>
<p>By adding an optional <code>&lt;Altitude&gt;</code> vector:</p>
<pre>
slope {
  &lt;Direction&gt;
  altitude &lt;Altitude&gt;
  }
</pre>
<p>the pattern will be influenced not only by the slope but also by a special gradient. <code>&lt;Altitude&gt;</code> is a  3-D vector that specifies the direction of the gradient. When <code>&lt;Altitude&gt;</code> is specified, the pattern value is a weighted average of the slope value and the gradient value. The weights are the lengths of the vectors <code>&lt;Direction&gt;</code> and <code>&lt;Altitude&gt;</code>. So if <code>&lt;Direction&gt;</code> is much longer than <code>&lt;Altitude&gt;</code> it means that the slope has greater effect on the results than the gradient. If on the other hand <code>&lt;Altitude&gt;</code> is longer, it means that the gradient has more effect on the results than the slope.</p>
<p>When adding the <code>&lt;Altitude&gt;</code> vector, the default gradient is defined from 0 to 1 units along the specified axis. This is fine when your object is defined within this range, otherwise a correction is needed. This can be done with the optional <code>Lo_alt</code> and <code>Hi_alt</code> parameters:</p>
<pre>
slope {
  &lt;Direction&gt;
  altitude &lt;Altitude&gt;, Lo_alt, Hi_alt
  }
</pre>
<p>They define the range of the gradient along the axis defined by the &lt;Altitude&gt; vector.</p>
<p>For example, with an <code>&lt;Altitude&gt;</code> vector set to y and an object going from -3 to 2 on 
the y axis, the <code>Lo_alt</code> and <code>Hi_alt</code> parameters should be set to -3 and 2 respectively.</p>
<p class="Note"><strong>Note:</strong> You should be aware of the following pitfalls when using the <code>slope</code> pattern.</p>
<ul>
<li>You may use the turbulence keyword inside slope pattern definitions but it may cause unexpected results. Turbulence is a 3-D distortion of a pattern. Since slope is only defined on surfaces of objects, a 3-D turbulence is not applicable to the slope component. However, if you are using altitude, the altitude component of the pattern will be affected by turbulence.</li>
<li>If your object is larger than the range of altitude you have specified, you may experience unexpected discontinuities. In that case it is best to adjust the <code>Lo_alt</code> and <code>Hi_alt</code> values so they fit to your object.</li>
<li>The slope pattern does not work for the sky_sphere, because the sky_sphere is a background feature and does not have a surface. similarly, it does not work for media densities.</li>
</ul>
<p>As of version 3.7 the <code>slope</code> pattern has been  extended to specify a reference point instead of a direction; the new syntax variant is as follows:</p>
<pre>
slope {
  point_at &lt;ReferencePoint&gt; [, Lo_Slope, Hi_Slope ]
  }
</pre>
<p class="Note"><strong>Note:</strong> This variant currently does <em>not</em> allow for the <code>altitude</code> keyword to be used.</p>
<p>The functionality is similar to MegaPOV's <code>aoi &lt;ReferencePoint&gt;</code> pattern, except that the values are reversed, i.e. range from 0.0 for surfaces facing away from the point in question, to 1.0 for surfaces facing towards that point; thus, <code>slope { &lt;Vector&gt; }</code> and <code>slope { point_at &lt;Vector&gt;*VeryLargeNumber }</code> have virtually the same effect.</p></div>

<a name="r3_6_2_4"></a>
<div class="content-level-h4" contains="Special Patterns" id="r3_6_2_4">
<h4>3.6.2.4 Special Patterns</h4>
<p>These patterns are not <em>real</em> patterns, but behave like patterns and are used in the same location as a regular pattern:</p>
<table class="tablelist">
<tr valign="top">
<td width="15%">
<code><a href="r3_6.html#r3_6_2_4_1">average</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_8">density_file</a></code><br>
</td>
<td width="15%">
<code><a href="r3_6.html#r3_6_2_4_2">image</a></code><br>
<code><a href="r3_6.html#r3_6_2_1_19">pigment_pattern</a></code><br>
</td>
<td width="15%">
<code><a href="r3_6.html#r3_6_2_3_2">slope</a></code><br>
</td>
</tr>
</table></div>

<a name="r3_6_2_4_1"></a>
<div class="content-level-h5" contains="Average Pattern" id="r3_6_2_4_1">
<h5>3.6.2.4.1 Average Pattern</h5>

<p>Technically <code>average</code> is not a pattern type but it is listed here
because the syntax is similar to other patterns. Typically a pattern type specifies
how colors or normals are chosen from a <code>pigment_map</code>,
<code>texture_map</code>, <code>density_map</code>, or <code>normal_map
</code>, however <code>average</code> tells POV-Ray to
average together all of the patterns you specify. Average was originally
designed to be used in a normal statement with a <code>normal_map</code> as a
method of specifying more than one normal pattern on the same surface.
However average may be used in a pigment statement with a <code>
pigment_map</code> or in a texture statement with a <code>texture_map</code>
or media density with <code>density_map</code> to average colors too.</p>
<p>
When used with pigments, the syntax is:</p>
<pre>
AVERAGED_PIGMENT:

pigment {
  pigment_map {
    PIGMENT_MAP_ENTRY...
    }
  }

PIGMENT_MAP_ENTRY:
[ [Weight] PIGMENT_BODY ]
</pre>

<p>Where <em><code>Weight</code></em> is an optional float value that
defaults to 1.0 if not specified. This weight value is the relative weight
applied to that pigment. Each <em>PIGMENT_BODY</em> is anything which can be
inside a <code>pigment{...}</code> statement. The <code>pigment</code>
keyword and <code>{}</code> braces need not be specified.</p>
<p class="Note"><strong>Note:</strong> The <code>[]</code> brackets are part of the actual <em>
PIGMENT_MAP_ENTRY</em>. They are not notational symbols denoting optional
parts. The brackets surround each entry in the <code>pigment_map</code>.</p>
<p>In <em>previous</em> versions there <em>had</em> to be from 2 to 256 entries in the map. A <font class="Change">Change</font> in version 3.8 has removed the upper restriction.</p>
<p>
For example</p>
<pre>
pigment {
  average
  pigment_map {
    [1.0  Pigment_1]
    [2.0  Pigment_2]
    [0.5  Pigment_3]
    }
  }
</pre>

<p>All three pigments are evaluated. The weight values are multiplied by the
resulting color. They are then divided by the total of the weights which, in
this example is 3.5. When used with <code>texture_map</code> or <code>
density_map</code> it works the same way.</p>
<p>
When used with a <code>normal_map</code> in a normal statement, multiple
copies of the original surface normal are created and are perturbed by each
pattern. The perturbed normals are then weighted, added and normalized.</p>
<p>
See the sections <a href="r3_6.html#r3_6_1_1_3">Pigment Maps and Pigment Lists</a>, <a href="r3_6.html#r3_6_1_2_1">Normal Maps and Normal Lists</a>, <a href="r3_6.html#r3_6_1_5_1">Texture Maps</a>, and <a href="r3_7.html#r3_7_2_4_3">Density Maps and Density Lists</a> for more information.</p></div>

<a name="r3_6_2_4_2"></a>
<div class="content-level-h5" contains="Image Pattern" id="r3_6_2_4_2">
<h5>3.6.2.4.2 Image Pattern</h5>

<p>Instead of placing the color of the image on the object using an <code>image_map</code>, the <code>image_pattern</code> specifies an entire texture item (color, pigment, normal or texture) based on the gray value at that point.</p>
<p>This gray value is evaluated against a list and the corresponding item is then used for the texture at that particular point. For values between listed items, an averaged texture is calculated.</p>
<p>It takes a standard image specification with the option, <code>use_alpha</code>, which works similar to <code>use_color</code> or <code>use_index</code>.</p>
<p class="Note"><strong>Note:</strong> See the section <a href="r3_6.html#r3_6_2_6_4">Using the Alpha Channel</a> for some important information regarding the use of <code>image_pattern</code>.</p>
<p>Syntax:</p>
<pre>
PIGMENT:
  pigment {
    IMAGE_PATTERN
    color_map { COLOR_MAP_BODY } | colour_map { COLOR_MAP_BODY } | pigment_map { PIGMENT_MAP_BODY }
    }
NORMAL:
  normal {
    IMAGE_PATTERN [Bump_Size]
    normal_map { NORMAL_MAP_BODY }
    }
TEXTURE:
  texture {
    IMAGE_PATTERN
    texture_map { TEXTURE_MAP_BODY }
    }

IMAGE_PATTERN:
  image_pattern {
    BITMAP_TYPE &quot;bitmap.ext&quot; [gamma GAMMA] [premultiplied BOOL]
    [IMAGE_MAP_MODS...]
    }
BITMAP_TYPE:
  exr | gif | hdr | iff | jpeg | pgm | png | ppm | sys | tga | tiff
GAMMA:
  Float_Value | srgb | bt709 | bt2020
IMAGE_MAP_MODS:
  map_type Type | once | interpolate Type | use_alpha
ITEM_MAP_BODY:
  ITEM_MAP_IDENTIFIER | ITEM_MAP_ENTRY...
ITEM_MAP_ENTRY:
  [ GRAY_VALUE  ITEM_MAP_ENTRY... ]
</pre>

<p>It is also useful for creating texture <em>masks</em> as in the following:</p>
<pre>
texture {
  image_pattern { tga &quot;image.tga&quot; use_alpha }
  texture_map {
    [0 Mytex]
    [1 pigment { transmit 1 }]
    }
  }
</pre>

<p class="Note"><strong>Note:</strong> This pattern uses an image to get the gray values. If you want exactly the same possibilities but need to get gray values from a pigment, you can use the <a href="r3_6.html#r3_6_1_1_3">pigment_pattern</a>.</p>
<p>While POV-Ray will normally interpret the image pattern input file as a container of linear data irregardless of file type, this can be overridden for any individual image pattern input file by specifying <code>gamma</code> GAMMA immediately after the file name. For example:</p>
<pre>
image_pattern {
  jpeg "foobar.jpg" gamma 1.8
  }
</pre>
<p>This will cause POV-Ray to perform gamma adjustment or decoding on the input file data before building the image pattern. Alternatively to a numerical value, <code>srgb</code> may be specified to denote that the file format is pre-corrected or encoded using the <em>sRGB transfer function</em> instead of a power-law gamma function. <font class="New">New</font> in version 3.8, other valid special values are <code>bt709</code> and <code>bt2020</code>, denoting that the file is encoded or pre-corrected using the ITU-R BT.709 or BT.2020 transfer function, respectively. See section <a href="t2_3.html#t2_3_4">Gamma Handling</a> for more details.</p>


<table class="centered" width="420px" cellpadding="0" cellspacing="10">
<tr>
  <td><img class="centered" width="200px" src="images/1/14/RefImgImagePigment.png"></td>
  <td><img class="centered" width="200px" src="images/9/9d/RefImgImageNormal.png"></td>
</tr>
<tr>
  <td colspan="2"><p class="caption">image pattern used as pigment and normal respectively</p></td>
</tr>
</table></div>

<a name="r3_6_2_4_3"></a>
<div class="content-level-h5" contains="Potential Pattern" id="r3_6_2_4_3">
<h5>3.6.2.4.3 Potential Pattern</h5>
<p><font class="New">New</font> in version 3.8 a <code>potential</code> pattern has been added to define a pattern based on the <em>potential</em> field of a <code>blob</code> or <code>isosurface</code> object.</p>
<p>Using <code>pigment</code> in the following example, the syntax for the new pattern is as follows:</p>

<pre>
pigment {
  potential { BLOB | ISOSURFACE }
  [threshold BOOL]
  [PIGMENT_MODIFIERS...]
  }
</pre>

<p>With <code>threshold on</code> the pattern will take the <code>blob</code> or <code>isosurface</code> object's <em>potential minus the threshold</em>; otherwise it will take the <em>raw potential</em> which is the default behavior.</p>

<p>The <em>isosurface's</em> container has no effect on the <code>potential</code> pattern.</p>

<p>The pattern value is <em>not</em> bound to the [0..1] range, unless you explicitly specify a <em>wave type</em>. See also: <a href="r3_6.html#r3_6_2_1_29">Waves Pattern</a>.</p>

<p>Applying the <code>inverse</code> keyword to the object will cause the pattern to be reversed as well; so, when using <code>threshold on</code> for blobs, positive pattern values always indicate inside, while negative values indicate outside.</p>

<p class="Note"><strong>Note:</strong> By default this is the opposite for isosurfaces, so for easier use, the new pattern is therefore accompanied by an extension to the <code>isosurface</code> syntax as shown below:</p>

<pre>
isosurface {
  ...
  polarity FLOAT
  ...
  }
</pre>

<p>Setting <code>polarity</code> to a positive value causes above-threshold values to be interpreted as inside, and below-threshold values as outside, rather than the other way round</p>

<p>See also: <a href="r3_5.html#r3_5_1_1_1">Blob</a> and <a href="r3_5.html#r3_5_1_1_6">Isosurface</a></p></div>

<a name="r3_6_2_4_4"></a>
<div class="content-level-h5" contains="User Defined Pattern" id="r3_6_2_4_4">
<h5>3.6.2.4.4 User Defined Pattern</h5>
<p><font class="New">New</font> in version 3.8 a special pigment pattern <code>user_defined</code> has been added to define the pigment color directly in terms of a set of functions.</p>

<p>The syntax is a follows:</p>

<pre>
pigment {
  user_defined {
    function { RED_FUNCTION },
    function { GREEN_FUNCTION },
    function { BLUE_FUNCTION },
    function { FILTER_FUNCTION },
    function { TRANSMIT_FUNCTION }
    }
  }
</pre>

<p>Each function is <em>optional</em>, in which case the corresponding component is set to 0. For example, the following sets the color to <code>rgbft &lt;x,y,0,0,z&gt;</code>:</p>

<pre>
pigment {
  user_defined {
    function { x },
    function { y },
    ,,
    function { z }
    }
  }
</pre>

<p>The pattern is similar to <code>image_map</code> in that it directly specifies <em>colors</em> rather than using a <code><a href="r3_6.html#r3_6_1_1_2">Color Map</a></code> or <code><a href="r3_6.html#r3_6_1_1_3">Pigment Map</a></code>.</div>

<a name="r3_6_2_5"></a>
<div class="content-level-h4" contains="Pattern Modifiers" id="r3_6_2_5">
<h4>3.6.2.5 Pattern Modifiers</h4>
<p>Pattern modifiers are statements or parameters which modify how a pattern
is evaluated or tells what to do with the pattern. The complete syntax
is:</p>
<pre>
PATTERN_MODIFIER:
  BLEND_MAP_MODIFIER | AGATE_MODIFIER | DENSITY_FILE_MODIFIER |
  QUILTED_MODIFIER | BRICK_MODIFIER | SLOPE_MODIFIER |
  noise_generator Number| turbulence &lt;Amount&gt; |
  octaves Count | omega Amount | lambda Amount |
  warp { [WARP_ITEMS...] } | TRANSFORMATION
BLEND_MAP_MODIFIER:
  frequency Amount | phase Amount | ramp_wave | triangle_wave |
  sine_wave | scallop_wave | cubic_wave | poly_wave [Exponent]
AGATE_MODIFIER:
  agate_turb Value
BRICK_MODIFIER:
  brick_size Size | mortar Size 
DENSITY_FILE_MODIFIER:
  interpolate Type
SLOPE_MODIFIERS:
  &lt;Altitude&gt; 
  &lt;Lo_slope,Hi_slope&gt;
  &lt;Lo_alt,Hi_alt&gt;
QUILTED_MODIFIER:
  control0 Value | control1 Value
PIGMENT_MODIFIER:
  PATTERN_MODIFIER | COLOR_LIST | PIGMENT_LIST |
  color_map { COLOR_MAP_BODY } | colour_map { COLOR_MAP_BODY } |
  pigment_map{ PIGMENT_MAP_BODY } | quick_color COLOR |
  quick_colour COLOR
COLOR NORMAL_MODIFIER:
  PATTERN_MODIFIER | NORMAL_LIST |
  normal_map { NORMAL_MAP_BODY } | slope_map{ SLOPE_MAP_BODY } |
  bump_size Amount
TEXTURE_PATTERN_MODIFIER:
  PATTERN_MODIFIER | TEXTURE_LIST |
  texture_map{ TEXTURE_MAP_BODY }
DENSITY_MODIFIER:
  PATTERN_MODIFIER | DENSITY_LIST | COLOR_LIST |
  color_map { COLOR_MAP_BODY } | colour_map { COLOR_MAP_BODY } |
  density_map { DENSITY_MAP_BODY }
</pre>

<p>Default values for pattern modifiers:</p>
<pre>
dist_exp        : 0
falloff         : 2.0
frequency       : 1.0
lambda          : 2.0
major_radius    : 1
map_type        : 0
noise_generator : 2
octaves         : 6
omega           : 0.5  
orientation     : &lt;0,0,1&gt;
phase           : 0.0
poly_wave       : 1.0
strength        : 1.0
turbulence      : &lt;0,0,0&gt;
</pre>

<p>The modifiers <em>PIGMENT_LIST</em>, <code>quick_color</code>, and <code>pigment_map</code> apply only to pigments. See the section <a href="r3_6.html#r3_6_1_1">Pigment</a> for details on these pigment-specific pattern modifiers.</p>
<p>The modifiers <em>COLOR_LIST</em> and <code>color_map</code> apply only to pigments and densities. See the sections <a href="r3_6.html#r3_6_1_1">Pigment</a> and <a href="r3_6.html#r3_6_2_1_8">Density</a> for details on these pigment-specific pattern modifiers.</p>
<p>The modifiers <em> NORMAL_LIST</em>, <code>bump_size</code>, <code>slope_map</code> and <code>normal_map</code> apply only to normals. See the section <a href="r3_6.html#r3_6_1_2">Normal</a> for details on these normal-specific pattern
modifiers.</p>
<p>The <em>TEXTURE_LIST</em> and <code>texture_map</code> modifiers can only be used with patterned textures. See the section <a href="r3_6.html#r3_6_1_5_1">Texture Maps</a> for details.</p>
<p>The <em>DENSITY_LIST</em> and <code>density_map</code> modifiers only work with <code>media{density{..}}</code> statements. See the section <a href="r3_6.html#r3_6_2_1_8">Density</a> for details.</p>

<p>The <code>agate_turb</code> modifier can only be used with the <code>agate</code> pattern. See the section <a href="r3_6.html#r3_6_2_1_1">Agate</a> for details.</p>
<p>The <code>brick_size</code> and <code>mortar</code> modifiers can only be used with the <code>brick</code> pattern. See the section <a href="r3_6.html#r3_6_2_1_4">Brick</a> for details.</p>
<p>The <code>control0</code> and <code>control1</code> modifiers can only be used with the <code>quilted</code> pattern. See the section <a href="r3_6.html#r3_6_2_1_21">Quilted</a> for details.</p>
<p>The <code>interpolate</code> modifier can only be used with the <code>density_file</code> pattern. See the section <a href="r3_6.html#r3_6_2_1_8">Density File</a> for details.</p>
<p>The general purpose pattern modifiers in the following sections can be used with <code>pigment</code>, <code>normal</code>, <code>texture</code>, or <code>density</code> patterns.</p>

</div>
<a name="r3_6_2_5_1"></a>
<div class="content-level-h5" contains="Transforming Patterns" id="r3_6_2_5_1">
<h5>3.6.2.5.1 Transforming Patterns</h5>
<p>The most common pattern modifiers are the transformation modifiers <code>translate</code>, <code>rotate</code>, <code>scale</code>, <code>transform</code>, and <code>matrix</code>. For details on these commands see the section <a href="r3_3.html#r3_3_1_12">Transformations</a>.</p>
<p>These modifiers may be placed inside pigment, normal, texture, and density
statements to change the position, size and orientation of the patterns.</p>
<p>Transformations are performed in the order in which you specify them.
However in general the order of transformations relative to other pattern
modifiers such as <code>turbulence</code>, <code>color_map</code> and other
maps is not important. For example scaling before or after turbulence makes
no difference. The turbulence is done first, then the scaling regardless of
which is specified first. However the order in which transformations are
performed relative to <code>warp</code> statements is important. See the section <a href="r3_6.html#r3_6_2_5_5">Warp</a> for details.</p>

</div>
<a name="r3_6_2_5_2"></a>
<div class="content-level-h5" contains="Frequency and Phase" id="r3_6_2_5_2">
<h5>3.6.2.5.2 Frequency and Phase</h5>
<p>The <code>frequency</code> and <code>phase</code> modifiers act as a type
of scale and translate modifiers for various blend maps. They only have
effect when blend maps are used. Blend maps are <code>color_map</code>,
<code>pigment_map</code>, <code>normal_map</code>, <code>slope_map</code>,
<code>density_map</code>, and <code>texture_map</code>. This discussion uses
a color map as an example but the same principles apply to the other blend
map types.</p>
<p>The <code>frequency</code> keyword adjusts the number of times that a color
map repeats over one cycle of a pattern. For example <code>gradient</code> covers color map values 0 to 1 over the range from x=0 to x=1. By adding <code>frequency 2.0</code> the color map repeats twice over that same range. The same effect can be achieved using <code>scale 0.5*x</code> so the frequency keyword is not that useful for patterns like gradient.</p>
<p>However the radial pattern wraps the color map around the +y-axis once. If
you wanted two copies of the map (or 3 or 10 or 100) you would have to build
a bigger map. Adding <code>frequency 2.0</code> causes the color map to be
used twice per revolution. Try this:</p>
<pre>
pigment {
  radial
  color_map{
    [0.5 color Red]
    [0.5 color White]
    }
  frequency 6
  }
</pre>

<p>The result is six sets of red and white radial stripes evenly spaced
around the object.</p>
<p>The float after <code>frequency</code> can be any value. Values greater than
1.0 causes more than one copy of the map to be used. Values from 0.0 to 1.0
cause a fraction of the map to be used. Negative values reverses the map.</p>
<p>The <code>phase</code> value causes the map entries to be shifted so that the map starts and ends at a different place. In the example above if you render successive frames at <code>phase 0</code> then <code>phase 0.1</code>, <code>phase 0.2</code>, etc. you could create an animation that rotates the stripes. The same effect can be easily achieved by rotating the <code>radial</code> pigment using <code>rotate y*Angle</code> but there are other uses where phase can be handy.</p>
<p>Sometimes you create a great looking gradient or wood color map but you want
the grain slightly adjusted in or out. You could re-order the color map
entries but that is a pain. A phase adjustment will shift everything but
keep the same scale. Try animating a <code>mandel</code> pigment for a color
palette rotation effect.</p>
<p>These values work by applying the following formula</p>
<p><em> New_Value = fmod ( Old_Value * Frequency + Phase, 1.0 ). </em></p>
<p>The <code>frequency</code> and <code>phase</code> modifiers have no effect on block patterns <code>checker</code>, <code>brick</code>, and <code>hexagon</code> nor do they effect <code>image_map</code>, <code>bump_map</code> or <code>material_map</code>. They also have no effect in normal statements when used with <code>bumps</code>, <code>dents</code>, <code>quilted</code> or <code>wrinkles</code> because these normal patterns cannot use <code>normal_map</code> or <code>slope_map</code>.</p>
<p>They can be used with normal patterns <code>ripples</code> and <code>waves</code> even though these two patterns cannot use <code>normal_map</code> or <code>slope_map</code> either. When used with <code>ripples</code> or <code>waves</code>, <code>frequency</code> adjusts the space between features and <code>phase</code> can be adjusted from 0.0 to 1.0 to cause the ripples or waves to move relative to their center for animating the features.</p>

</div>
<a name="r3_6_2_5_3"></a>
<div class="content-level-h5" contains="Waveforms" id="r3_6_2_5_3">
<h5>3.6.2.5.3 Waveforms</h5>
<p>POV-Ray allows you to apply various wave forms to the pattern function
before applying it to a blend map. Blend maps are <code>color_map</code>,
<code>pigment_map</code>, <code>normal_map</code>, <code>slope_map</code>,
<code>density_map</code>, and <code>texture_map</code>.</p>
<p>
Most of the patterns which use a blend map, use the entries in the map in
order from 0.0 to 1.0. The effect can most easily be seen when these patterns
are used as normal patterns with no maps. Patterns such as <code>
gradient</code> or <code>onion</code> generate a groove or slot that looks
like a ramp that drops off sharply. This is called a <code>ramp_wave</code>
wave type and it is the default wave type for most patterns. However the
<code>wood</code> and <code>marble</code> patterns use the map from 0.0 to
1.0 and then reverses it and runs it from 1.0 to 0.0. The result is a wave
form which slopes upwards to a peak, then slopes down again in a <code>
triangle_wave</code>. In earlier versions of POV-Ray there was no way to
change the wave types. You could simulate a triangle wave on a ramp wave
pattern by duplicating the map entries in reverse, however there was no way
to use a ramp wave on wood or marble.</p>
<p>
Now any pattern that takes a map can have the default wave type overridden.
For example:</p>
<pre>
pigment { wood color_map { MyMap } ramp_wave }
</pre>

<p>Also available are <code>sine_wave</code>, <code>scallop_wave</code>,
<code>cubic_wave</code> and <code>poly_wave</code> types. These types are of
most use in normal patterns as a type of built-in slope map. The <code>
sine_wave</code> takes the zig-zag of a ramp wave and turns it into a gentle
rolling wave with smooth transitions. The <code>scallop_wave</code> uses the
absolute value of the sine wave which looks like corduroy when scaled small
or like a stack of cylinders when scaled larger. The <code>cubic_wave</code>
is a gentle cubic curve from 0.0 to 1.0 with zero slope at the start and end.
The <code>poly_wave</code> is an exponential function. It is followed by an
optional float value which specifies exponent. For example <code>poly_wave
2</code> starts low and climbs rapidly at the end while <code>poly_wave
0.5</code> climbs rapidly at first and levels off at the end. If no float
value is specified, the default is 1.0 which produces a linear function
identical to <code>ramp_wave</code>.</p>
<p>
Although any of these wave types can be used for pigments, normals,
textures, or density the effect of many of the wave types are not as
noticeable on pigments, textures, or density as they are for normals.</p>
<p>
Wave type modifiers have no effect on block patterns <code>checker</code>,
<code>brick</code>, <code>object</code> and <code>hexagon</code> nor do they effect <code>
image_map</code>, <code>bump_map</code> or <code>material_map</code>. They
also have no effect in normal statements when used with <code>bumps</code>,
<code>dents</code>, <code>quilted</code>, <code>ripples</code>, <code>
waves</code>, or <code>wrinkles</code> because these normal patterns cannot
use <code>normal_map</code> or <code>slope_map</code>.</p>

</div>
<a name="r3_6_2_5_4"></a>
<div class="content-level-h5" contains="Noise Generators" id="r3_6_2_5_4">
<h5>3.6.2.5.4 Noise Generators</h5>
<p> There are three noise generators implemented. Changing the <code>noise_generator</code> will change 
the appearance of noise based patterns, like bozo and granite.</p>
<ul>
<li><code>noise_generator 1</code> the noise that was used in POV_Ray 3.1</li>
<li><code>noise_generator 2</code> <em>range corrected</em> version of the old noise, it does not show 
the plateaus seen with <code>noise_generator 1</code> </li>
<li><code>noise_generator 3</code> generates Perlin noise</li>
</ul>
<p>The default is <code>noise_generator 2</code></p>
<p class="Note"><strong>Note:</strong> The noise_generator can also be set in <code>global_settings</code></p></div>

<a name="r3_6_2_5_5"></a>
<div class="content-level-h5" contains="Warp" id="r3_6_2_5_5">
<h5>3.6.2.5.5 Warp</h5>

<p>The <code>warp</code> statement is a pattern modifier that is similar to
turbulence. Turbulence works by taking the pattern evaluation point and
pushing it about in a series of random steps. However warps push the point in
very well-defined, non-random, geometric ways. The <code>warp</code>
statement also overcomes some limitations of traditional turbulence and
transformations by giving the user more control over the order in which
turbulence, transformation and warp modifiers are applied to the pattern.</p>
<p>The turbulence warp provides an alternative way to
specify turbulence. The others modify the pattern in geometric ways.</p>
<p>
The syntax for using a <code>warp</code> statement is:</p>
<pre>
WARP:
  warp { WARP_ITEM }
WARP_ITEM:
  repeat &lt;Direction&gt; [REPEAT_ITEMS...] |
  black_hole &lt;Location&gt;, Radius [BLACK_HOLE_ITEMS...] | 
  turbulence &lt;Amount&gt; [TURB_ITEMS...]
  cylindrical  [ orientation VECTOR | dist_exp FLOAT ]
  spherical  [ orientation VECTOR | dist_exp FLOAT ]
  toroidal  [ orientation VECTOR | dist_exp FLOAT | major_radius FLOAT ]
  planar [ VECTOR , FLOAT ]
REPEAT_ITEMS:
  offset &lt;Amount&gt; | 
  flip &lt;Axis&gt;
BLACK_HOLE_ITEMS:
  strength Strength | falloff Amount | inverse |
  repeat &lt;Repeat&gt; | turbulence &lt;Amount&gt;
TURB_ITEMS:
  octaves Count | omega Amount | lambda Amount
</pre>

<p>You may have as many separate warp statements as you like in each pattern.
The placement of warp statements relative to other modifiers such as <code>
color_map</code> or <code>turbulence</code> is not important. However
placement of warp statements relative to each other and to transformations is
significant. Multiple warps and transformations are evaluated in the order in
which you specify them. For example if you translate, then warp or warp, then
translate, the results can be different.</p>

</div>
<a name="r3_6_2_5_5_1"></a>
<div class="content-level-h6" contains="Black Hole Warp" id="r3_6_2_5_5_1">
<h6>3.6.2.5.5.1 Black Hole Warp</h6>
<p>A <code>black_hole</code> warp is so named because of its similarity to
real black holes. Just like the real thing, you cannot actually see a black
hole. The only way to detect its presence is by the effect it has on things
that surround it.</p>
<p>
Take, for example, a wood grain. Using POV-Ray's normal turbulence and
other texture modifier functions, you can get a nice, random appearance to
the grain. But in its randomness it is regular - it is regularly random!
Adding a black hole allows you to create a localized disturbance in a wood
grain in either one or multiple locations. The black hole can have the effect
of either <em>sucking</em> the surrounding texture into itself (like the real
thing) or <em>pushing</em> it away. In the latter case, applied to a wood
grain, it would look to the viewer as if there were a knothole in the wood.
In this text we use a wood grain regularly as an example, because it is
ideally suitable to explaining black holes. However, black holes may in fact
be used with any texture or pattern. The effect that the black hole has on
the texture can be specified. By default, it <em>sucks</em> with the
strength calculated exponentially (inverse-square). You can change this if
you like.</p>
<p>
Black holes may be used anywhere a warp is permitted. The syntax is:</p>
<pre>
BLACK_HOLE_WARP:
  warp {
    black_hole &lt;Location&gt;, Radius
    [BLACK_HOLE_ITEMS...]
    }
BLACK_HOLE_ITEMS:
  strength Strength | falloff Amount | inverse | type Type | 
  repeat &lt;Repeat&gt; | turbulence &lt;Amount&gt;
</pre>

<p>The minimal requirement is the <code>black_hole</code> keyword followed by
a vector <em><code>&lt;Location&gt;</code></em> followed by a comma and a
float <em><code>Radius</code></em>. Black holes effect all points within the
spherical region around the location and within the radius. This is
optionally followed by any number of other keywords which control how the
texture is warped.</p>
<p>
The <code>falloff</code> keyword may be used with a float value to specify
the power by which the effect of the black hole falls off. The default is
two. The force of the black hole at any given point, before applying the
<code>strength</code> modifier, is as follows.</p>
<p>
First, convert the distance from the point to the center to a proportion (0
to 1) that the point is from the edge of the black hole. A point on the
perimeter of the black hole will be 0.0; a point at the center will be 1.0; a
point exactly halfway will be 0.5, and so forth. Mentally you can consider
this to be a closeness factor. A closeness of 1.0 is as close as you can get
to the center (i.e. at the center), a closeness of 0.0 is as far away as you
can get from the center and still be inside the black hole and a closeness of
0.5 means the point is exactly halfway between the two.</p>
<p>
Call this value c. Raise c to the power specified in <code>falloff</code>.
By default Falloff is 2, so this is c^2 or c squared. The resulting value is
the force of the black hole at that exact location and is used, after
applying the <code>strength</code> scaling factor as described below, to
determine how much the point is perturbed in space. For example, if c is 0.5
the force is 0.5^2 or 0.25. If c is 0.25 the force is 0.125. But if c is
exactly 1.0 the force is 1.0. Recall that as c gets smaller the point is
farther from the center of the black hole. Using the default power of 2, you
can see that as c reduces, the force reduces exponentially in an
inverse-square relationship. Put in plain English, it means that the force is
much stronger (by a power of two) towards the center than it is at the
outside.</p>
<p>
By increasing <code>falloff</code>, you can increase the magnitude of the
falloff. A large value will mean points towards the perimeter will hardly be
affected at all and points towards the center will be affected strongly. A
value of 1.0 for <code>falloff</code> will mean that the effect is linear. A
point that is exactly halfway to the center of the black hole will be
affected by a force of exactly 0.5. A value of <code>falloff</code> of less
than one but greater than zero means that as you get closer to the outside,
the force increases rather than decreases. This can have some uses but there
is a side effect. Recall that the effect of a black hole ceases outside its
perimeter. This means that points just within the perimeter will be affected
strongly and those just outside not at all. This would lead to a visible
border, shaped as a sphere. A value for <code>falloff</code> of 0 would mean
that the force would be 1.0 for all points within the black hole, since any
number larger 0 raised to the power of 0 is 1.0.</p>
<p>
The <code>strength</code> keyword may be specified with a float value to
give you a bit more control over how much a point is perturbed by the black
hole. Basically, the force of the black hole (as determined above) is
multiplied by the value of <code>strength</code>, which defaults to 1.0. If
you set strength to 0.5, for example, all points within the black hole will
be moved by only half as much as they would have been. If you set it to 2.0
they will be moved twice as much.</p>
<p>
There is a rider to the latter example, though - the movement is clipped to
a maximum of the original distance from the center. That is to say, a point
that is 0.75 units from the center may only be moved by a maximum of 0.75
units either towards the center or away from it, regardless of the value of
<code>strength</code>. The result of this clipping is that you will have an
exclusion area near the center of the black hole where all points whose final
force value exceeded or equaled 1.0 were moved by a fixed amount.</p>
<p>
If the <code>inverse</code> keyword is specified then the points <em>
pushed</em> away from the center instead of being pulled in.</p>
<p>
The <code>repeat</code> keyword followed by a vector, allows you to simulate
the effect of many black holes without having to explicitly declare them.
Repeat is a vector that tells POV-Ray to use this black hole at multiple
locations. Using <code>repeat</code> logically divides your scene up into
cubes, the first being located at &lt;0,0,0&gt; and going to <em><code>
&lt;Repeat&gt;</code></em>. Suppose your repeat vector was &lt;1,5,2&gt;. The
first cube would be from &lt;0,0,0&gt; to &lt; 1,5,2&gt;. This cube repeats,
so there would be one at &lt; -1,-5,-2&gt;, &lt;1,5,2&gt;, &lt;2,10,4&gt; and
so forth in all directions, ad infinitum.</p>
<p>
When you use <code>repeat</code>, the center of the black hole does not
specify an absolute location in your scene but an offset into each block. It
is only possible to use positive offsets. Negative values will produce
undefined results.</p>
<p>
Suppose your center was &lt;0.5,1,0.25&gt; and the repeat vector is
&lt;2,2,2&gt;. This gives us a block at &lt; 0,0,0&gt; and &lt;2,2,2&gt;,
etc. The centers of the black hole's for these blocks would be
&lt;0,0,0&gt; + &lt; 0.5,1.0,0.25&gt;, i. e. &lt;0.5,1.0,0.25&gt;, and &lt;
2,2,2&gt; + &lt;0.5,1.0,0.25&gt;, i. e. &lt; 2,5,3.0,2.25&gt;.</p>
<p>
Due to the way repeats are calculated internally, there is a restriction on
the values you specify for the repeat vector. Basically, each black hole must
be totally enclosed within each block (or cube), with no part crossing into a
neighboring one. This means that, for each of the x, y and z dimensions, the
offset of the center may not be less than the radius, and the repeat value
for that dimension must be &gt;=the center plus the radius since any other
values would allow the black hole to cross a boundary. Put another way, for
each of x, y and z</p>

<p> Radius &lt;= Offset or Center &lt;= Repeat - Radius.</p>

<p>If the repeat vector in any dimension is too small to fit this criteria,
it will be increased and a warning message issued. If the center is less than
the radius it will also be moved but no message will be issued.</p>
<p>
Note that none of the above should be read to mean that you cannot
overlap black holes. You most certainly can and in fact this can produce some
most useful effects. The restriction only applies to elements of the <code>
same</code> black hole which is repeating. You can declare a second black
hole that also repeats and its elements can quite happily overlap the first
and causing the appropriate interactions. It is legal for the repeat value
for any dimension to be 0, meaning that POV-Ray will not repeat the black
hole in that direction.</p>
<p>
The <code>turbulence</code> can only be used in a black hole with <code>
repeat</code>. It allows an element of randomness to be inserted into the way
the black holes repeat, to cause a more natural look. A good example would be
an array of knotholes in wood - it would look rather artificial if each
knothole were an exact distance from the previous.</p>
<p>
The <code>turbulence</code> vector is a measurement that is added to each
individual black hole in an array, after each axis of the vector is multiplied
by a different random amount ranging from 0 to 1. The resulting actual
position of the black hole's center for that particular repeat element is
random (but consistent, so renders will be repeatable) and somewhere within
the above coordinates. There is a rider on the use of turbulence, which
basically is the same as that of the repeat vector. You cannot specify a
value which would cause a black hole to potentially cross outside of its
particular block.</p>
<p>
In summary: For each of x, y and z the offset of the center must be
&gt;=radius and the value of the repeat must be &gt;= center + radius +
turbulence. The exception being that repeat may be 0 for any dimension, which
means do not repeat in that direction.</p>
<p>
Some examples are given by</p>
<pre>
warp {
  black_hole &lt;0, 0, 0&gt;, 0.5
  }

warp {
  black_hole &lt;0.15, 0.125, 0&gt;, 0.5
  falloff 7
  strength 1.0
  repeat &lt;1.25, 1.25, 0&gt;
  turbulence &lt;0.25, 0.25, 0&gt;
  inverse
  }

warp {
  black_hole &lt;0, 0, 0&gt;, 1.0
  falloff 2
  strength 2
  inverse
  }
</pre>

</div>
<a name="r3_6_2_5_5_2"></a>
<div class="content-level-h6" contains="Repeat Warp" id="r3_6_2_5_5_2">
<h6>3.6.2.5.5.2 Repeat Warp</h6>
<p>The <code>repeat</code> warp causes a section of the pattern to be
repeated over and over. It takes a slice out of the pattern and makes
multiple copies of it side-by-side. The warp has many uses but was originally
designed to make it easy to model wood veneer textures. Veneer is made by
taking very thin slices from a log and placing them side-by-side on some
other backing material. You see side-by-side nearly identical ring patterns
but each will be a slice perhaps 1/32th of an inch deeper.</p>
<p>
The syntax for a repeat warp is</p>
<pre>
REPEAT_WARP:
  warp { repeat &lt;Direction&gt; [REPEAT_ITEMS...] }
REPEAT_ITEMS:
  offset &lt;Amount&gt; | flip &lt;Axis&gt;
</pre>

<p>The <code>repeat</code> vector specifies the direction in which the
pattern repeats and the width of the repeated area. This vector must lie
entirely along an axis. In other words, two of its three components must be
0. For example</p>
<pre>
pigment {
  wood
  warp { repeat 2*x }
  }
</pre>

<p>which means that from x=0 to x=2 you get whatever the pattern usually is.
But from x=2 to x=4 you get the same thing exactly shifted two units over in
the x-direction. To evaluate it you simply take the x-coordinate modulo 2.
Unfortunately you get exact duplicates which is not very realistic. The
optional <code>offset</code> vector tells how much to translate the pattern
each time it repeats. For example</p>
<pre>
pigment {
  wood
  warp {repeat x*2  offset z*0.05}
  }
</pre>

<p>means that we slice the first copy from x=0 to x=2 at z=0 but at x=2 to
x=4 we offset to z=0.05. In the 4 to 6 interval we slice at z=0.10. At the
n-th copy we slice at 0.05 n z. Thus each copy is slightly different. There
are no restrictions on the offset vector.</p>

<p>Finally the <code>flip</code> vector causes the pattern to be flipped or
mirrored every other copy of the pattern. The first copy of the pattern in
the positive direction from the axis is not flipped. The next farther is, the
next is not, etc. The flip vector is a three component x, y, z vector but
each component is treated as a boolean value that tells if you should or
should not flip along a given axis. For example</p>
<pre>
pigment {
  wood
  warp {repeat 2*x  flip &lt;1,1,0&gt;}
  }
</pre>

<p>means that every other copy of the pattern will be mirrored about the x-
and y- axis but not the z-axis. A non-zero value means flip and zero means do
not flip about that axis. The magnitude of the values in the flip vector
does not matter.</p>

</div>
<a name="r3_6_2_5_5_3"></a>
<div class="content-level-h6" contains="Turbulence Warp" id="r3_6_2_5_5_3">
<h6>3.6.2.5.5.3 Turbulence Warp</h6>
<p>Inside the <code>warp</code> statement, the keyword <code>turbulence</code> followed by a float or vector may be
used to stir up any <code>pigment</code>, <code>normal</code> or <code>density</code>. A number of
optional parameters may be used with turbulence to control how it is
computed. The syntax is:</p>
<pre>
TURBULENCE_ITEM:
  turbulence &lt;Amount&gt; | octaves Count | omega Amount | lambda Amount
</pre>

<p>Typical turbulence values range from the default 0.0, which is no
turbulence, to 1.0 or more, which is very turbulent. If a vector is specified
different amounts of turbulence are applied in the x-, y- and z-direction.
For example</p>
<pre>
turbulence &lt;1.0, 0.6, 0.1&gt;
</pre>

<p>has much turbulence in the x-direction, a moderate amount in the
y-direction and a small amount in the z-direction.</p>
<p>
Turbulence uses a random noise function called <em>DNoise</em>. This is
similar to the noise used in the <code>bozo</code> pattern except that
instead of giving a single value it gives a direction. You can think of it as
the direction that the wind is blowing at that spot. Points close together
generate almost the same value but points far apart are randomly
different.</p>
<p>
Turbulence uses <em>DNoise</em> to push a point around in several steps
called <code>octaves</code>. We locate the point we want to evaluate, then
push it around a bit using turbulence to get to a different point then look
up the color or pattern of the new point.</p>
<p>
It says in effect <em>Do not give me the color at this spot...
take a few random steps in different directions and give me that
color</em>. Each step is typically half as long as the one before. For
example:</p>

<table class="centered" width="660x" cellpadding="0" cellspacing="10">
<tr>
  <td>
    <p>The magnitude of these steps is controlled by the turbulence value. There are three additional parameters which control how turbulence is computed. They are <code>octaves</code>, <code>lambda</code> and <code>omega</code>. Each is optional, each is followed by a single float value, and each has no effect when there is no turbulence.</p>
  </td>
  <td>
    <img class="right" width="320px" src="images/5/53/RefImgTurbrand.png">
  </td>
</tr>
<tr>
  <td></td>
  <td>
    <p class="caption">Turbulence random walk.</p>
  </td>
</tr>
</table>

</div>
<a name="r3_6_2_5_5_4"></a>
<div class="content-level-h6" contains="Octaves" id="r3_6_2_5_5_4">
<h6>3.6.2.5.5.4 Octaves</h6>
<p>The <code>octaves</code> keyword may be followed by an integer value to
control the number of steps of turbulence that are computed. Legal values
range from 1 to &lt;10. The default value of 6 is a fairly high value; you
will not see much change by setting it to a higher value because the extra
steps are too small. Float values are truncated to integer. Smaller numbers
of octaves give a gentler, wavy turbulence and computes faster. Higher
octaves create more jagged or fuzzy turbulence and takes longer to
compute.</p>

</div>
<a name="r3_6_2_5_5_5"></a>
<div class="content-level-h6" contains="Lambda" id="r3_6_2_5_5_5">
<h6>3.6.2.5.5.5 Lambda</h6>
<p>The <code>lambda</code> parameter controls how statistically different the
random move of an octave is compared to its previous octave. The default
value is 2.0 which is quite random. Values close to lambda 1.0 will
straighten out the randomness of the path in the diagram above. The zig-zag
steps in the calculation are in nearly the same direction. Higher values can
look more <em>swirly</em> under some circumstances.</p>

</div>
<a name="r3_6_2_5_5_6"></a>
<div class="content-level-h6" contains="Omega" id="r3_6_2_5_5_6">
<h6>3.6.2.5.5.6 Omega</h6>
<p>The <code>omega</code> value controls how large each successive octave
step is compared to the previous value. Each successive octave of turbulence
is multiplied by the omega value. The default <code>omega 0.5</code> means
that each octave is 1/2 the size of the previous one. Higher omega values
mean that 2nd, 3rd, 4th and up octaves contribute more turbulence giving a
sharper, <em>crinkly</em> look while smaller omegas give a fuzzy kind of
turbulence that gets blurry in places.</p>

</div>
<a name="r3_6_2_5_5_7"></a>
<div class="content-level-h6" contains="Mapping using warps" id="r3_6_2_5_5_7">
<h6>3.6.2.5.5.7 Mapping using warps</h6>
<p>With the <code>cylindrical, spherical</code> and <code>toroidal</code> warps you can wrap checkers, 
bricks and other patterns around cylinders, spheres, tori and other objects. In essence, these 
warps use the same mapping as the image maps use.</p>

<p>The syntax is as follows:</p>

<pre>
CYLINDRICAL_WARP:
  warp { cylindrical [CYLINDRICAL_ITEMS...]}
CYLINDRICAL_ITEMS:  
  orientation VECTOR | dist_exp FLOAT
SPHERICAL_WARP:
  warp { spherical [SPHERICAL_ITEMS...]}
SPHERICAL_ITEMS:  
  orientation VECTOR | dist_exp FLOAT
TOROIDAL_WARP:
  warp { toroidal [TOROIDAL_ITEMS...]}
TOROIDAL_ITEMS:  
  orientation VECTOR | dist_exp FLOAT | major_radius FLOAT
PLANAR_WARP:
  warp { planar [ VECTOR , FLOAT ]}
CUBIC_WARP:
  warp { cubic }
</pre>

<p>These defaults are in affect:</p>

<pre>
orientation &lt;0,0,1&gt;
dist_exp 0
major_radius 1
</pre>

<p>Although these warps do 3D mapping, some concession had to be made on depth.</p>
<p>The distance exponent is controlled by using the <code>dist_exp</code> keyword. When using the default value of 0, imagine a box from &lt;0,0&gt; to &lt;1,1&gt; stretching to infinity along the orientation vector.</p>

<p>The <code>distance</code> keyword is evaluated as follows:</p>
<ul>
  <li><code>sphere</code>: distance from origin</li>
  <li><code>cylinder</code>: distance from y-axis</li>
  <li><code>torus</code>: distance from major radius</li>
</ul>

<p>The <code>planar</code> warp was made to make a pattern act like an image_map, of infinite size and can be useful in combination with other mapping-warps. By default the pigment in the XY-plane is extruded along 
the Z-axis. The pigment can be taken from an other plane, by specifying the optional vector (normal of the plane) and float (distance along the normal). The result, again, is extruded along the Z-axis.</p>

<p>The <code>cubic</code> warp  requires no parameters, and maps an area in the x-y plane between &lt;0,0&gt; and &lt;1,1&gt; around the origin in the same way as uv-mapping an origin-centered cube-shaped box would. The <code>cubic</code> warp works with any object whereas the uv-mapping only works for the box object. See the section on <a href="r3_6.html#r3_6_1_7_1">box</a> uv-mapping for details.</p>

<p>The following code examples produced the images below:</p>

<pre>
torus {
  1, 0.5
  pigment {
    hexagon
    scale 0.1
    warp {
      toroidal 
      orientation y 
      dist_exp 1 
      major_radius 1
      }
    }
  }

sphere {
  0,1
  pigment {
    hexagon
    scale &lt;0.5/pi, 1, 1/pi&gt;*0.1
    warp {
      spherical
      orientation y 
      dist_exp 1 
      }
    }
  }

cylinder {
  -y, y, 1
  pigment {
    hexagon
    scale &lt;0.5/pi, 1, 1&gt;*0.1
    warp {
      cylindrical 
      orientation y 
      dist_exp 1 
      }
    }
  }
</pre>

<table class="matte" width="700px" cellpadding="0" cellspacing="10px">
<tr>
  <td>
    <img class="leftpanel" width="220px" src="images/4/46/RefImgWarpCylindrical1.png">
  </td>
  <td>
    <img class="centerpanel" width="220px" src="images/5/5a/RefImgWarpSphere1.png">
  </td>
  <td>
    <img class="rightpanel" width="220px" src="images/e/e7/RefImgWarpToroidal1.png">
  </td>
</tr>
<tr>
  <td>
    <p class="caption">cylindrical warp</p>
  </td>
  <td>
    <p class="caption">spherical warp</p>
  </td>
  <td>
    <p class="caption">toroidal warp</p>
  </td>
</tr>
</table>

</div>
<a name="r3_6_2_5_5_8"></a>
<div class="content-level-h6" contains="Turbulence versus Turbulence Warp" id="r3_6_2_5_5_8">
<h6>3.6.2.5.5.8 Turbulence versus Turbulence Warp</h6>
<p>The POV-Ray language contains an ambiguity and limitation on the way you
specify <code>turbulence</code> and transformations such as <code>
translate</code>, <code>rotate</code>, <code>scale</code>, <code>
matrix</code>, and <code>transform</code> transforms. Usually the turbulence
is done first. Then all translate, rotate, scale, matrix, and transform
operations are always done after turbulence regardless of the order in which
you specify them. For example this</p>
<pre>
pigment {
  wood
  scale .5
  turbulence .2
  }
</pre>

<p>works exactly the same as</p>
<pre>
pigment {
  wood
  turbulence .2
  scale .5
  }
</pre>

<p>The turbulence is always first. A better example of this limitation is
with uneven turbulence and rotations.</p>
<pre>
pigment {
  wood
  turbulence 0.5*y
  rotate z*60
  }
// as compared to
pigment {
  wood
  rotate z*60
  turbulence 0.5*y
  }
</pre>

<p>The results will be the same either way even though you would think it
should look different.</p>
<p>
We cannot change this basic behavior in POV-Ray now because lots of scenes
would potentially render differently if suddenly the order transformation vs.
turbulence mattered when in the past, it did not.</p>
<p>
However, by specifying our turbulence inside warp statement you tell POV-Ray
that the order in which turbulence, transformations and other warps are
applied is significant. Here is an example of a turbulence warp.</p>
<pre>
warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
</pre>

<p>The significance is that this</p>
<pre>
pigment {
  wood
  translate &lt;1,2,3&gt; rotate x*45 scale 2
  warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
  }
</pre>

<p>produces <em>different results</em> than this...</p>
<pre>
pigment {
  wood
  warp { turbulence &lt;0,1,1&gt; octaves 3 lambda 1.5 omega 0.3 }
  translate &lt;1,2,3&gt; rotate x*45 scale 2
  }
</pre>

<p>You may specify turbulence without using a warp statement. However you
cannot control the order in which they are evaluated unless you put them in a
warp.</p>
<p>
The evaluation rules are as follows:</p>
<ol>
<li>First any turbulence not inside a warp statement is applied regardless
of the order in which it appears relative to warps or transformations.</li>
<li>Next each warp statement, translate, rotate, scale or matrix one-by-one,
is applied in the order the user specifies. If you want turbulence done in a
specific order, you simply specify it inside a warp in the proper place.</li>
</ol>
</div>
<a name="r3_6_2_5_5_9"></a>
<div class="content-level-h6" contains="Turbulence" id="r3_6_2_5_5_9">
<h6>3.6.2.5.5.9 Turbulence</h6>
<p>The <code>turbulence</code> pattern modifier is still supported for compatibility
issues, but it is better nowadays to use the warp <code><a href="r3_6.html#r3_6_2_5_5_3">turbulence</a></code> feature,
which does not have turbulence's limitation in transformation order
(turbulence is always applied first, before any scale, translate or
rotate, whatever the order you specify). For a detailed discussion see
<a href="r3_6.html#r3_6_2_5_5_8">Turbulence versus Turbulence Warp</a></p>
<p> The old-style turbulence is handled slightly differently when used with the
agate, marble, spiral1, spiral2, and wood textures.</p></div>

<a name="r3_6_2_6"></a>
<div class="content-level-h4" contains="Image Map" id="r3_6_2_6">
<h4>3.6.2.6 Image Map</h4>
<p>When all else fails and none of the pigment pattern types meets your needs you can use an <code>image_map</code> to wrap a 2-D bit-mapped image around your 3-D objects.</p>

</div>
<a name="r3_6_2_6_1"></a>
<div class="content-level-h5" contains="Specifying an Image Map" id="r3_6_2_6_1">
<h5>3.6.2.6.1 Specifying an Image Map</h5>
<p>The syntax for an <code>image_map</code> is:</p>
<pre>
IMAGE_MAP:
 pigment {
   image_map {
     [BITMAP_TYPE] &quot;bitmap[.ext]&quot; [gamma GAMMA] [premultiplied BOOL]
     [IMAGE_MAP_MODS...]
     }
 [PIGMENT_MODFIERS...]
 }
IMAGE_MAP:
 pigment {
  image_map {
    FUNCTION_IMAGE
    }
 [PIGMENT_MODFIERS...]
 }
BITMAP_TYPE:
  exr | gif | hdr | iff | jpeg | pgm | png | ppm | sys | tga | tiff
GAMMA:
  Float_Value | srgb | bt709 | bt2020
IMAGE_MAP_MODS:
  map_type Type | once | interpolate Type | 
  filter Palette, Amount | filter all Amount |
  transmit Palette, Amount | transmit all Amount
FUNCTION_IMAGE:
  function I_WIDTH, I_HEIGHT { FUNCTION_IMAGE_BODY }
FUNCTION_IMAGE_BODY: 
  PIGMENT | FN_FLOAT | pattern { PATTERN [PATTERN_MODIFIERS] } 
</pre>

<p>After the optional <em>BITMAP_TYPE</em> keyword is a string expression containing the name of a bitmapped image file of the specified type. If the <em>BITMAP_TYPE</em> is not given, the same type is expected as the type set for output.</p>
<p>For example:</p>
<pre>
plane { -z,0 
  pigment {
    image_map {png &quot;Eggs.png&quot;}
    }
  }

plane { -z,0 
  pigment {
    image_map {&quot;Eggs&quot;}
    }
  }
</pre>
<p>The second method will look for, and use &quot;Eggs.png&quot; if the output file type is set to be <code>png</code> (Output_File_Type=N in INI-file or +FN on command line). It is particularly useful when the image used in the <code>image_map</code> is also rendered with POV-Ray.</p> 
<p>Several optional modifiers may follow the file specification. The modifiers are described below.</p>
<p class="Note"><strong>Note:</strong> Earlier versions of POV-Ray allowed some modifiers before the <em>BITMAP_TYPE</em> but that syntax is being phased out in favor of the syntax described here.</p>
<p class="Note"><strong>Note:</strong> The <code>sys</code> format is a system-specific format. See the <a href="r3_2.html#r3_2_4_1">Output File Type</a> section for more information.</p>
<p>Filenames specified in the <code>image_map</code> statements will be searched for in the home (current) directory first and, if not found, will then be searched for in directories specified by any <code>+L</code> or <code>Library_Path</code> options active. This would facilitate keeping all your image maps files in a separate subdirectory and giving a <code>Library_Path</code> option to specify where your library of image maps are. See <a href="r3_2.html#r3_2_5_3">Library Paths</a> for details.</p>
<p>By default, the image is mapped onto the x-y-plane. The image is <em>projected</em> onto the object as though there were a slide projector somewhere in the -z-direction. The image exactly fills the square area from (x,y) coordinates (0,0) to (1,1) regardless of the image's original size in pixels. If you would like to change this default you may translate, rotate or scale the pigment or texture to map it onto the object's surface as desired.</p>
<p>In the section <a href="r3_6.html#r3_6_2_2_2">Checker</a>, the <code>checker</code> pigment pattern is explained. The checks are described as solid cubes of colored clay from which objects are carved. With image maps you should imagine that each pixel is a long, thin, square, colored rod that extends parallel to the z-axis. The image is made from rows and columns of these rods bundled together and the object is then carved from the bundle.</p>
<p>If you would like to change this default orientation you may translate, rotate or scale the pigment or texture to map it onto the object's surface as desired.</p>
<p>The file name is optionally followed by one or more <em>BITMAP_MODIFIERS</em>. The <code> filter</code>, <code>filter all</code>, <code>transmit</code>, and <code> transmit all</code> modifiers are specific to image maps and are discussed in the following sections. An <code>image_map</code> may also use generic bitmap modifiers <code>map_type</code>,
<code>once</code> and <code> interpolate</code> described in Bitmap Modifiers</p>

</div>
<a name="r3_6_2_6_2"></a>
<div class="content-level-h5" contains="The Gamma Option" id="r3_6_2_6_2">
<h5>3.6.2.6.2 The Gamma Option</h5>
<p>The default gamma handling rules for any image input file can be overridden by specifying <code>gamma</code> GAMMA immediately after the file name. For example:</p>
<pre>
image_map {
  jpeg "foobar.jpg" gamma 1.8
  interpolate 2
  }
</pre>
<p>Alternatively to a numerical value, <code>srgb</code> may be specified to denote that the file is encoded or pre-corrected using the <em>sRGB transfer function</em> instead of a power-law gamma function. <font class="New">New</font> in version 3.8, other valid special values are <code>bt709</code> and <code>bt2020</code>, denoting that the file is encoded or pre-corrected using the ITU-R BT.709 or BT.2020 transfer function, respectively.</p>
<p>
See section <a href="t2_3.html#t2_3_4">Gamma Handling</a> for more information on gamma.</p>

</div>
<a name="r3_6_2_6_3"></a>
<div class="content-level-h5" contains="The Filter and Transmit Bitmap Modifiers" id="r3_6_2_6_3">
<h5>3.6.2.6.3 The Filter and Transmit Bitmap Modifiers</h5>
<p>To make all or part of an image map transparent you can specify <code>filter</code> and/or <code>transmit</code> values for the color palette/registers of PNG, GIF or IFF pictures (at least for the modes that use palettes). You can do this by adding the keyword <code>filter</code> or <code>transmit</code> following the filename. The keyword is followed by two numbers. The first number is the palette number value and the second is the amount of transparency. The values should be separated by a comma. For
example:</p>
<pre>
image_map {
  gif &quot;mypic.gif&quot;
  filter   0, 0.5 // Make color 0 50% filtered transparent
  filter   5, 1.0 // Make color 5 100% filtered transparent
  transmit 8, 0.3 // Make color 8 30% non-filtered transparent
  }
</pre>
<p>You can give the entire image a <code>filter</code> or <code>transmit</code> value using <code>filter all</code> <em><code>Amount</code></em> or <code>transmit all</code> <em><code>Amount</code></em>. For example:</p>
<pre>
image_map {
  gif &quot;stnglass.gif&quot;
  filter all 0.9
  }
</pre>

<p class="Note"><strong>Note:</strong> Early versions of POV-Ray used the keyword <code>alpha</code> to specify filtered transparency however that word is often used to describe non-filtered transparency. For this reason <code>alpha</code> is no longer
used.</p>
<p>See the section <a href="r3_3.html#r3_3_1_7">Color Expressions</a> for details on the differences between filtered and non-filtered transparency.</p>

</div>
<a name="r3_6_2_6_4"></a>
<div class="content-level-h5" contains="Using the Alpha Channel" id="r3_6_2_6_4">
<h5>3.6.2.6.4 Using the Alpha Channel</h5>
<p>Another way to specify non-filtered transmit transparency in an image map is by using the<em> alpha channel</em>. POV-Ray will automatically use the alpha channel for transmittance when one is stored in the image. PNG file format allows you to store a
different transparency for each color index in the PNG file, if desired. If your paint programs support this feature of PNG you can do the transparency editing within your paint program rather than specifying transmit values for each color in the POV file. Since some image formats can also store full alpha channel (transparency) information you can generate image maps that have transparency which is not dependent on the color of a pixel but rather its location in the image.</p>

<p>Although POV uses <code>transmit 0.0</code> to specify no transparency and <code> 1.0</code> to specify full transparency, the alpha data ranges from 0 to 255 in the opposite direction. Alpha data 0 means the same as <code>transmit 1.0</code> and alpha data 255 produces <code>transmit 0.0</code>.</p>
<p class="Note"><strong>Note:</strong> In version 3.7 alpha handling for image file output has changed. Effectively, the background <em>now requires</em> a <code>filter</code> or <code>transmit</code> value in order for alpha transparency to work properly.</p>

<p>Previous versions of POV-Ray always expected <em>straight</em> (aka <em>non-premultiplied</em>) alpha for file input, this has been changed in 3.7 on a per-file-format basis as follows:</p>
<ul>
<li> PNG will use straight alpha as per specification.</li>
<li> OpenEXR will use <em>associated</em> (ala <em>premultiplied</em>) alpha as per specifications.</li>
<li> <font class="New">New</font> as of version 3.8, TIFF will use straight or associated alpha as per the file header (3.7.0 expected associated alpha).</li>
<li> TGA and BMP 32-bit RGBA will use straight alpha, retaining file input compatibility for now, until a final decision has been made on these formats.</li>
</ul>

<p>Additionally the <code>premultiplied</code> parameter may be used to specify the input image alpha handling. This boolean parameter specifies whether the file is stored in premultiplied <em>associated</em> or non-premultiplied <em>straight</em> alpha format, overriding the file format specific default. This keyword has no effect on files without an alpha channel. Like the <code>gamma</code>, it <em>MUST</em> immediately follow the filename, though the order does not matter.</p>

<p class="Note"><strong>Note:</strong> The following mechanism has some limitations with colored highlights.</p>

<p>When generating non-premultiplied alpha output to a classic low-dynamic-range file format (e.g. PNG), transparency of particularly bright areas will now be reduced, in order to better preserve highlights on transparent objects.</p>

<p class="Note"><strong>Note:</strong> When using an input image in a <code>material_map</code>, <code>bump_map</code>, or <code>image_pattern</code> definition, the following conditions apply.</p>

<ul>
<li> For material maps, <em>no</em> alpha premultiplication handling is done whatsoever, instead the data as stored in the file is used.</li>
<li> For bump maps and image patterns, images with an alpha channel are treated as if they had a black background, unless the alpha channel itself is used.</li>
</ul>

<p class="Note"><strong>Note:</strong> See also <code><a href="r3_7.html#r3_7_1_2">background</a></code> and <code><a href="r3_7.html#r3_7_1_4">sky_sphere</a></code> for additional information.</p>

<p><font class="New">New</font> as of version 3.8, using <code>filter all</code> and <code>transmit all</code> on an image file with an alpha channel is now supported properly (requires <code>#version 3.8</code> or higher).</p></div>

<a name="r3_6_2_7"></a>
<div class="content-level-h4" contains="Bitmap Modifiers" id="r3_6_2_7">
<h4>3.6.2.7 Bitmap Modifiers</h4>

<p>A bitmap modifier is a modifier used inside an <code>image_map</code>,
<code>bump_map</code> or <code>material_map</code> to specify how the 2-D
bitmap is to be applied to the 3-D surface. Several bitmap modifiers apply to
specific kinds of maps and they are covered in the appropriate sections. The
bitmap modifiers discussed in the following sections are applicable to all
three types of bitmaps.</p>

</div>
<a name="r3_6_2_7_1"></a>
<div class="content-level-h5" contains="The once Option" id="r3_6_2_7_1">
<h5>3.6.2.7.1 The once Option</h5>
<p>Normally there are an infinite number of repeating image maps, bump maps
or material maps created over every unit square of the x-y-plane like tiles.
By adding the <code>once</code> keyword after a file name you can eliminate
all other copies of the map except the one at (0,0) to (1,1). In image maps,
areas outside this unit square are treated as fully transparent. In bump
maps, areas outside this unit square are left flat with no normal
modification. In material maps, areas outside this unit square are textured
with the first texture of the texture list.</p>
<p>
For example:</p>
<pre>
image_map {
  gif &quot;mypic.gif&quot;
  once
  }
</pre>

</div>
<a name="r3_6_2_7_2"></a>
<div class="content-level-h5" contains="The map_type Option" id="r3_6_2_7_2">
<h5>3.6.2.7.2 The map_type Option</h5>
<p>The default projection of the image onto the x-y-plane is called a <em>planar map type</em>. This option may be changed by adding the <code>map_type</code> keyword followed by an integer number specifying the way to wrap the image around the object.</p>

<ul>
  <li>A <code>map_type 0</code> gives the default planar mapping already described.</li>
  <li>A <code>map_type 1</code> gives a spherical mapping. It assumes that the object is a sphere of any size sitting at the origin. The y-axis is the north/south pole of the spherical mapping. The top and bottom edges of the image just touch the pole regardless of any scaling. The left edge of the image begins at the positive x-axis and wraps the image around the sphere from west to east in a -y-rotation. The image covers the sphere exactly once. The <code>once</code> keyword has no meaning for this mapping type.</li>
  <li>With <code>map_type 2</code> you get a cylindrical mapping. It assumes that a cylinder of any diameter lies along the y-axis. The image wraps around the cylinder just like the spherical map but the image remains one unit tall from y=0 to y=1. This band of color is repeated at all heights unless the <code>once</code> keyword is applied.</li>
  <li>A <code>map_type 5</code> gives a torus or donut shaped mapping. It assumes that a torus of major radius one sits at the origin in the x-z-plane. The image is wrapped around similar to spherical or cylindrical maps. However the top and bottom edges of the map wrap over and under the torus where they meet each other on the inner rim.</li>
  <li>Types 3 and 4 are still under development.</li>
  <li>A <code>map_type 7</code> <font class="New">New</font> in version 3.8 produces an <em>angular</em> shaped mapping to be used with light probes.</li>
</ul>
<p class="Note"><strong>Note:</strong> The <code>map_type</code> option may also be applied to <code>
bump_map</code> and <code>material_map</code> statements.</p>
<p>
For example:</p>
<pre>
sphere{&lt;0,0,0&gt;,1
  pigment{
    image_map {
      gif &quot;world.gif&quot;
      map_type 1
      }
    }
  }
</pre>

</div>
<a name="r3_6_2_7_3"></a>
<div class="content-level-h5" contains="The interpolate Option" id="r3_6_2_7_3">
<h5>3.6.2.7.3 The interpolate Option</h5>
<p>Adding the <code>interpolate</code> keyword can smooth the jagged look of a bitmap. When POV-Ray checks a color for an image map or a bump amount for a bump map, it often checks a point that is not directly on top of one pixel but sort of between several differently colored pixels. Interpolations return an in-between value so that the steps between the pixels in the map will look smoother.</p>
<p>
Although <code>interpolate</code> is legal in material maps, the color index is interpolated before the texture is chosen. It does not interpolate the final color as you might hope it would. In general, interpolation of material maps serves no useful purpose but this may be fixed in future versions.</p>
<p>
There are currently three types of interpolation: <code>interpolate 2</code> gives bilinear interpolation, <code>interpolate 3</code> gives bicubic,  and <code>interpolate 4</code> gives normalized distance.</p>
<p>For example:</p>
<pre>
image_map {
  gif &quot;mypic.gif&quot;
  interpolate 2
  }
</pre>

<p>The default is no interpolation. Normalized distance is the slowest, bilinear does a better job of picking the between color,  and arguably, bicubic interpolation is a slight improvement, however it is subject to over-sharpening at some color borders. Normally bilinear is used.</p>
<p>
If your map looks jagged, try using interpolation instead of going to a higher resolution image. The results can be very good.</p></div>

</div>

</div>
</body>
</html>
