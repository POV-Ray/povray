<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<!--  This file copyright Persistence of Vision Raytracer Pty. Ltd. 2009-2011  -->

<html lang="en">
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<title>Reference Section 8</title>
<link rel="StyleSheet" href="povray.css" type="text/css">
<link rel="shortcut icon" href="favicon.ico">

<!--  NOTE: In order to help users find information about POV-Ray using web      -->
<!--  search engines, we ask that you *not* let them index documentation         -->
<!--  mirrors because effectively, when searching, users will get hundreds of    -->
<!--  results containing the same information! For this reason, these meta tags  -->
<!--  below disable archiving of this page by search engines.                    -->

<meta name="robots" content="noarchive">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="expires" content="0">
</head>
<body>

<div class="Page">

<!-- NavPanel Begin -->
<div class="NavPanel">
<table class="NavTable">
<tr>
  <td class="FixedPanelHeading"><a title="3.8" href="#r3_8">Scene File Extras</a></td>
</tr>
<tr>
  <td><div class="divh2"><strong><a title="3.8.1" href="#r3_8_1">Include Files</a></strong></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.8.1.1" href="#r3_8_1_1">Main Files</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.1" href="#r3_8_1_1_1">Arrays.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.2" href="#r3_8_1_1_2">Chars.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.3" href="#r3_8_1_1_3">Colors.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.3.1" href="#r3_8_1_1_3_1">Predefined colors</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.3.2" href="#r3_8_1_1_3_2">Color macros</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.4" href="#r3_8_1_1_4">Colors ral.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.5" href="#r3_8_1_1_5">Consts.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.5.1" href="#r3_8_1_1_5_1">Vector constants</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.5.2" href="#r3_8_1_1_5_2">Map type constants</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.5.3" href="#r3_8_1_1_5_3">Interpolation type constants</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.5.4" href="#r3_8_1_1_5_4">Fog type constants</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.5.5" href="#r3_8_1_1_5_5">Focal blur hexgrid constants</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.5.6" href="#r3_8_1_1_5_6">IORs</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.5.7" href="#r3_8_1_1_5_7">Dispersion amounts</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.5.8" href="#r3_8_1_1_5_8">Scattering media type constants</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.6" href="#r3_8_1_1_6">Debug.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.7" href="#r3_8_1_1_7">Finish.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.8" href="#r3_8_1_1_8">Functions.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.1" href="#r3_8_1_1_8_1">Common Parameters</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.2" href="#r3_8_1_1_8_2">Cross Section Type</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.3" href="#r3_8_1_1_8_3">Field Strength</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.4" href="#r3_8_1_1_8_4">Field Limit</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.5" href="#r3_8_1_1_8_5">SOR Switch</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.6" href="#r3_8_1_1_8_6">SOR Offset</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.7" href="#r3_8_1_1_8_7">SOR Angle</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.8" href="#r3_8_1_1_8_8">Invert Isosurface</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.9" href="#r3_8_1_1_8_9">Internal Functions</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.10" href="#r3_8_1_1_8_10">Pre defined functions</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.8.11" href="#r3_8_1_1_8_11">Pattern functions</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.9" href="#r3_8_1_1_9">Glass.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.9.1" href="#r3_8_1_1_9_1">Glass colors (with transparency)</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.9.2" href="#r3_8_1_1_9_2">Glass colors (without transparency, for fade_color)</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.9.3" href="#r3_8_1_1_9_3">Glass finishes</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.9.4" href="#r3_8_1_1_9_4">Glass interiors</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.9.5" href="#r3_8_1_1_9_5">Glass interior macros</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.10" href="#r3_8_1_1_10">Golds.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.11" href="#r3_8_1_1_11">Logo.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.12" href="#r3_8_1_1_12">Makegrass.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.13" href="#r3_8_1_1_13">Math.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.13.1" href="#r3_8_1_1_13_1">Float functions and macros</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.13.2" href="#r3_8_1_1_13_2">Vector functions and macros</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.13.3" href="#r3_8_1_1_13_3">Vector Analysis</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.14" href="#r3_8_1_1_14">Meshmaker.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.15" href="#r3_8_1_1_15">Metals.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.16" href="#r3_8_1_1_16">Rad_def.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.17" href="#r3_8_1_1_17">Rand.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.17.1" href="#r3_8_1_1_17_1">Flat Distributions</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.17.2" href="#r3_8_1_1_17_2">Other Distributions</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.17.3" href="#r3_8_1_1_17_3">Continuous Symmetric Distributions</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.17.4" href="#r3_8_1_1_17_4">Continuous Skewed Distributions</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.17.5" href="#r3_8_1_1_17_5">Discrete Distributions </a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.18" href="#r3_8_1_1_18">Screen.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.19" href="#r3_8_1_1_19">Shapes.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.19.1" href="#r3_8_1_1_19_1">The HF Macros</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.20" href="#r3_8_1_1_20">Shapes2.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.21" href="#r3_8_1_1_21">Shapes3.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.22" href="#r3_8_1_1_22">Shapesq.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.23" href="#r3_8_1_1_23">Skies.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.24" href="#r3_8_1_1_24">Stars.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.25" href="#r3_8_1_1_25">Stones.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.26" href="#r3_8_1_1_26">Stdinc.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.27" href="#r3_8_1_1_27">Strings.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.28" href="#r3_8_1_1_28">Sunpos.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.29" href="#r3_8_1_1_29">Textures.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.29.1" href="#r3_8_1_1_29_1">Stones</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.29.2" href="#r3_8_1_1_29_2">Skies</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.29.3" href="#r3_8_1_1_29_3">Woods</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.29.4" href="#r3_8_1_1_29_4">Glass</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.29.5" href="#r3_8_1_1_29_5">Metals</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.29.6" href="#r3_8_1_1_29_6">Special textures</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.1.29.7" href="#r3_8_1_1_29_7">Texture and pattern macros</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.30" href="#r3_8_1_1_30">Transforms.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.31" href="#r3_8_1_1_31">Woods.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.1.32" href="#r3_8_1_1_32">Woodmaps.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.8.1.2" href="#r3_8_1_2">Old Files</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.2.1" href="#r3_8_1_2_1">Glass_old.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.2.1.1" href="#r3_8_1_2_1_1">Glass finishes</a></div></td>
</tr>
<tr>
  <td><div class="divh5"><a title="3.8.1.2.1.2" href="#r3_8_1_2_1_2">Glass textures</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.2.2" href="#r3_8_1_2_2">Shapes_old.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.2.3" href="#r3_8_1_2_3">Stage1.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.2.4" href="#r3_8_1_2_4">Stdcam.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.2.5" href="#r3_8_1_2_5">Stones1.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.2.6" href="#r3_8_1_2_6">Stones2.inc</a></div></td>
</tr>
<tr>
  <td><div class="divh3"><a title="3.8.1.3" href="#r3_8_1_3">Other Files</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.3.1" href="#r3_8_1_3_1">Font Files</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.3.2" href="#r3_8_1_3_2">Color Map Files</a></div></td>
</tr>
<tr>
  <td><div class="divh4"><a title="3.8.1.3.3" href="#r3_8_1_3_3">Image Files</a></div></td>
</tr>
<tr>
  <td><div class="divh1">&nbsp;</div></td>
</tr>
<tr>
  <td><div class="divh1">&nbsp;</div></td>
</tr>
</table>
</div>
<!-- NavPanel End -->

<div class="Content">
<table class="HeaderFooter" width="100%">
<tr>
  <td colspan=5 align="left" class="HeaderFooter">
    POV-Ray for Unix <strong class="HeaderFooter">version 3.8</strong>
  </td>
</tr>
<tr >
  <td colspan=5>
    <hr align="right" width="70%">
  </td>
</tr>
<tr>
  <td width="30%"></td>
  <td class="NavBar"><a href="index.html" title="The Front Door">Home</a></td>
  <td class="NavBar"><a href="u1_0.html" title="Unix Table of Contents">POV-Ray for Unix</a></td>
  <td class="NavBar"><a href="t2_0.html" title="Tutorial Table of Contents">POV-Ray Tutorial</a></td>
  <td class="NavBar"><a href="r3_0.html" title="Reference Table of Contents">POV-Ray Reference</a></td>
</tr>
</table>

<a name="r3_8"></a>
<div class="content-level-h2" contains="Scene File Extras" id="r3_8">
<h2>3.8 Scene File Extras</h2>
<p>Quick Links:</p>

<ul>
  <li><a href="r3_8.html#r3_8_1_1">Main Files</a></li>
  <li><a href="r3_8.html#r3_8_1_2">Old Files</a></li>
  <li><a href="r3_8.html#r3_8_1_3">Other Files</a></li>
</ul></div>

<a name="r3_8_1"></a>
<div class="content-level-h3" contains="Include Files" id="r3_8_1">
<h3>3.8.1 Include Files</h3>
<p>This section covers the <em>include files</em> that come with every distribution of POV-Ray. File location varies, so see your platform specific documentation for more information.</p></div>

<a name="r3_8_1_1"></a>
<div class="content-level-h4" contains="Main Files" id="r3_8_1_1">
<h4>3.8.1.1 Main Files</h4>
<p>The <em>main</em> include files in alphabetical order:</p></div>

<a name="r3_8_1_1_1"></a>
<div class="content-level-h5" contains="Arrays.inc" id="r3_8_1_1_1">
<h5>3.8.1.1.1 Arrays.inc</h5>

<p>This file contains macros for manipulating arrays.</p>

<p><code>ARRAYS_WriteDF3(Array, FileName, BitDepth)</code>: Write an array to a df3 file.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Array</code> = The array that contains the data.</li>
		<li><code>FileName</code> = The name of the file to be written.</li>
		<li><code>BitDepth</code> = The size of the binary word.</li>
	</ul>

<p class="Note"><strong>Note:</strong> See the <a href="r3_3.html#r3_3_2_3_4">#write</a> directive for more information.</p>

<p><code>Rand_Array_Item(Array, Stream)</code>: Randomly Picks an item from a 1D array.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Array</code> = The array from which to choose the item.</li>
		<li><code>Stream</code> = A random number stream.</li>
	</ul>

<p><code>Resize_Array(Array, NewSize)</code>: Resize a 1D array, retaining its contents.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Array</code> = The array to be resized.</li>
		<li><code>NewSize</code> = The desired new size of the array.</li>
	</ul>

<p><code>Reverse_Array(Array)</code>: Reverses the order of items in a 1D array.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Array</code> = The array to be reversed.</li>
	</ul>


<p><code>Sort_Compare(Array, IdxA, IdxB)</code>: This macro is used by the <code>Sort_Array()</code>
and <code>Sort_Partial_Array()</code> macros. The given macro works for 1D arrays of floats, but
you can redefine it in your scene file for more complex situations, arrays of vectors or
multidimensional arrays for example. Just make sure your macro returns true if the item at IdxA &lt;
the item at IdxB, and otherwise returns false.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Array</code> = The array containing the data being sorted.</li>
		<li><code>IdxA, IdxB</code> = The array offsets of the data elements being compared.</li>
	</ul>

<p><code>Sort_Swap_Data(Array, IdxA, IdxB)</code>: This macro is used by the <code>Sort_Array()</code>
and <code>Sort_Partial_Array()</code> macros. The given macro works for 1D arrays only,
but you can redefine it in your scene file to handle multidimensional arrays if needed.
The only requirement is that your macro swaps the data at IdxA with that at IdxB.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Array</code> = The array containing the data being sorted.</li>
		<li><code>IdxA, IdxB</code> = The array offsets of the data elements being swapped.</li>
	</ul>

<p><code>Sort_Array(Array)</code>: This macro sorts a 1D array of floats, though you can
redefine the <code>Sort_Compare()</code> and <code>Sort_Swap_Data()</code> macros to 
handle multidimensional arrays and other data types.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Array</code> = The array to be sorted.</li>
	</ul>

<p><code>Sort_Partial_Array(Array, FirstInd, LastInd)</code>: This macro is like
<code>Sort_Array()</code>, but sorts a specific range of an array instead of the whole array.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Array</code> = The array to be sorted.</li>
		<li><code>FirstInd, LastInd</code> = The start and end indices of the range being sorted.</li>
	</ul></div>

<a name="r3_8_1_1_2"></a>
<div class="content-level-h5" contains="Chars.inc" id="r3_8_1_1_2">
<h5>3.8.1.1.2 Chars.inc</h5>

<p>
This file includes 26 upper-case letter and other characters defined as objects.
The size of all characters is 4 * 5 * 1. The center of the bottom side of a character
face is set to the origin, so you may need to translate a character appropriately
before rotating it about the x or z axes.
</p>

<p>
Letters:<br>
<code>
char_A, char_B, char_C,<br>
char_D, char_E, char_F,<br>
char_G, char_H, char_I,<br>
char_J, char_K, char_L,<br>
char_M, char_N, char_O,<br>
char_P, char_Q, char_R,<br>
char_S, char_T, char_U,<br>
char_V, char_W, char_X,<br>
char_Y, char_Z<br>
</code>
</p>
<p>
Numerals:<br>
<code>
char_0, char_1,<br>
char_2, char_3,<br>
char_4, char_5,<br>
char_6, char_7,<br>
char_8, char_9<br>
</code>
</p>
<p>
Symbols:<br>
<code>
char_Dash, char_Plus, char_ExclPt,<br> 
char_Amps, char_Num,  char_Dol,<br>
char_Perc, char_Astr, char_Hat, <br>
char_LPar, char_RPar, char_AtSign,<br>
char_LSqu, char_RSqu<br>
</code>
</p>

<p>
Usage:</p>
<pre>
#include &quot;chars.inc&quot;
.
.
object {char_A ...}
</pre></div>

<a name="r3_8_1_1_3"></a>
<div class="content-level-h5" contains="Colors.inc" id="r3_8_1_1_3">
<h5>3.8.1.1.3 Colors.inc</h5>

<p>This file is mainly a list of predefined colors, but also has a few color
manipulation macros.</p>

</div>
<a name="r3_8_1_1_3_1"></a>
<div class="content-level-h6" contains="Predefined colors" id="r3_8_1_1_3_1">
<h6>3.8.1.1.3.1 Predefined colors</h6>
<p>This file contains 125 predefined colors that you can use in your scenes. Simply <code>#include</code> them in your scene file to use them:</p>
<pre>
  #include &quot;colors.inc&quot;
</pre>
<p>These basic colors:</p>
<ul>
  <li>Red</li>
  <li>Green</li>
  <li>Blue</li>
  <li>Yellow</li>
  <li>Cyan</li>
  <li>Magenta</li>
  <li>Clear</li>
  <li>White</li>
  <li>Black</li>
</ul>
<p>A series of <em>percentage</em> grays that are useful for fine-tuning lighting color values and for other areas where subtle variations of grays are needed, and a palette of over 100 additional color definitions are available. See the distribution file <code>~include/colors.inc</code> for more details.</p>

</div>
<a name="r3_8_1_1_3_2"></a>
<div class="content-level-h6" contains="Color macros" id="r3_8_1_1_3_2">
<h6>3.8.1.1.3.2 Color macros</h6>
<p>In POV-Ray all colors are handled in RGB color space with a component for
the amount of red, green and blue light. However, not everybody thinks this
is the most intuitive way to specify colors. For your convenience there are
macros included in colors.inc that converts between a few different types of
color spaces.</p>
<p>The supported color spaces:</p>
<ul>
<li><code>RGB</code> = &lt; Red, Green, Blue, Filter, Transmit &gt;</li>
<li><code>HSL</code> = &lt; Hue, Saturation, Lightness, Filter, Transmit &gt;</li>
<li><code>HSV</code> = &lt; Hue, Saturation, Value, Filter, Transmit &gt;</li>
<li><code>XYZ</code> = &lt; X, Y, Z, Filter, Transmit &gt; (CIEXYZ; <font class="New">New</font> in 3.8)</li>
<li><code>Lab</code> = &lt; Lightness L*, Chroma a*, Chroma b* &gt; (more accurately L*a*b*, CIELAB; <font class="New">New</font> in 3.8)</li>
</ul>
<p class="Note"><strong>Note:</strong> The Hue parameter is given in degrees.</p>

<p><code>CHSL2RGB(Color)</code>: Converts a color given in <code>HSL</code> space to one in <code>RGB</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>HSL</code> color to be converted.</li>
</ul>

<p><code>CRGB2HSL(Color)</code>: Converts a color given in <code>RGB</code> space to one in <code>HSL</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>RGB</code> color to be converted.</li>
</ul>

<p><code>CHSV2RGB(Color)</code>: Converts a color given in <code>HSV</code> space to one in <code>RGB</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>HSV</code> color to be converted.</li>
</ul>

<p><code>CRGB2HSV(Color)</code>: Converts a color given in <code>RGB</code> space to one in <code>HSV</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>RGB</code> color to be converted.</li>
</ul>

<p><code>CXYZ2RGB(Color)</code>: Converts a color given in <code>XYZ</code> space to one in <code>RGB</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>XYZ</code> color to be converted.</li>
</ul>

<p><code>CRGB2XYZ(Color)</code>: Converts a color given in <code>RGB</code> space to one in <code>XYZ</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>RGB</code> color to be converted.</li>
</ul>

<p><code>CLab2RGB(Color,WhiteXYZ)</code>: Converts a color given in <code>Lab</code> space to one in <code>RGB</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>Lab</code> color to be converted.</li>
<li><code>WhiteXYZ</code> = <code>XYZ</code> color of the chosen L*a*b* variant's reference white point.</li>
</ul>

<p><code>CRGB2Lab(Color,WhiteXYZ)</code>: Converts a color given in <code>RGB</code> space to one in <code>Lab</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>RGB</code> color to be converted.</li>
<li><code>WhiteXYZ</code> = <code>XYZ</code> color of the chosen L*a*b* variant's reference white point.</li>
</ul>

<p><code>CLab2RGB_D65(Color)</code>: Converts a color given in <code>Lab</code> space (using D65 as reference white point) to one in <code>RGB</code> space.</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>Lab</code> color to be converted.</li>
</ul>

<p><code>CRGB2Lab_D65(Color)</code>: Converts a color given in <code>RGB</code> space to one in <code>Lab</code> space (using D65 as reference white point).</p>
<p>Parameters:</p>
<ul>
<li><code>Color</code> = <code>RGB</code> color to be converted.</li>
</ul></div>

<a name="r3_8_1_1_4"></a>
<div class="content-level-h5" contains="Colors ral.inc" id="r3_8_1_1_4">
<h5>3.8.1.1.4 Colors ral.inc</h5>

<p>This file contains approximately 200 predefined colors from the German RAL institute's <em>RAL Classic</em> collection of standardized paint pigments that you can use in your scenes. Simply <code>#include</code> them in your scene file to use them:</p>
<pre>
  #include &quot;colors_ral.inc&quot;
</pre>
<p>The colors are named <code>RAL_nnnn</code>, where <code>nnnn</code> is the 4-digit numerical RAL Classic color code.</p></div>

<a name="r3_8_1_1_5"></a>
<div class="content-level-h5" contains="Consts.inc" id="r3_8_1_1_5">
<h5>3.8.1.1.5 Consts.inc</h5>
<p>This file defines a number of constants, including things such as mapping types and ior definitions.</p>

</div>
<a name="r3_8_1_1_5_1"></a>
<div class="content-level-h6" contains="Vector constants" id="r3_8_1_1_5_1">
<h6>3.8.1.1.5.1 Vector constants</h6>
<dl>
<dt><code>o</code> = &lt; 0, 0, 0&gt; (origin)</dt>
<dt><code>xy</code> = &lt; 1, 1, 0&gt;</dt>
<dt><code>yz</code> = &lt; 0, 1, 1&gt;</dt>
<dt><code>xz</code> = &lt; 1, 0, 1&gt;</dt>
</dl>

</div>
<a name="r3_8_1_1_5_2"></a>
<div class="content-level-h6" contains="Map type constants" id="r3_8_1_1_5_2">
<h6>3.8.1.1.5.2 Map type constants</h6>
<dl>
<dt><code>Plane_Map</code> = 0</dt>
<dt><code>Sphere_Map</code> = 1</dt>
<dt><code>Cylinder_Map</code> = 2</dt>
<dt><code>Torus_Map</code> = 5</dt>
</dl>

</div>
<a name="r3_8_1_1_5_3"></a>
<div class="content-level-h6" contains="Interpolation type constants" id="r3_8_1_1_5_3">
<h6>3.8.1.1.5.3 Interpolation type constants</h6>
<dl>
<dt><code>Bi</code> = 2</dt>
<dt><code>Norm</code> = 4</dt>
</dl>

</div>
<a name="r3_8_1_1_5_4"></a>
<div class="content-level-h6" contains="Fog type constants" id="r3_8_1_1_5_4">
<h6>3.8.1.1.5.4 Fog type constants</h6>
<dl>
<dt><code>Uniform_Fog</code> = 1</dt>
<dt><code>Ground_Fog</code> = 2</dt>
</dl>

</div>
<a name="r3_8_1_1_5_5"></a>
<div class="content-level-h6" contains="Focal blur hexgrid constants" id="r3_8_1_1_5_5">
<h6>3.8.1.1.5.5 Focal blur hexgrid constants</h6>
<dl>
<dt><code>Hex_Blur1</code> = 7</dt>
<dt><code>Hex_Blur2</code> = 19</dt>
<dt><code>Hex_Blur3</code> = 37</dt>
</dl>

</div>
<a name="r3_8_1_1_5_6"></a>
<div class="content-level-h6" contains="IORs" id="r3_8_1_1_5_6">
<h6>3.8.1.1.5.6 IORs</h6>
<dl>
<dt><code>Air_Ior</code> = 1.000292</dt>
<dt><code>Amethyst_Ior</code> = 1.550</dt>
<dt><code>Apatite_Ior</code> = 1.635</dt>
<dt><code>Aquamarine_Ior</code> = 1.575</dt>
<dt><code>Beryl_Ior</code> = 1.575</dt>
<dt><code>Citrine_Ior</code> = 1.550</dt>
<dt><code>Crown_Glass_Ior</code> = 1.51</dt>
<dt><code>Corundum_Ior</code> = 1.765</dt>
<dt><code>Diamond_Ior</code> = 2.47</dt>
<dt><code>Emerald_Ior</code> = 1.575		</dt>
<dt><code>Flint_Glass_Ior</code> = 1.71</dt>
<dt><code>Flint_Glass_Heavy_Ior</code> = 1.8</dt>
<dt><code>Flint_Glass_Medium_Ior</code> = 1.63</dt>
<dt><code>Flint_Glass_Light_Ior</code> = 1.6</dt>
<dt><code>Fluorite_Ior</code> = 1.434</dt>
<dt><code>Gypsum_Ior</code> = 1.525</dt>
<dt><code>Ice_Ior</code> = 1.31</dt>
<dt><code>Plexiglas_Ior</code> = 1.5</dt>
<dt><code>Quartz_Ior</code> = 1.550</dt>
<dt><code>Quartz_Glass_Ior </code>= 1.458</dt>
<dt><code>Ruby_Ior</code> = 1.765</dt>
<dt><code>Salt_Ior</code> = 1.544</dt>
<dt><code>Sapphire_Ior</code> = 1.765</dt>
<dt><code>Topaz_Ior</code> = 1.620</dt>
<dt><code>Tourmaline_Ior</code> = 1.650</dt>
<dt><code>Water_Ior</code> = 1.33</dt>
</dl>

</div>
<a name="r3_8_1_1_5_7"></a>
<div class="content-level-h6" contains="Dispersion amounts" id="r3_8_1_1_5_7">
<h6>3.8.1.1.5.7 Dispersion amounts</h6>
<dl>
<dt><code>Quartz_Glass_Dispersion</code> = 1.012</dt>
<dt><code>Water_Dispersion</code> = 1.007</dt>
<dt><code>Diamond_Dispersion</code> = 1.035</dt>
<dt><code>Sapphire_Dispersion</code> = 1.015</dt>
</dl>

</div>
<a name="r3_8_1_1_5_8"></a>
<div class="content-level-h6" contains="Scattering media type constants" id="r3_8_1_1_5_8">
<h6>3.8.1.1.5.8 Scattering media type constants</h6>
<dl>
<dt><code>ISOTROPIC_SCATTERING</code> = 1;</dt>
<dt><code>MIE_HAZY_SCATTERING</code> = 2;</dt>
<dt><code>MIE_MURKY_SCATTERING</code> = 3;</dt>
<dt><code>RAYLEIGH_SCATTERING</code> = 4;</dt>
<dt><code>HENYEY_GREENSTEIN_SCATTERING</code> = 5;</dt>
</dl></div>

<a name="r3_8_1_1_6"></a>
<div class="content-level-h5" contains="Debug.inc" id="r3_8_1_1_6">
<h5>3.8.1.1.6 Debug.inc</h5>

<p>This file contains a set of macros designed to make debugging easier. It also functions like the old debug.inc, with the exception that you have to call the <code>Debug_Inc_Stack()</code> macro to get the include stack output.</p>

<p><code>Debug_Inc_Stack()</code>: Activates include file tracking, each included file will send a debug message when it is included.</p>
<p>Parameters:</p>
<ul>
  <li>None.</li>
</ul>

<p><code>Set_Debug(Bool)</code>: Activate or deactivate the debugging macros.</p>
<p>Parameters:</p>
<ul>
	<li><code>Bool</code> = A boolean (true/false) value.</li>
</ul>

<p><code>Debug_Message(Str)</code>: If debugging, sends the message to the debug stream.</p>
<p>Parameters:</p>
<ul>
	<li><code>Str</code> = The desired message.</li>
</ul>
<p><code>Debug(Condition, Message)</code>: Sends a message to the <code>#debug</code> stream depending on a given condition.</p>
<p>Parameters:</p>
<ul>
	<li><code>Condition</code> = Any boolean expression.</li>
	<li><code>Message</code> = The message to be sent if Condition evaluates as <em>true</em>.</li>
</ul>

<p><code>Warning(Condition, Message)</code>: Sends a message to the <code>#warning</code> stream depending on a given condition.</p>
<p>Parameters:</p>
<ul>
	<li><code>Condition</code> = Any boolean expression.</li>
	<li><code>Message</code> = The message to be sent if Condition evaluates as <em>true</em>.</li>
</ul>

<p><code>Error(Condition, Message)</code>: Sends a message to the <code>#error</code> stream depending on a given condition.</p>
<p>Parameters:</p>
<ul>
	<li><code>Condition</code> = Any boolean expression.</li>
	<li><code>Message</code> = The message to be sent if Condition evaluates as <em>true</em>.</li>
</ul></div>

<a name="r3_8_1_1_7"></a>
<div class="content-level-h5" contains="Finish.inc" id="r3_8_1_1_7">
<h5>3.8.1.1.7 Finish.inc</h5>

<p>This file contains some predefined finishes.</p>

<dl>
<dt><code>Dull</code></dt>
<dd>Dull, with a large, soft specular highlight.</dd>

<dt><code>Shiny</code></dt>
<dd>Shiny, with a small, tight specular highlight.</dd>

<dt><code>Glossy</code></dt>
<dd>Very shiny with very tight specular highlights and a fair amount of reflection.</dd>

<dt><code>Phong_Dull</code></dt>
<dd>Dull, with a large, soft phong highlight.</dd>

<dt><code>Phong_Shiny</code></dt>
<dd>Shiny, with a small, tight phong highlight.</dd>

<dt><code>Phong_Glossy</code></dt>
<dd>Very shiny with very tight phong highlights and a fair amount of reflection.</dd>

<dt><code>Luminous</code></dt>
<dd>A glowing surface, unaffected by light_sources.</dd>

<dt><code>Mirror</code></dt>
<dd>A perfectly reflective surface, no highlights or shading.</dd>
</dl></div>

<a name="r3_8_1_1_8"></a>
<div class="content-level-h5" contains="Functions.inc" id="r3_8_1_1_8">
<h5>3.8.1.1.8 Functions.inc</h5>

<p>
This include file contains interfaces to internal functions as well as several predefined functions. The ID's used to access the internal
functions through calls to <em>internal(XX)</em>, are not guaranteed to stay the same between POV-Ray versions, so users are encouraged to
use the functions declared here.
</p>
<p>
The number of required parameters and what they control are also given in the include file, this chapter gives more information. For starter
values of the parameters, see the <code>~scenes/incdemo/i_internal.pov</code> demo file.
</p>
<p>Syntax to be used:</p>
<pre>
#include &quot;functions.inc&quot;
isosurface {
  function { f_torus_gumdrop(x,y,z, P0) }
  ...
  }

pigment {
  function { f_cross_ellipsoids(x,y,z, P0, P1, P2, P3) }
  COLOR_MAP ...
  }
</pre>
<p>Some special parameters are found in several of these functions. These are described in the next section and later referred to as
<em>Cross section type</em>, <em>Field Strength</em>, <em>Field Limit</em>, <em>SOR</em> parameters.</p>

</div>
<a name="r3_8_1_1_8_1"></a>
<div class="content-level-h6" contains="Common Parameters" id="r3_8_1_1_8_1">
<h6>3.8.1.1.8.1 Common Parameters</h6>
</div>
<a name="r3_8_1_1_8_2"></a>
<div class="content-level-h6" contains="Cross Section Type" id="r3_8_1_1_8_2">
<h6>3.8.1.1.8.2 Cross Section Type</h6>
<p>In the helixes and spiral functions, the 9th parameter is the cross section type.</p>
<p>Some shapes are:</p>
<ul>
<li><code>0</code>: square</li>
<li><code>0.0 to 1.0</code>: rounded squares</li>
<li><code>1</code>: circle</li>
<li><code>1.0 to 2.0</code>: rounded diamonds</li>
<li><code>2</code>: diamond</li>
<li><code>2.0 to 3.0</code>: partially concave diamonds</li>
<li><code>3</code>: concave diamond</li>
</ul>

</div>
<a name="r3_8_1_1_8_3"></a>
<div class="content-level-h6" contains="Field Strength" id="r3_8_1_1_8_3">
<h6>3.8.1.1.8.3 Field Strength</h6>
<p>The numerical value at a point in space generated by the function is multiplied by the Field Strength. The set of points where the
function evaluates to zero are unaffected by any positive value of this parameter, so if you are just using the function on its own with
threshold = 0, the generated surface is still the same.</p>
<p>In some cases, the field strength has a considerable effect on the speed and accuracy of rendering the surface. In general, increasing
the field strength speeds up the rendering, but if you set the value too high the surface starts to break up and may disappear
completely.</p>
<p>Setting the field strength to a negative value produces the inverse of the surface, like making the function negative.</p>

</div>
<a name="r3_8_1_1_8_4"></a>
<div class="content-level-h6" contains="Field Limit" id="r3_8_1_1_8_4">
<h6>3.8.1.1.8.4 Field Limit</h6>
<p>This will not make any difference to the generated surface if you are using threshold that is within the field limit (and will kill the
surface completely if the threshold is greater than the field limit). However, it may make a huge difference to the rendering times.</p>
<p>If you use the function to generate a pigment, then all points that are a long way from the surface will have the same color, the color
that corresponds to the numerical value of the field limit.</p>

</div>
<a name="r3_8_1_1_8_5"></a>
<div class="content-level-h6" contains="SOR Switch" id="r3_8_1_1_8_5">
<h6>3.8.1.1.8.5 SOR Switch</h6>
<p>If greater than zero, the curve is swept out as a surface of revolution (SOR). If the value is zero or negative, the curve is extruded
linearly in the Z direction.</p>

</div>
<a name="r3_8_1_1_8_6"></a>
<div class="content-level-h6" contains="SOR Offset" id="r3_8_1_1_8_6">
<h6>3.8.1.1.8.6 SOR Offset</h6>
<p>If the SOR switch is on, then the curve is shifted this distance in the X direction before being swept out.</p>

</div>
<a name="r3_8_1_1_8_7"></a>
<div class="content-level-h6" contains="SOR Angle" id="r3_8_1_1_8_7">
<h6>3.8.1.1.8.7 SOR Angle</h6>
<p>If the SOR switch is on, then the curve is rotated this number of degrees about the Z axis before being swept out.</p>

</div>
<a name="r3_8_1_1_8_8"></a>
<div class="content-level-h6" contains="Invert Isosurface" id="r3_8_1_1_8_8">
<h6>3.8.1.1.8.8 Invert Isosurface</h6>
<p>Sometimes, when you render a surface, you may find that you get only the shape of the container. This could be caused by the fact that
some of the build in functions are defined inside out.</p>
<p>We can invert the isosurface by negating the whole function: <code>-(function) - threshold</code></p>

</div>
<a name="r3_8_1_1_8_9"></a>
<div class="content-level-h6" contains="Internal Functions" id="r3_8_1_1_8_9">
<h6>3.8.1.1.8.9 Internal Functions</h6>
<p>Here is a list of the internal functions in the order they appear in the <em>functions.inc</em> include file</p>

<p><code>f_algbr_cyl1(x,y,z, P0, P1, P2, P3, P4)</code>: An algebraic cylinder is what you get if you take any 2d curve and plot it in 3d.
The 2d curve is simply extruded along the third axis, in this case the z axis. With the SOR Switch switched on, the figure-of-eight curve
will be rotated around the Y axis instead of being extruded along the Z axis.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a></li>
<li><code>P1</code> : <a href="r3_8.html#r3_8_1_1_8_4">Field Limit</a></li>
<li><code>P2</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_algbr_cyl2(x,y,z, P0, P1, P2, P3, P4)</code>: An algebraic cylinder is what you 
get if you take any 2d curve and plot it in 3d.
The 2d curve is simply extruded along the third axis, in this case the z axis.With the SOR Switch switched on, the cross section curve will
be rotated around the Y axis instead of being extruded along the Z axis.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : <a href="r3_8.html#r3_8_1_1_8_4">Field Limit</a></li>
<li><code>P2</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_algbr_cyl3(x,y,z, P0, P1, P2, P3, P4)</code>: An algebraic cylinder is what you get
if you take any 2d curve and plot it in 3d. The 2d curve
is simply extruded along the third axis, in this case the Z axis. With the SOR Switch switched on, the cross section curve will be rotated
around the Y axis instead of being extruded along the Z axis.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : <a href="r3_8.html#r3_8_1_1_8_4">Field Limit</a></li>
<li><code>P2</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_algbr_cyl4(x,y,z, P0, P1, P2, P3, P4)</code>: An algebraic cylinder is what you get
if you take any 2d curve and plot it in 3d. The 2d curve
is simply extruded along the third axis, in this case the z axis. With the SOR Switch switched on, the cross section curve will be rotated
around the Y axis instead of being extruded along the Z axis.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : <a href="r3_8.html#r3_8_1_1_8_4">Field Limit</a></li>
<li><code>P2</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_bicorn(x,y,z, P0, P1)</code>: The surface is a surface of revolution.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Scale. The mathematics of this surface suggest that the shape should be different
for different values of this parameter. In practice the difference in shape is hard to spot.
Setting the scale to 3 gives a surface with a radius of about 1 unit</li>
</ul>

<p><code>f_bifolia(x,y,z, P0, P1)</code>: The bifolia surface looks something like the top part of
a a paraboloid bounded below by another paraboloid.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Scale. The surface is always the same shape. Changing this parameter has the
same effect as adding a scale modifier. Setting the scale to 1 gives a surface with a radius
of about 1 unit</li>
</ul>

<p><code>f_blob(x,y,z, P0, P1, P2, P3, P4)</code>: This function generates blobs that are
similar to a CSG blob with two spherical components. This function only seems to work
with negative threshold settings.</p>
<ul>
<li><code>P0</code> : X distance between the two components</li>
<li><code>P1</code> : Blob strength of component 1</li>
<li><code>P2</code> : Inverse blob radius of component 1</li>
<li><code>P3</code> : Blob strength of component 2</li>
<li><code>P4</code> : Inverse blob radius of component 2</li>
</ul>

<p><code>f_blob2(x,y,z, P0, P1, P2, P3)</code>: The surface is similar to a CSG blob
with two spherical components.</p>
<ul>
<li><code>P0</code> : Separation. One blob component is at the origin, and the other is this distance away on the X axis</li>
<li><code>P1</code> : Inverse size. Increase this to decrease the size of the surface</li>
<li><code>P2</code> : Blob strength</li>
<li><code>P3</code> : Threshold. Setting this parameter to 1 and the threshold to zero has exactly the same effect as setting this parameter to zero and the threshold to -1</li>
</ul>

<p><code>f_boy_surface(x,y,z, P0, P1)</code>: For this surface, it helps if the field strength
is set low, otherwise the surface has a tendency to break up or disappear entirely. This has
the side effect of making the rendering times extremely long.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Scale. The surface is always the same shape. Changing this parameter has the
same effect as adding a scale modifier</li>
</ul>

<p><code>f_comma(x,y,z, P0)</code>: The <em>comma</em> surface is very much like a comma-shape.</p>
<ul>
<li><code>P0</code> : Scale</li></ul>

<p><code>f_cross_ellipsoids(x,y,z, P0, P1, P2, P3)</code>: The <em>cross ellipsoids</em> surface is
like the union of three crossed ellipsoids, one oriented along each axis.</p>
<ul>
<li><code>P0</code> : Eccentricity. When less than 1, the ellipsoids are oblate, when greater than 1 the
ellipsoids are prolate, when zero the ellipsoids are spherical (and hence the whole surface is a sphere)</li>
<li><code>P1</code> : Inverse size. Increase this to decrease the size of the surface</li>
<li><code>P2</code> : Diameter. Increase this to increase the size of the ellipsoids</li>
<li><code>P3</code> : Threshold. Setting this parameter to 1 and the threshold to zero has exactly the same
effect as setting this parameter to zero and the threshold to -1</li>
</ul>

<p><code>f_crossed_trough(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_cubic_saddle(x,y,z, P0)</code>: For this surface, it helps if the field strength is set quite low, otherwise the surface has a
tendency to break up or disappear entirely.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_cushion(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_devils_curve(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : Field Strength (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_devils_curve_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>: The <code>f_devils_curve_2d</code> curve can be
extruded along the z axis, or using the SOR parameters it can be made into a surface of revolution.
The X and Y factors control the size of the central feature.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : X factor</li>
<li><code>P2</code> : Y factor</li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_dupin_cyclid(x,y,z, P0, P1, P2, P3, P4, P5)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Major radius of torus</li>
<li><code>P2</code> : Minor radius of torus</li>
<li><code>P3</code> : X displacement of torus</li>
<li><code>P4</code> : Y displacement of torus</li>
<li><code>P5</code> : Radius of inversion</li>
</ul>

<p><code>f_ellipsoid(x,y,z, P0, P1, P2)</code>: <code>f_ellipsoid</code> generates spheres and ellipsoids. Needs <code>threshold 1</code>.
Setting these scaling parameters to 1/n gives exactly the same effect as performing a scale operation to increase the scaling by <em>n</em>
in the corresponding direction.</p>
<ul>
<li><code>P0</code> : X scale (inverse)</li>
<li><code>P1</code> : Y scale (inverse)</li>
<li><code>P2</code> : Z scale (inverse)</li>
</ul>

<p><code>f_enneper(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_flange_cover(x,y,z, P0, P1, P2, P3)</code>:</p>
<ul>
<li><code>P0</code> : Spikiness. Set this to very low values to increase the spikes. Set it to 1 and you get a sphere</li>
<li><code>P1</code> : Inverse size. Increase this to decrease the size of the surface. (The other parameters
also drastically affect the size, but this parameter has no other effects)</li>
<li><code>P2</code> : Flange. Increase this to increase the flanges that appear between the spikes. Set it to 1 for no flanges</li>
<li><code>P3</code> : Threshold. Setting this parameter to 1 and the threshold to zero has exactly the
same effect as setting this parameter to zero and the threshold to -1</li>
</ul>

<p><code>f_folium_surface(x,y,z, P0, P1, P2)</code>: A <em>folium surface</em> looks something like a paraboloid glued to a plane.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Neck width factor - the larger you set this, the narrower the neck where the
paraboloid meets the plane</li>
<li><code>P2</code> : Divergence - the higher you set this value, the wider the paraboloid gets</li>
</ul>

<p><code>f_folium_surface_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>: The <code>f_folium_surface_2d</code> curve can be
rotated around the X axis to generate the same 3d surface as the <code>f_folium_surface</code>, or it can be extruded 
in the Z direction (by switching the SOR switch off) </p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Neck width factor - same as the 3d surface if you are revolving it around the Y axis</li>
<li><code>P2</code> : Divergence - same as the 3d surface if you are revolving it around the Y axis</li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_glob(x,y,z, P0)</code>: One part of this surface would actually go off to
infinity if it were not restricted by the contained_by shape.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_heart(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_helical_torus(x,y,z, P0, P1, P2, P3, P4, P5, P6, P7, P8, P9)</code>: With some sets of parameters, it looks like a torus with a
helical winding around it. The
winding optionally has grooves around the outside.</p>
<ul>
<li><code>P0</code> : Major radius</li>
<li><code>P1</code> : Number of winding loops</li>
<li><code>P2</code> : Twistiness of winding. When zero, each winding loop is separate. When set to one,
each loop twists into the next one. When set to two, each loop twists into the one after next</li>
<li><code>P3</code> : Fatness of winding?</li>
<li><code>P4</code> : Threshold. Setting this parameter to 1 and the threshold to zero has s similar effect
as setting this parameter to zero and the threshold to 1</li>
<li><code>P5</code> : Negative minor radius? Reducing this parameter increases the minor radius of the
central torus. Increasing it can make the torus disappear and be replaced by a vertical column.
The value at which the surface switches from one form to the other depends on several other parameters</li>
<li><code>P6</code> : Another fatness of winding control?</li>
<li><code>P7</code> : Groove period. Increase this for more grooves</li>
<li><code>P8</code> : Groove amplitude. Increase this for deeper grooves</li>
<li><code>P9</code> : Groove phase. Set this to zero for symmetrical grooves</li>
</ul>

<p><code>f_helix1(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>:</p>
<ul>
<li><code>P0</code> : Number of helixes - e.g. 2 for a double helix</li>
<li><code>P1</code> : Period - is related to the number of turns per unit length</li>
<li><code>P2</code> : Minor radius (major radius &gt; minor radius)</li>
<li><code>P3</code> : Major radius</li>
<li><code>P4</code> : Shape parameter. If this is greater than 1 then the tube becomes fatter in the y direction</li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_2">Cross section type</a></li>
<li><code>P6</code> : Cross section rotation angle (degrees)</li>
</ul>

<p><code>f_helix2(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>: Needs a negated function</p>
<ul>
<li><code>P0</code> : Not used</li>
<li><code>P1</code> : Period - is related to the number of turns per unit length</li>
<li><code>P2</code> : Minor radius (minor radius &gt; major radius)</li>
<li><code>P3</code> : Major radius</li>
<li><code>P4</code> : Not used</li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_2">Cross section type</a></li>
<li><code>P6</code> : Cross section rotation angle (degrees)</li>
</ul>

<p><code>f_hex_x(x,y,z, P0)</code>: This creates a grid of hexagonal cylinders stretching along 
the z-axis. The fatness is controlled
by the threshold value. When this value equals 0.8660254 or cos(30) the sides will touch, because
this is the distance between centers. Negating the function will inverse the surface and create a
honey-comb structure. This function is also useful as pigment function.</p>
<ul>
<li><code>P0</code> : No effect (but the syntax requires at least one parameter)</li>
</ul>

<p><code>f_hex_y(x,y,z, P0)</code>: This is function forms a lattice of infinite boxes 
stretching along the z-axis. The fatness is
controlled by the threshold value. These boxes are rotated 60 degrees around centers, which
are 0.8660254 or cos(30) away from each other. This function is also useful as pigment function.</p>
<ul>
<li><code>P0</code> : No effect (but the syntax requires at least one parameter)</li>
</ul>

<p><code>f_hetero_mf(x,y,z, P0, P1, P2, P3, P4, P5)</code>: <code>f_hetero_mf (x,0,z)</code> makes multifractal height fields and patterns
of <em>1/f</em> noise. <em>Multifractal</em> refers to their characteristic of having a fractal dimension which varies with
altitude. Built from summing noise of a number of frequencies, the hetero_mf parameters determine how many, and which frequencies are to be
summed. An advantage to using these instead of a height_field {} from an image (a number of height field programs output multifractal types
of images) is that the hetero_mf function domain extends arbitrarily far in the x and z directions so huge landscapes can be made without
losing resolution or having to tile a height field. Other functions of interest are <code>f_ridged_mf</code> and <code>f_ridge</code>.</p>
<ul>
<li><code>P0</code> : H is the negative of the exponent of the basic noise frequencies used in building these functions (each frequency
<em>f's</em> amplitude is weighted by the factor <em>f - H</em> ). In landscapes, and many natural forms, the amplitude of high frequency
contributions are usually less than the lower frequencies. When H is 1, the fractalization is relatively smooth (<em>1/f noise</em>). As H
nears 0, the high frequencies contribute equally with low frequencies as in <em>white noise</em>.</li>
<li><code>P1</code> : <em>Lacunarity</em> is the multiplier used to get from one <em>octave</em> to the next. This parameter affects the
size of the frequency gaps in the pattern. Make this greater than 1.0</li>
<li><code>P2</code> : Octaves is the number of different frequencies added to the fractal. Each <em>Octave</em> frequency is the previous
one multiplied by <em>Lacunarity</em>, so that using a large number of octaves can get into very high frequencies very quickly.</li>
<li><code>P3</code> : Offset is the <em>base altitude</em> (sea level) used for the heterogeneous scaling</li>
<li><code>P4</code> : T scales the <em>heterogeneity</em> of the fractal. T=0 gives <em>straight 1/f</em> (no heterogeneous
scaling). T=1 suppresses higher frequencies at lower altitudes</li>
<li><code>P5</code> : Generator type used to generate the noise3d. 0, 1, 2 and 3 are legal values.</li>
</ul>

<p><code>f_hunt_surface(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_hyperbolic_torus(x,y,z, P0, P1, P2)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Major radius: separation between the centers of the tubes at the closest point</li>
<li><code>P2</code> : Minor radius: thickness of the tubes at the closest point</li>
</ul>

<p><code>f_isect_ellipsoids(x,y,z, P0, P1, P2, P3)</code>: The <em>isect ellipsoids</em> surface is like the
intersection of three crossed ellipsoids, one oriented along each axis.</p>
<ul>
<li><code>P0</code> : Eccentricity. When less than 1, the ellipsoids are oblate, when greater than 1 the
ellipsoids are prolate, when zero the ellipsoids are spherical (and hence the whole surface is a sphere)</li>
<li><code>P1</code> : Inverse size. Increase this to decrease the size of the surface</li>
<li><code>P2</code> : Diameter. Increase this to increase the size of the ellipsoids</li>
<li><code>P3</code> : Threshold. Setting this parameter to 1 and the threshold to zero has exactly
the same effect as setting this parameter to zero and the threshold to -1</li>
</ul>

<p><code>f_kampyle_of_eudoxus(x,y,z, P0, P1, P2)</code>: The <em>kampyle of eudoxus</em> is like two infinite planes with a dimple at the
center.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Dimple: When zero, the two dimples punch right through and meet at the center.
Non-zero values give less dimpling</li>
<li><code>P2</code> : Closeness: Higher values make the two planes become closer</li>
</ul>

<p><code>f_kampyle_of_eudoxus_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>: The 2d curve that generates the above surface can be extruded in the
Z direction or rotated about various axes by using the SOR parameters.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Dimple: When zero, the two dimples punch right through and meet at the center.
Non-zero values give less dimpling</li>
<li><code>P2</code> : Closeness: Higher values make the two planes become closer</li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_klein_bottle(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_kummer_surface_v1(x,y,z, P0)</code>: The Kummer surface consists of a collection of radiating rods.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_kummer_surface_v2(x,y,z, P0, P1, P2, P3)</code>: Version 2 of the kummer surface only looks like radiating rods when the
parameters are set to particular negative values. For positive values it tends to look rather like a superellipsoid.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Rod width (negative): Setting this parameter to larger negative values increases the diameter of the rods</li>
<li><code>P2</code> : Divergence (negative): Setting this number to -1 causes the rods to become
approximately cylindrical. Larger negative values cause the rods to become fatter further
from the origin. Smaller negative numbers cause the rods to become narrower away from
the origin, and have a finite length</li>
<li><code>P3</code> : Influences the length of half of the rods.Changing the sign affects the other half of the rods. 0 has no effect</li>
</ul>

<p><code>f_lemniscate_of_gerono(x,y,z, P0)</code>: The <em>Lemniscate of Gerono</em> surface is an hourglass shape, or two teardrops with
their ends connected.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_lemniscate_of_gerono_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>: The 2d version of the Lemniscate can be extruded in the Z
direction, or used as a surface of revolution to generate the equivalent of the 3d version, or revolved in different ways.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Size: increasing this makes the 2d curve larger and less rounded</li>
<li><code>P2</code> : Width: increasing this makes the 2d curve fatter</li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_mesh1(x,y,z, P0, P1, P2, P3, P4)</code>: The overall thickness of the threads is controlled by the isosurface threshold, not
by a parameter. If you render a mesh1 with zero threshold, the threads have zero thickness and are therefore invisible. Parameters P2 and P4
control the shape of the thread relative to this threshold parameter.</p>
<ul>
<li><code>P0</code> : Distance between neighboring threads in the x direction</li>
<li><code>P1</code> : Distance between neighboring threads in the z direction</li>
<li><code>P2</code> : Relative thickness in the x and z directions</li>
<li><code>P3</code> : Amplitude of the weaving effect. Set to zero for a flat grid</li>
<li><code>P4</code> : Relative thickness in the y direction</li>
</ul>

<p><code>f_mitre(x,y,z, P0)</code>: The <em>Mitre</em> surface looks a bit like an ellipsoid which has been nipped at each end with a pair
of sharp nosed pliers.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_nodal_cubic(x,y,z, P0)</code>: The <em>Nodal Cubic</em> is something like what you would get if you were to extrude the Stophid2D
curve along the X axis and then lean it over.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_noise3d(x,y,z)</code>:</p>

<p><code>f_noise_generator(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : Noise generator number</li>
</ul>

<p><code>f_odd(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_ovals_of_cassini(x,y,z, P0, P1, P2, P3)</code>: The Ovals of Cassini are a generalization of the torus shape.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Major radius - like the major radius of a torus</li>
<li><code>P2</code> : Filling. Set this to zero, and you get a torus. Set this to a higher value and the hole in the middle starts to heal
up. Set it even higher and you get an ellipsoid with a dimple</li>
<li><code>P3</code> : Thickness. The higher you set this value, the plumper is the result</li>
</ul>

<p><code>f_paraboloid(x,y,z, P0)</code>: This paraboloid is the surface of revolution that you get if you rotate a parabola about the Y
axis.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_parabolic_torus(x,y,z, P0, P1, P2)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Major radius</li>
<li><code>P2</code> : Minor radius</li>
</ul>

<p><code>f_ph(x,y,z)</code>: When used alone, the <em>PH</em> function gives a surface that consists of all points that are at a particular
latitude, i.e. a cone. If you use a threshold of zero (the default) this gives a cone of width zero, which is invisible. Also look at
<code>f_th</code> and <code>f_r</code>
</p>

<p><code>f_pillow(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a></li>
</ul>

<p><code>f_piriform(x,y,z, P0)</code>: The piriform surface looks rather like half a lemniscate.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a></li>
</ul>

<p><code>f_piriform_2d(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>: The 2d version of the <em>Piriform</em> can be extruded in the Z
direction, or used as a surface of revolution to generate the equivalent of the 3d version.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Size factor 1: increasing this makes the curve larger</li>
<li><code>P2</code> : Size factor 2: making this less negative makes the curve larger but also thinner</li>
<li><code>P3</code> : Fatness: increasing this makes the curve fatter</li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P6</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_poly4(x,y,z, P0, P1, P2, P3, P4)</code>: This <code>f_poly4</code> can be used to generate the surface of revolution of any
polynomial up to degree 4. To put it another way: If we call the parameters A, B, C, D, E; then this function generates the surface of
revolution formed by revolving <code>x = A + By + Cy2 + Dy3 + Ey4</code> around the Y axis.</p>
<ul>
<li><code>P0</code> : Constant</li>
<li><code>P1</code> : Y coefficient</li>
<li><code>P2</code> : Y2 coefficient</li>
<li><code>P3</code> : Y3 coefficient</li>
<li><code>P4</code> : Y4 coefficient</li>
</ul>

<p><code>f_polytubes(x,y,z, P0, P1, P2, P3, P4, P5)</code>: The <em>Polytubes</em> surface consists of a number of tubes. Each tube follows
a 2d curve which is specified by a polynomial of degree 4 or less. If we look at the parameters, then this function generates <em>P0</em>
tubes which all follow the equation <code>x = P1 + P2y + P3y2 + P4y3 + P5y4</code> arranged around the Y axis. This function needs a
positive threshold (fatness of the tubes).</p>
<ul>
<li><code>P0</code> : Number of tubes</li>
<li><code>P1</code> : Constant</li>
<li><code>P2</code> : Y coefficient</li>
<li><code>P3</code> : Y2 coefficient</li>
<li><code>P4</code> : Y3 coefficient</li>
<li><code>P5</code> : Y4 coefficient</li>
</ul>

<p><code>f_quantum(x,y,z, P0)</code>: It resembles the shape of the electron density cloud for one of the d orbitals.</p>
<ul>
<li><code>P0</code> : Not used, but required</li>
</ul>

<p><code>f_quartic_paraboloid(x,y,z, P0)</code>: The <em>Quartic Paraboloid</em> is similar to a paraboloid, but has a squarer shape.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_quartic_saddle(x,y,z, P0)</code>: The <em>Quartic saddle</em> is similar to a saddle, but has a squarer shape.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a></li>
</ul>

<p><code>f_quartic_cylinder(x,y,z, P0, P1, P2)</code>: The <em>Quartic cylinder</em> looks a bit like a cylinder that is swallowed an
egg.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Diameter of the <em>egg</em></li>
<li><code>P2</code> : Controls the width of the tube and the vertical scale of the <em>egg</em></li>
</ul>

<p><code>f_r(x,y,z)</code>: When used alone, the <em>R</em> function gives a surface that consists of all the points that are a specific
distance (threshold value) from the origin, i.e. a sphere. Also look at <code>f_ph</code> and <code>f_th</code></p>

<p><code>f_ridge(x,y,z, P0, P1, P2, P3, P4, P5)</code>: This function is mainly intended for modifying other surfaces as you might use a
height field or to use as pigment function. Other functions of interest are <code>f_hetero_mf</code> and <code>f_ridged_mf</code>.</p>
<ul>
<li><code>P0</code> : Lambda</li>
<li><code>P1</code> : Octaves</li>
<li><code>P2</code> : Omega</li>
<li><code>P3</code> : Offset</li>
<li><code>P4</code> : Ridge</li>
<li><code>P5</code> : Generator type used to generate the noise3d. 0, 1, 2 and 3 are legal values.</li>
</ul>

<p><code>f_ridged_mf(x,y,z, P0, P1, P2, P3, P4, P5)</code>: The <em>Ridged Multifractal</em> surface can be used to create multifractal
height fields and patterns. <em>Multifractal</em> refers to their characteristic of having a fractal dimension which varies with altitude.
They are built from summing noise of a number of frequencies. The f_ridged_mf parameters determine how many, and which frequencies are to be
summed, and how the different frequencies are weighted in the sum.</p>
<p>An advantage to using these instead of a <code>height_field{}</code> from an image is that the ridged_mf function domain extends
arbitrarily far in the x and z directions so huge landscapes can be made without losing resolution or having to tile a height field. Other
functions of interest are <code>f_hetero_mf</code> and <code>f_ridge</code>.</p>
<ul>
<li><code>P0</code> : H is the negative of the exponent of the basic noise frequencies used in building these
functions (each frequency f's amplitude is weighted by the factor fE- H ). When H is 1, the
fractalization is relatively smooth. As H nears 0, the high frequencies contribute equally with
low frequencies</li>
<li><code>P1</code> : Lacunarity is the multiplier used to get from one <em>octave</em> to the next in the <em>fractalization</em>. This
parameter affects the size of the frequency gaps in the pattern. (Use values greater than 1.0)</li>
<li><code>P2</code> : Octaves is the number of different frequencies added to the fractal. Each octave
frequency is the previous one multiplied by <em>Lacunarity</em>. So, using a large number of octaves can
get into very high frequencies very quickly</li>
<li><code>P3</code> : Offset gives a fractal whose fractal dimension changes from altitude to altitude. The high
frequencies at low altitudes are more damped than at higher altitudes, so that lower altitudes are
smoother than higher areas</li>
<li><code>P4</code> : Gain weights the successive contributions to the accumulated fractal result to make
creases stick up as ridges</li>
<li><code>P5</code> : Generator type used to generate the noise3d. 0, 1, 2 and 3 are legal values.</li>
</ul>

<p><code>f_rounded_box(x,y,z, P0, P1, P2, P3)</code>: The Rounded Box is defined in a cube from &lt;-1, -1, -1&gt; to &lt;1, 1, 1&gt;. By
changing the <em>Scale</em> parameters, the size can be adjusted, without affecting the Radius of curvature.</p>
<ul>
<li><code>P0</code> : Radius of curvature. Zero gives square corners, 0.1 gives corners that match <code>sphere {0, 0.1}</code></li>
<li><code>P1</code> : Scale x</li>
<li><code>P2</code> : Scale y</li>
<li><code>P3</code> : Scale z</li>
</ul>

<p><code>f_sphere(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code>: radius of the sphere</li>
</ul>

<p><code>f_spikes(x,y,z, P0, P1, P2, P3, P4)</code>:</p>
<ul>
<li><code>P0</code> : Spikiness. Set this to very low values to increase the spikes. Set it to 1 and you get a sphere</li>
<li><code>P1</code> : Hollowness. Increasing this causes the sides to bend in more</li>
<li><code>P2</code> : Size. Increasing this increases the size of the object</li>
<li><code>P3</code> : Roundness. This parameter has a subtle effect on the roundness of the spikes</li>
<li><code>P4</code> : Fatness. Increasing this makes the spikes fatter</li>
</ul>

<p><code>f_spikes_2d(x,y,z, P0, P1, P2, P3)</code>:</p>
<ul>
<li><code>P0</code> : Height of central spike</li>
<li><code>P1</code> : Frequency of spikes in the X direction</li>
<li><code>P2</code> : Frequency of spikes in the Z direction</li>
<li><code>P3</code> : Rate at which the spikes reduce as you move away from the center</li>
</ul>

<p><code>f_spiral(x,y,z, P0, P1, P2, P3, P4, P5)</code>:</p>
<ul>
<li><code>P0</code> : Distance between windings</li>
<li><code>P1</code> : Thickness</li>
<li><code>P2</code> : Outer radius of the spiral. The surface behaves as if it is contained_by a sphere of this diameter</li>
<li><code>P3</code> : Not used</li>
<li><code>P4</code> : Not used</li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_2">Cross section type</a></li>
</ul>

<p><code>f_steiners_roman(x,y,z, P0)</code>: The <em>Steiners Roman</em> is composed of four identical triangular pads which together make
up a sort of rounded tetrahedron. There are creases along the X, Y and Z axes where the pads meet.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_strophoid(x,y,z, P0, P1, P2, P3)</code>: The <em>Strophoid</em> is like an infinite plane with a bulb sticking out of it.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Size of bulb. Larger values give larger bulbs. Negative values give a bulb on the other side of the plane</li>
<li><code>P2</code> : Sharpness. When zero, the bulb is like a sphere that just touches the plane. When
positive, there is a crossover point. When negative the bulb simply bulges out of the plane like a pimple</li>
<li><code>P3</code> : Flatness. Higher values make the top end of the bulb fatter</li>
</ul>

<p><code>f_strophoid_2d(x,y,z, P0, P1, P2, P3, P4, P5, P6)</code>: The 2d strophoid curve can be extruded in the Z direction or rotated
about various axes by using the SOR parameters.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a></li>
<li><code>P1</code> : Size of bulb. Larger values give larger bulbs. Negative values give a bulb on the other side of the plane</li>
<li><code>P2</code> : Sharpness. When zero, the bulb is like a sphere that just touches the plane. When positive, there is a crossover
point. When negative the bulb simply bulges out of the plane like a pimple</li>
<li><code>P3</code> : Fatness. Higher values make the top end of the bulb fatter</li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P6</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

<p><code>f_superellipsoid(x,y,z, P0, P1)</code>: Needs a negative field strength or a negated function.</p>
<ul>
<li><code>P0</code> : east-west exponentx</li>
<li><code>P1</code> : north-south exponent</li>
</ul>

<p><code>f_th(x,y,z)</code>: <code>f_th()</code> is a function that is only useful when combined with other surfaces. It produces a value
which is equal to the <em>theta</em> angle, in radians, at any point. The theta angle is like the longitude coordinate on the Earth. It
stays the same as you move north or south, but varies from east to west. Also look at <code>f_ph</code> and <code>f_r</code>
</p>

<p><code>f_torus(x,y,z, P0, P1)</code>:</p>
<ul>
<li><code>P0</code> : Major radius</li>
<li><code>P1</code> : Minor radius</li>
</ul>

<p><code>f_torus2(x,y,z, P0, P1, P2)</code>: This is different from the f_torus function which just has the major and minor radii as
parameters.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a 
   negated function)</li>
<li><code>P1</code> : Major radius</li>
<li><code>P2</code> : Minor radius</li>
</ul>

<p><code>f_torus_gumdrop(x,y,z, P0)</code>: The <em>Torus Gumdrop</em> surface is something like a torus with a couple of gumdrops hanging
off the end.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_umbrella(x,y,z, P0)</code>:</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
</ul>

<p><code>f_witch_of_agnesi(x,y,z, P0, P1, P2, P3, P4, P5)</code>: The <em>Witch of Agnesi</em> surface looks something like a witches
hat.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Controls the width of the spike. The height of the spike is always about 1 unit</li>
</ul>

<p><code>f_witch_of_agnesi_2d(x,y,z, P0, P1, P2, P3, P4, P5)</code>: The 2d version of the <em>Witch of Agnesi</em> curve can be extruded in
the Z direction or rotated about various axes by use of the SOR parameters.</p>
<ul>
<li><code>P0</code> : <a href="r3_8.html#r3_8_1_1_8_3">Field Strength</a> (Needs a negative field strength or a negated function)</li>
<li><code>P1</code> : Controls the size of the spike</li>
<li><code>P2</code> : Controls the height of the spike</li>
<li><code>P3</code> : <a href="r3_8.html#r3_8_1_1_8_5">SOR Switch</a></li>
<li><code>P4</code> : <a href="r3_8.html#r3_8_1_1_8_6">SOR Offset</a></li>
<li><code>P5</code> : <a href="r3_8.html#r3_8_1_1_8_7">SOR Angle</a></li>
</ul>

</div>
<a name="r3_8_1_1_8_10"></a>
<div class="content-level-h6" contains="Pre defined functions" id="r3_8_1_1_8_10">
<h6>3.8.1.1.8.10 Pre defined functions</h6>
<p><code>eval_pigment(Pigm, Vect)</code>: This macro evaluates the color of a pigment at a specific point. Some pigments require more
information than simply a point, slope pattern based pigments for example, and will not work with this macro. However, most pigments will
work fine.</p>
<p>Parameters:</p>
<ul>
	<li><code>Vect</code> = The point at which to evaluate the pigment.</li>
	<li><code>Pigm</code> = The pigment to evaluate.</li>
</ul>

<p><code>f_snoise3d(x, y, z)</code>: Just like f_noise3d(), but returns values in the range [-1, 1].</p>

<p><code>f_sine_wave(val, amplitude, frequency)</code>: Turns a ramping waveform into a sine waveform.</p>

<p><code>f_scallop_wave(val, amplitude, frequency)</code>: Turns a ramping waveform into a <em>scallop wave</em> waveform.
</p>

</div>
<a name="r3_8_1_1_8_11"></a>
<div class="content-level-h6" contains="Pattern functions" id="r3_8_1_1_8_11">
<h6>3.8.1.1.8.11 Pattern functions</h6>
<p>Predefined pattern functions, useful for building custom function patterns or performing <em>displacement mapping</em> on isosurfaces.
Many of them are not really useful for these purposes, they are simply included for completeness.</p>
<p>Some are not implemented at all because they require special parameters that must be specified in the definition, or information that is
not available to pattern functions. For this reason, you probably would want to define your own versions of these functions.
</p>
<p>All of these functions take three parameters, the XYZ coordinates of the point to evaluate the pattern at.</p>
<dl>
<dt><code>f_agate(x, y, z)</code></dt>
<dt><code>f_boxed(x, y, z)</code></dt>
<dt><code>f_bozo(x, y, z)</code></dt>
<dt><code>f_brick(x, y, z)</code></dt>
<dt><code>f_bumps(x, y, z)</code></dt>
<dt><code>f_checker(x, y, z)</code></dt>
<dt><code>f_crackle(x, y, z)</code></dt>
<dd> This pattern has many more options, this function uses the defaults.</dd>
<dt><code>f_cylindrical(x, y, z)</code></dt>
<dt><code>f_dents(x, y, z)</code></dt>
<dt><code>f_gradientX(x, y, z)</code></dt>
<dt><code>f_gradientY(x, y, z)</code></dt>
<dt><code>f_gradientZ(x, y, z)</code></dt>
<dt><code>f_granite(x, y, z)</code></dt>
<dt><code>f_hexagon(x, y, z)</code></dt>
<dt><code>f_leopard(x, y, z)</code></dt>
<dt><code>f_mandel(x, y, z)</code></dt>
<dd> Only the basic mandel pattern is implemented, its variants 
and the other fractal patterns are not implemented.</dd>
<dt><code>f_marble(x, y, z)</code></dt>
<dt><code>f_onion(x, y, z)</code></dt>
<dt><code>f_planar(x, y, z)</code></dt>
<dt><code>f_radial(x, y, z)</code></dt>
<dt><code>f_ripples(x, y, z)</code></dt>
<dt><code>f_spherical(x, y, z)</code></dt>
<dt><code>f_spiral1(x, y, z)</code></dt>
<dt><code>f_spiral2(x, y, z)</code></dt>
<dt><code>f_spotted(x, y, z)</code></dt>
<dt><code>f_waves(x, y, z)</code></dt>
<dt><code>f_wood(x, y, z)</code></dt>
<dt><code>f_wrinkles(x, y, z)</code></dt>
</dl></div>

<a name="r3_8_1_1_9"></a>
<div class="content-level-h5" contains="Glass.inc" id="r3_8_1_1_9">
<h5>3.8.1.1.9 Glass.inc</h5>

<p>This file contains glass materials using new features introduced in POV 3.1 and 3.5. The old glass.inc
file is still included for backwards compatibility (it is named glass_old.inc, and is included
by glass.inc, so you do not need to change any scenes), but these materials will give more
realistic results.</p>

</div>
<a name="r3_8_1_1_9_1"></a>
<div class="content-level-h6" contains="Glass colors (with transparency)" id="r3_8_1_1_9_1">
<h6>3.8.1.1.9.1 Glass colors (with transparency)</h6>
<table summary="glass.inc glass colors with transparency" cellspacing="5" cellpadding="5" width="100%">
<tr valign="top">
<td width="33%">
<code>
Col_Glass_Beerbottle<br>
Col_Glass_Bluish<br>
Col_Glass_Clear<br>
Col_Glass_Dark_Green<br>
</code>
</td>
<td width="33%">
<code>
Col_Glass_General<br>
Col_Glass_Green<br>
Col_Glass_Old<br>
Col_Glass_Orange<br>
</code>
</td>
<td width="33%">
<code>
Col_Glass_Ruby<br>
Col_Glass_Vicksbottle<br>
Col_Glass_Winebottle<br>
Col_Glass_Yellow<br>
</code>
</td>
</tr>
</table>

</div>
<a name="r3_8_1_1_9_2"></a>
<div class="content-level-h6" contains="Glass colors (without transparency, for fade_color)" id="r3_8_1_1_9_2">
<h6>3.8.1.1.9.2 Glass colors (without transparency, for fade_color)</h6>
<table summary="glass.inc glass colors without transparency for fade_color" cellspacing="5" cellpadding="5" width="100%">
<tr valign="top">
<td width="33%">
<code>
Col_Amber_01<br>
Col_Amber_02<br>
Col_Amber_03<br>
Col_Amber_04<br>
Col_Amber_05<br>
</code>
</td>
<td width="33%">
<code>
Col_Amber_06<br>
Col_Amber_07<br>
Col_Amber_08<br>
Col_Amber_09<br>
Col_Amethyst_01<br>
</code>
</td>
<td width="33%">
<code>
Col_Amethyst_02<br>
Col_Amethyst_03<br>
Col_Amethyst_04<br>
Col_Amethyst_05<br>
Col_Amethyst_06<br>
</code>
</td>
</tr>
<tr valign="top">
<td>
<code>
Col_Apatite_01<br>
Col_Apatite_02<br>
Col_Apatite_03<br>
Col_Apatite_04<br>
Col_Apatite_05<br>
</code>
</td>
<td>
<code>
Col_Aquamarine_01<br>
Col_Aquamarine_02<br>
Col_Aquamarine_03<br>
Col_Aquamarine_04<br>
Col_Aquamarine_05<br>
</code>
</td>
<td>
<code>
Col_Aquamarine_06<br>
Col_Azurite_01<br>
Col_Azurite_02<br>
Col_Azurite_03<br>
Col_Azurite_04<br>
</code>
</td>
</tr>
<tr valign="top">
<td>
<code>
Col_Beerbottle<br>
Col_Blue_01<br>
Col_Blue_02<br>
Col_Blue_03<br>
Col_Blue_04<br>
</code>
</td>
<td>
<code>
Col_Citrine_01<br>
Col_Dark_Green<br>
Col_Emerald_01<br>
Col_Emerald_02<br>
Col_Emerald_03<br>
</code>
</td>
<td>
<code>
Col_Emerald_04<br>
Col_Emerald_05<br>
Col_Emerald_06<br>
Col_Emerald_07<br>
Col_Fluorite_01<br>
</code>
</td>
</tr>
<tr valign="top">
<td>
<code>
Col_Fluorite_02<br>
Col_Fluorite_03<br>
Col_Fluorite_04<br>
Col_Fluorite_05<br>
Col_Fluorite_06<br>
</code>
</td>
<td>
<code>
Col_Fluorite_07<br>
Col_Fluorite_08<br>
Col_Fluorite_09<br>
Col_Green<br>
Col_Green_01<br>
</code>
</td>
<td>
<code>
Col_Green_02<br>
Col_Green_03<br>
Col_Green_04<br>
Col_Gypsum_01<br>
Col_Gypsum_02<br>
</code>
</td>
</tr>
<tr valign="top">
<td>
<code>
Col_Gypsum_03<br>
Col_Gypsum_04<br>
Col_Gypsum_05<br>
Col_Gypsum_06<br>
Col_Orange<br>
</code>
</td>
<td>
<code>
Col_Red_01<br>
Col_Red_02<br>
Col_Red_03<br>
Col_Red_04<br>
Col_Ruby<br>
</code>
</td>
<td>
<code>
Col_Ruby_01<br>
Col_Ruby_02<br>
Col_Ruby_03<br>
Col_Ruby_04<br>
Col_Ruby_05<br>
</code>
</td>
</tr>
<tr valign="top">
<td>
<code>
Col_Sapphire_01<br>
Col_Sapphire_02<br>
Col_Sapphire_03<br>
Col_Topaz_01<br>
Col_Topaz_02<br>
</code>
</td>
<td>
<code>
Col_Topaz_03<br>
Col_Tourmaline_01<br>
Col_Tourmaline_02<br>
Col_Tourmaline_03<br>
Col_Tourmaline_04<br>
</code>
</td>
<td>
<code>
Col_Tourmaline_05<br>
Col_Tourmaline_06<br>
Col_Vicksbottle<br>
Col_Winebottle<br>
Col_Yellow<br>
</code>
</td>
</tr>
<tr valign="top">
<td>
<code>
Col_Yellow_01<br>
Col_Yellow_02<br>
Col_Yellow_03<br>
Col_Yellow_04<br>
</code>
</td>
<td>
</td>
<td>
</td>
</tr>
</table>

</div>
<a name="r3_8_1_1_9_3"></a>
<div class="content-level-h6" contains="Glass finishes" id="r3_8_1_1_9_3">
<h6>3.8.1.1.9.3 Glass finishes</h6>
<code>F_Glass5, ..., F_Glass10</code>

</div>
<a name="r3_8_1_1_9_4"></a>
<div class="content-level-h6" contains="Glass interiors" id="r3_8_1_1_9_4">
<h6>3.8.1.1.9.4 Glass interiors</h6>
<dl>
<dt><code>I_Glass1, ..., I_Glass4</code></dt>
<dd><code>I_Glass_Fade_Sqr1</code> (identical to <code>I_Glass1</code>)</dd>
<dd><code>I_Glass_Fade_Exp1</code> (identical to <code>I_Glass2</code>)</dd>
<dd><code>I_Glass_Fade_Exp2</code> (identical to <code>I_Glass3</code>)</dd>
<dd><code>I_Glass_Fade_Exp3</code> (identical to <code>I_Glass4</code>)</dd>
<dd>Glass interiors with various fade_power settings.</dd>
<dt><code>I_Glass_Dispersion1, I_Glass_Dispersion2</code></dt>
<dd>Glass interiors with dispersion. <code>I_Glass_Dispersion1</code> has
an approximately natural glass dispersion. <code>I_Glass_Dispersion2</code> is exaggerated.</dd>
<dt><code>I_Glass_Caustics1, I_Glass_Caustics2</code></dt>
<dd>Glass interiors with caustics. </dd>
</dl>

</div>
<a name="r3_8_1_1_9_5"></a>
<div class="content-level-h6" contains="Glass interior macros" id="r3_8_1_1_9_5">
<h6>3.8.1.1.9.5 Glass interior macros</h6>
<p><code>I_Glass_Exp(Distance)</code> and <code>I_Glass_Sqr(Distance)</code>: These macros return an interior with either exponential or fade_power 2 falloff, and a fade_distance of Distance.</p></div>

<a name="r3_8_1_1_10"></a>
<div class="content-level-h5" contains="Golds.inc" id="r3_8_1_1_10">
<h5>3.8.1.1.10 Golds.inc</h5>

<p>This file has its own versions of <code>F_MetalA</code> through <code>F_MetalB</code>. The gold textures themselves are <code>T_Gold_1A</code> through <code>T_Gold_5E</code>.</p></div>

<a name="r3_8_1_1_11"></a>
<div class="content-level-h5" contains="Logo.inc" id="r3_8_1_1_11">
<h5>3.8.1.1.11 Logo.inc</h5>

<p>The official POV-Ray logo designed by Chris Colefax, in two versions</p>

<dl>
<dt><code>Povray_Logo</code></dt>
<dd> The POV-Ray logo object</dd>
<dt><code>Povray_Logo_Prism</code></dt>
<dd> The POV-Ray logo as a prism</dd>
<dt><code>Povray_Logo_Bevel</code></dt>
<dd>The POV-Ray logo as a beveled prism</dd>
</dl></div>

<a name="r3_8_1_1_12"></a>
<div class="content-level-h5" contains="Makegrass.inc" id="r3_8_1_1_12">
<h5>3.8.1.1.12 Makegrass.inc</h5>
 

<p>makegrass.inc  - grass and prairie building macros.</p>
<dl>
<dt><code>MakeBlade()</code></dt>
	<dd>creates an individual blade of grass as mesh.</dd>

<dt><code>MakeGrassPatch()</code></dt>
	<dd>creates a patch of grass (mesh)<br>
optional with saving the mesh in a text file.</dd>

<dt><code>MakePrairie()</code></dt>
	<dd>creates a prairie of grass patches.</dd>
</dl></div>

<a name="r3_8_1_1_13"></a>
<div class="content-level-h5" contains="Math.inc" id="r3_8_1_1_13">
<h5>3.8.1.1.13 Math.inc</h5>

<p>This file contains many general math functions and macros.</p>

</div>
<a name="r3_8_1_1_13_1"></a>
<div class="content-level-h6" contains="Float functions and macros" id="r3_8_1_1_13_1">
<h6>3.8.1.1.13.1 Float functions and macros</h6>
<p><code>even(N)</code>: A function to test whether N is even, returns 1 when true, 0 when false.</p>
<p>Parameters:</p>
<ul>
	<li><code>N</code> = Input value</li>
</ul>

<p><code>odd(N)</code>: A function to test whether N is odd, returns 1 when true, 0 when false.</p>
<p>Parameters:</p>
<ul>
	<li><code>N</code> = Input value</li>
</ul>

<p><code>Interpolate(GC, GS, GE, TS, TE, Method)</code>: Interpolation macro, interpolates between the float values <code>TS</code> and <code>TE</code>. The method of interpolation is cosine, linear or exponential. The position where to evaluate the interpolation is determined by the position of <code>GC</code> in the range <code>GS</code> - <code>GE</code>. See the example below.</p>
<p>Parameters:</p>
<ul>
	<li><code>GC</code> = global current, float value within the range GS - GE</li>
	<li><code>GS</code> = global start</li>
	<li><code>GE</code> = global end</li>
	<li><code>TS</code> = target start</li>
	<li><code>TE</code> = target end</li>
	<li><code>Method</code> = interpolation method, float value:
		<ul>
			<li><code>Method</code> &lt; 0 : exponential, using the value of Method as exponent.</li>
			<li><code>Method</code> = 0 : cosine interpolation.</li>
			<li><code>Method</code> &gt; 0 : exponential, using the value of Method as exponent.
			<ul>
      <li><code>Method</code> = 1 : linear interpolation,</li>
			</ul></li>
		</ul></li>
</ul>
<p>
Example:
</p>
<pre>
#declare A = Interpolate(0.5, 0, 1, 0, 10, 1);
#debug str(A,0,2)
// result A = 5.00

#declare A = Interpolate(0.0,-2, 2, 0, 10, 1);
#debug str(A,0,2)
// result A = 5.00

#declare A = Interpolate(0.5, 0, 1, 0, 10, 2);
#debug str(A,0,2)  
// result A = 2.50
</pre>

<p><code>Mean(A)</code>: A macro to compute the average of an array of values.</p>
<p>Parameters:</p>
<ul>
	<li><code>A</code> = An array of float or vector values.</li>
</ul>

<p><code>Std_Dev(A, M)</code>: A macro to compute the standard deviation.</p>
<p>Parameters:</p>
<ul>
	<li><code>A</code> = An array of float values.</li>
	<li><code>M</code> = Mean of the floats in the array.</li>
</ul>

<p><code>GetStats(A)</code>: This macro declares a global array named <code>StatisticsArray</code> containing: N, Mean, Min, Max, and Standard Deviation</p>
<p>Parameters:</p>
<ul>
	<li><code>A</code> = An array of float values.</li>
</ul>

<p><code>Histogram(ValArr, Intervals)</code>: This macro declares a global, 2D array named <code>HistogramArray</code>. The first value in the array is the center of the interval/bin, the second the number of values in that interval.</p>
<p>Parameters:</p>
<ul>
	<li><code>ValArr</code> = An array with values.</li>
	<li><code>Intervals</code> = The desired number of intervals/bins.</li>
</ul>

<p><code>sind(v), cosd(v), tand(v), asind(v), acosd(v), atand(v), atan2d(a, b)</code>: These functions are versions of the
trigonometric functions using degrees, instead of radians, as the angle unit.</p>
<p>Parameters:</p>
<ul>
    <li>The same as for the analogous built-in trig function.</li>
</ul>

<p><code>max3(a, b, c)</code>: A function to find the largest of three numbers.</p>
<p>Parameters:</p>
<ul>
	<li><code>a, b, c</code> = Input values.</li>
</ul>

<p><code>min3(a, b, c)</code>: A function to find the smallest of three numbers.</p>
<p>Parameters:</p>
<ul>
	<li><code>a, b, c</code> = Input values.</li>
</ul>

<p><code>f_sqr(v)</code>: A function to square a number.</p>
<p>Parameters:</p>
<ul>
	<li><code>v</code> = Input value.</li>
</ul>

<p><code>sgn(v)</code>: A function to show the sign of the number. Returns -1 or 1 depending on the sign of v.</p>
<p>Parameters:</p>
<ul>
	<li><code>v</code> = Input value.</li>
</ul>

<p><code>clip(V, Min, Max)</code>: A function that limits a value to a specific range, if it goes outside that range it is <em>clipped</em>. Input values larger than <code>Max</code> will return <code>Max</code>, those less than <code>Min</code> will return <code>Min</code>.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input value.</li>
	<li><code>Min</code> = Minimum of output range.</li>
	<li><code>Max</code> = Maximum of output range.</li>
</ul>

<p><code>clamp(V, Min, Max)</code>: A function that limits a value to a specific range, if it goes outside that range it is <em>clamped</em> to this range, wrapping around. As the input increases or decreases outside the given range, the output will
repeatedly sweep through that range, making a <em>sawtooth</em> waveform.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input value.</li>
	<li><code>Min</code> = Minimum of output range.</li>
	<li><code>Max</code> = Maximum of output range.</li>
</ul>

<p><code>adj_range(V, Min, Max)</code>: A function that adjusts input values in the range [0, 1] to a given range. An input value of 0 will return <code>Min</code>, 1 will return <code>Max</code>, and values outside the [0, 1] range will be linearly extrapolated (the graph will continue in a straight line).</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input value.</li>
	<li><code>Min</code> = Minimum of output range.</li>
	<li><code>Max</code> = Maximum of output range.</li>
</ul>

<p><code>adj_range2(V, InMin, InMax, OutMin, OutMax)</code>: Like <code>adj_range()</code>, but adjusts input values in the range <code>[InMin, InMax]</code> to the range <code>[OutMin, OutMax]</code>.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input value.</li>
	<li><code>InMin</code> = Minimum of input range.</li>
	<li><code>InMax</code> = Maximum of input range.</li>
	<li><code>OutMin</code> = Minimum of output range.</li>
	<li><code>OutMax</code> = Maximum of output range.</li>
</ul>

</div>
<a name="r3_8_1_1_13_2"></a>
<div class="content-level-h6" contains="Vector functions and macros" id="r3_8_1_1_13_2">
<h6>3.8.1.1.13.2 Vector functions and macros</h6>
<p>These are all macros in the current version because functions can not take vector parameters, but this may change in the future.</p>
<p><code>VSqr(V)</code>: Square each individual component of a vector, equivalent to <code>V*V</code>.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Vector to be squared.</li>
</ul>

<p><code>VPow(V, P), VPow5D(V, P)</code>: Raise each individual component of a vector to a given power.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input vector.</li>
	<li><code>P</code> = Power.</li>
</ul>

<p><code>VEq(V1, V2)</code>: Tests for equal vectors, returns true if all three components of <code>V1</code>equal the respective components of <code>V2</code>.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, V2</code> = The vectors to be compared.</li>
</ul>

<p><code>VEq5D(V1, V2)</code>: A 5D version of <code>VEq()</code>. Tests for equal vectors, returns true if all 5 components of <code>V1 </code>equal the respective components of <code>V2</code>.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, V2</code> = The vectors to be compared.</li>
</ul>

<p><code>VZero(V)</code>: Tests for a &lt; 0, 0, 0&gt; vector.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input vector.</li>
</ul>

<p><code>VZero5D(V)</code>: Tests for a &lt; 0, 0, 0, 0, 0&gt; vector.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input vector.</li>
</ul>

<p><code>VLength5D(V)</code>: Computes the length of a 5D vector.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input vector.</li>
</ul>

<p><code>VNormalize5D(V)</code>: Normalizes a 5D vector.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input vector.</li>
</ul>

<p><code>VDot5D(V1, V2)</code>: Computes the dot product of two 5D vectors. See vdot() for more information on dot products.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input vector.</li>
</ul>

<p><code>VCos_Angle(V1, V2)</code>: Compute the cosine of the angle between two vectors.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, V2</code> = Input vectors.</li>
</ul>

<p><code>VAngle(V1, V2), VAngleD(V1, V2)</code>: Compute the angle between two vectors. <code>VAngle()</code> returns the angle in radians, <code>VAngleD()</code> in degrees.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, V2</code> = Input vectors.</li>
</ul>

<p><code>VRotation(V1, V2, Axis)</code> and <code>VRotationD(V1, V2, Axis)</code>: Compute the rotation angle from V1 to V2 around Axis. Axis should be perpendicular to both V1 and V2. The output will be in the range between -pi and pi radians or between -180 degrees and 180 degrees if you are using the degree version. However, if Axis is set to &lt;0,0,0&gt; the output will always be positive or zero, the same result you will get with the VAngle() macros.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, V2</code> = Input vectors.</li>
</ul>

<p><code>VDist(V1, V2)</code>: Compute the distance between two points.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, V2</code> = Input vectors.</li>
</ul>

<p><code>VPerp_To_Vector(V)</code>: Find a vector perpendicular to the given vector.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input vector.</li>
</ul>

<p><code>VPerp_To_Plane(V1, V2)</code>: Find a vector perpendicular to both given vectors. In other words, perpendicular to the plane defined by the two input vectors.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, V2</code> = Input vectors.</li>
</ul>

<p><code>VPerp_Adjust(V1, Axis)</code>: Find a vector perpendicular to Axis and in the plane of V1 and Axis. In other words, the new vector is a version of V1 adjusted to be perpendicular to Axis.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, Axis</code> = Input vectors.</li>
</ul>

<p><code>VProject_Plane(V1, Axis)</code>: Project vector V1 onto the plane defined by Axis.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1</code> = Input vectors.</li>
	<li><code>Axis</code> = Normal of the plane.</li>
</ul>

<p><code>VProject_Axis(V1, Axis)</code>: Project vector V1 onto the axis defined by Axis.</p>
<p>Parameters:</p>
<ul>
	<li><code>V1, Axis</code> = Input vectors.</li>
</ul>

<p><code>VMin(V), VMax(V)</code>: Find the smallest or largest component of a vector.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Input vector.</li>
</ul>

<p><code>VWith_Len(V, Len)</code>: Create a vector parallel to a given vector but with a given length.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = Direction vector.</li>
	<li><code>Len</code> = Length of desired vector.</li>
</ul>

</div>
<a name="r3_8_1_1_13_3"></a>
<div class="content-level-h6" contains="Vector Analysis" id="r3_8_1_1_13_3">
<h6>3.8.1.1.13.3 Vector Analysis</h6>
<p><code>SetGradientAccuracy(Value)</code>: All the macros below make use of a constant named <em>__Gradient_Fn_Accuracy_</em> for numerical approximation of the derivatives. This constant can be changed with the macro, the default value is 0.001.</p>

<p><code>fn_Gradient(Fn)</code>: A macro calculating the gradient of a function as a function.</p>
<p>Parameters:</p>
<ul>
<li><code>Fn</code> = function to calculate the gradient from.</li>
</ul>
<p>
Output: the length of the gradient as a function.
</p>

<p><code>fn_Gradient_Directional(Fn, Dir)</code>: A macro calculating the gradient of a function in one direction as a function.</p>
<p>Parameters:</p>
<ul>
<li><code>Fn</code> = function to calculate the gradient from.</li>
<li><code>Dir</code> = direction to calculate the gradient.</li>
</ul>
<p>
Output: the gradient in that direction as a function.
</p>

<p><code>fn_Divergence(Fnx, Fny, Fnz)</code>: A macro calculating the divergence of a (vector) function as a function.</p>
<p>Parameters:</p>
<ul>
<li><code>Fnx, Fny, Fnz</code>= x, y and z components of a vector function.</li>
</ul>
<p>
Output: the divergence as a function.
</p>

<p><code>vGradient(Fn, p0)</code>: A macro calculating the gradient of a function as a vector expression.</p>
<p>Parameters:</p>
<ul>
<li><code>Fn</code> = function to calculate the gradient from.</li>
<li><code>p0</code> = point where to calculate the gradient.</li>
</ul>
<p>
Output: the gradient as a vector expression.
</p>

<p><code>vCurl(Fnx, Fny, Fnz, p0)</code>: A macro calculating the curl of a (vector) function as a vector expression.</p>
<p>Parameters:</p>
<ul>
<li><code>Fnx, Fny, Fnz</code> = x, y and z components of a vector function.</li>
<li><code>p0</code> = point where to calculate the gradient.</li>
</ul>
<p>
Output: the curl as a vector expression
</p>

<p><code>Divergence(Fnx, Fny, Fnz, p0)</code>: A macro calculating the divergence of a (vector) function as a float expression.</p>
<p>Parameters:</p>
<ul>
<li><code>Fnx, Fny, Fnz</code> = x, y and z components of a vector function.</li>
<li><code>p0</code> = point where to calculate the gradient.</li>
</ul>
<p>
Output: the divergence as a float expression.
</p>

<p><code>Gradient_Length(Fn, p0)</code>: A macro calculating the length of the gradient of a function as a float expression.</p>
<p>Parameters:</p>
<ul>
<li><code>Fn</code> = function to calculate the gradient from.</li>
<li><code>p0</code> = point where to calculate the gradient.</li>
</ul>
<p>
Output: the length of the gradient as a float expression.
</p>

<p><code>Gradient_Directional(Fn, p0, Dir)</code>: A macro calculating the gradient of a function in one direction as a float expression.</p>
<p>Parameters:</p>
<ul>
<li><code>Fn</code> = function to calculate the gradient from.
<li><code>p0</code> = point where to calculate the gradient.
<li><code>Dir</code> = direction to calculate the gradient.
</ul>
<p>
Output: the gradient in that direction as a float expression
</p></div>

<a name="r3_8_1_1_14"></a>
<div class="content-level-h5" contains="Meshmaker.inc" id="r3_8_1_1_14">
<h5>3.8.1.1.14 Meshmaker.inc</h5>
 
<p>meshmaker.inc  -  various mesh2 objects by splines.</p>
<dl>
<dt><code>MSM(SplineArray, SplRes, Interp_type,  InterpRes, FileName)</code></dt>
	<dd>Generates a mesh2 from an array of splines and optionally writes the mesh2 object as a file of the given <code>FileName</code>.<br>
The uv_coordinates come from the square &lt;0,0&gt; - &lt;1,1&gt;.<br>
The spline is evaluated from t=0 to t=1. <br>
For the normal calculation, it is required that all splines (also linear_spline) have one extra
point before t=0 and after t=1.</dd>

<dt><code>BuildWriteMesh2(VecArr, NormArr, UVArr, U, V, FileName)</code></dt>
	<dd>Generates and optionally writes a mesh2 object based on 3 input arrays,
the number of quads in U and V direction and a filename.<br>
<code>VecArr</code>   : The array that contains the vertices of the triangles in the mesh.<br>
<code>NormArr</code>  : The array with the normal vectors that go with the vertices.<br>
<code>UVArr</code>    : The array containing the uv_vectors.<br>
<code>U</code>        : The amount of subdivisions of the surface in the u-direction.<br>
<code>V</code>        : The amount of subdivisions in the v-direction.<br>
Based on the U and V values the face_indices of the  triangles in the mesh are calculated.<br>
<code>FileName</code> : The name of the file to which the mesh will be written. 
If is an empty string (""), no file will be written.<br>
If the file extension is 'obj' a Wavefront objectfile will be written.<br>
If the extension is 'pcm' a compressed mesh file is written.<br>
If a file name is given, the macro will first check if it already exists.<br>
If that is so, it will try to parse the existing file unless it's a '*.obj', '*.pcm' or '*.arr' file as POV-Ray
can not read them directly. In this case a new mesh will be generated,
but the existing files will _not_ be over-written.</dd>

<dt><code>BuildSpline(Arr, SplType)</code></dt> 
	<dd>A helper macro for MSM()<br>
Generates from a array <code>Arr</code> a spline of the given spline type <code>SplType</code>.</dd>

<dt><code>CheckFileName(FileName)</code></dt> 
	<dd>A helper macro for MSM()<br>
If Return has a value of 0 the mesh will not be build,
but it will be parsed from file.</dd>

<dt><code>LInterpolate(Val, Min, Max)</code></dt> 
	<dd>A helper macro for MSM()<br>
Linear interpolation of a vector or float between <code>Min</code> and <code>Max</code>.<br>
<code>Min</code> : minimal float value or vector.<br>
<code>Max</code> : Maximal float value or vector.<br>
<code>Val</code> : A float in the range 0 - 1.</dd>

<dt><code>RangeMM()  = function(Val,Rmin,Rmax,Min,Max)</code></dt> 
	<dd>A helper function for MSM()<br>
Adjusts input values in the range [<code>RMin, RMax</code>] to fit in the range [Min, Max].
<code>Val</code>: A float value in the range [Rmin, Rmax].</dd>

<dt><code>Parametric(__F1__, __F2__, __F3__, UVmin, UVmax, Iter_U, Iter_V, FileName)</code></dt>
	<dd>Generates a mesh2 object from the parametric uv functions <code>__F1__, __F2__, __F3__</code>
in the ranges between <code>UVmin</code> and <code>UVmax</code> with the iteration steps

<code>Iter_U</code> and <code>Iter_V</code> and optionally saves the mesh2 object as a file with the name <code>FileName</code>.</dd>

<dt><code>Paramcalc(UVmin, UVmax, Iter_U, Iter_V, FileName)</code></dt>
	<dd>The kernel of the macro Parametric(). See <code>Parametric()</code>.</dd>

<dt><code> Prism1(Spl, ResSpl, PSpl, PRes, FileName)</code></dt>
	<dd>Generates a mesh2 object by extruding the spline <code>Spl</code> along the y-axis with the resolution spline <code>ResSpl</code>.
In every step the spline is scaled by the 'relative' distance from the
y-axis of the second spline (PSpl).<br>
The uv_coordinates come from the square &lt;0,0&gt; - &lt;1,1&gt;.<br>
<code>Spl</code>  : The spline to be extruded.<br>
The spline is evaluated from t=0 to t=1. For the normal calculation,<br>
it is required that all splines (also linear_spline) have one extra<br>
point before t=0 and after t=1.
<code>ResSpl</code>  : The amount of triangles to be used along the spline.
<code>PSpl</code>    : The spline that determines by what amount the extrusion<br>
is scaled in each step. The scaling is based on the relative distance from the y-axis.<br>
That is, at t=0 the scale is always 1, so that the start of the shape is<br>
identical to the spline <code>Spl</code>.<br>
PSpl also sets the height of the resulting shape (its y-value at t=1).<br>
The spline is evaluated from t=0 to t=1. For the normal calculation,<br>
it is required that all splines (also linear_spline) have one extra <br>
point before t=0 and after t=1. <br>
<code>FileName</code> : The name of the file to which the mesh will be written.<br>
If is an empty string (""), no file will be written. If a file name is given, the macro <br>
will first check if it already exists. If that is so, it will expect a <br>
mesh2 with the name "Surface" and try to parse the existing file.<br>

<dt><code>Lathe(Spl, ResSpl, Rot, ResRot, FileName)</code></dt>
	<dd>This  macro generates a mesh2 object by rotating a two-dimensional curve about the y-axis.<br>
The uv_coordinates come from the square &lt;0,0&gt; - &lt;1,1&gt;.<br>
<code>Spl</code>      : The spline to be rotated.
The spline is evaluated from t=0 to t=1. For the normal calculation,
it is required that all splines (also linear_spline) have one extra
point before t=0 and after t=1.
<code>ResSpl</code>   : The amount of triangles to be used along the spline.
<code>Rot</code>      : The angle the spline has to be rotated.<br>
<code>ResRot</code>   : The amount of triangles to be used in the circumference.<br>
<code>FileName</code> : The name of the file to which the mesh will be written.<br>
If is an  empty string (""), no file will be written.<br>
If the file extension is 'obj' a Wavefront objectfile will be written.<br>
If the extension is 'pcm' a compressed mesh file is written.<br>
If a file name is given, the macro will first check if it already exists.<br>
If that is so, it will try to parse the existing file unless it's a '*.obj', <br>
'*.pcm' or '*.arr' file as POV-Ray can not read them directly. In this case a new <br>
mesh will be generated, but the existing files will _not_ be over-written. </dd>

<dt><code>Coons(Spl1, Spl2, Spl3, Spl4, Iter_U, Iter_V, FileName)</code></dt>
	<dd>Generates a mesh2 'coons surface' defined by four splines, all attached head to tail to the previous / next one.<br>
The uv_coordinates come from the square &lt;0,0&gt; - &lt;1,1&gt;.<br>
<code>Spl1 - 4</code> : The four spline that define the surface.<br>
The splines are evaluated from t=0 to t=1. <br>
<code>Iter_U</code>   : The resolution for the splines 1 and 3.<br>
<code>Iter_V</code>   : The resolution for the splines 2 and 4.<br>
<code>FileName</code> : The name of the file to which the mesh will be written.<br>
If is an empty string (""), no file will be written.<br>
If the file extension is 'obj' a Wavefront objectfile will be written.<br>
If the extension is 'pcm' a compressed mesh file is written.<br>
If a file name is given, the macro will first check if it already exists.<br>
If that is so, it will try to parse the existing file unless it's a '*.obj',<br>
'*.pcm' or '*.arr' file as POV-Ray can not read them directly. In this case a new<br>
mesh will be generated, but the existing files will _not_ be over-written.</dd>

<dt><code>TwoVarSurf(__Fuv, Urange, Vrange, Iter_U, Iter_V, FileName)</code></dt>
	<dd>Generates a mesh2 object by extruding an uv-function.
<code>Urange</code>   : The range in x direction.<br>
<code>Vrange</code>   : The range in y direction.<br>
<code>Iter_U</code>   : The resolution in x direction.<br>
<code>Iter_V</code>   : The resolution in y direction.<br>
<code>FileName</code> : The name of the file to which the mesh will be written.<br>
If is an empty string (""), no file will be written. If a file name is given, the macro <br>
will first check if it already exists. If that is so, it will expect a <br>
mesh2 with the name "Surface" and try to parse the existing file.</dd>

<dt><code>SweepSpline1(Track,Shape,Waist,U,V,Filename)</code></dt>
	<dd>Generates a mesh2 object by extruding a spline <code>Shape</code> along <code>Track</code>
and optionally writes it as a file with method 1.<br>
<code>FileName</code> : The name of the file to which the mesh will be written.
If is an empty string (""), no file will be written. If a file name is given, the macro <br>
will first check if it already exists. If that is so, it will expect a <br>
mesh2 with the name "Surface" and try to parse the existing file.</dd>
<dt><code>SweepSpline2(Track,Shape,Waist,U,V,Filename)</code></dt>
	<dd>Generates a mesh2 object by extruding a spline <code>Shape</code> along <code>Track</code>
and optionally writes it as a file with method 2.<br>
<code>FileName</code> : The name of the file to which the mesh will be written.
If is an empty string (""), no file will be written. If a file name is given, the macro <br>
will first check if it already exists. If that is so, it will expect a <br>
mesh2 with the name "Surface" and try to parse the existing file.</dd>
<br>

</dl></div>

<a name="r3_8_1_1_15"></a>
<div class="content-level-h5" contains="Metals.inc" id="r3_8_1_1_15">
<h5>3.8.1.1.15 Metals.inc</h5>

<p>These files define several metal textures. The file metals.inc contains copper, silver, chrome, and brass textures, and golds.inc contains the gold textures. Rendering the demo files will come in useful in using these textures.</p>

<p><strong>Pigments:</strong></p>
	<dl>
		<dt><code>P_Brass1</code></dt>
			<dd>Dark brown bronze.</dd>
		
		<dt><code>P_Brass2</code></dt>
			<dd>Somewhat lighter brown than Brass4. Old penny, in soft finishes.</dd>
		
		<dt><code>P_Brass3</code></dt>
			<dd>Used by Steve Anger's Polished_Brass. Slightly coppery.</dd>
		
		<dt><code>P_Brass4</code></dt>
			<dd>A little yellower than Brass1.</dd>
		
		<dt><code>P_Brass5</code></dt>
			<dd>Very light bronze, ranges from med tan to almost white.</dd>
	</dl>	
	<dl>	
		<dt><code>P_Copper1</code></dt>
			<dd>Bronze-like.  Best in finish #C.</dd>
		
		<dt><code>P_Copper2</code></dt>
			<dd>Slightly brownish copper/bronze.  Best in finishes #B-#D.</dd>
		
		<dt><code>P_Copper3</code></dt>
			<dd>Reddish-brown copper.  Best in finishes #C-#E.</dd>
		
		<dt><code>P_Copper4</code></dt>
			<dd>Pink copper, like new tubing.  Best in finishes #C-#E.</dd>
		
		<dt><code>P_Copper5</code></dt>
			<dd>Bronze in softer finishes, gold in harder finishes.</dd>
	</dl>
	<dl>
		<dt><code>P_Chrome1</code></dt>
			<dd>20% Gray. Used in Steve Anger's Polished_Chrome.</dd>
		
		<dt><code>P_Chrome2</code></dt>
			<dd>Slightly blueish 60% gray. Good steel w/finish #A.</dd>
		
		<dt><code>P_Chrome3</code></dt>
			<dd>50% neutral gray.</dd>
		
		<dt><code>P_Chrome4</code></dt>
			<dd>75% neutral gray.</dd>
		
		<dt><code>P_Chrome5</code></dt>
			<dd>95% neutral gray.</dd>
	</dl>
	<dl>	
		<dt><code>P_Silver1</code></dt>
			<dd>Yellowish silverplate.  Somewhat tarnished looking.</dd>
		
		<dt><code>P_Silver2</code></dt>
			<dd>Not quite as yellowish as Silver1 but more so than Silver3.</dd>
		
		<dt><code>P_Silver3</code></dt>
			<dd>Reasonably neutral silver.</dd>
		
		<dt><code>P_Silver4</code></dt>
		
		<dt><code>P_Silver5</code></dt>
	</dl>

<p><strong>Finishes:</strong></p>
	<dl>
		<dt><code>F_MetalA</code></dt>
			<dd>Very soft and dull.</dd>
		
		<dt><code>F_MetalB</code></dt>
			<dd>Fairly soft and dull.</dd>
		
		<dt><code>F_MetalC</code></dt>
			<dd>Medium reflectivity. Holds color well.</dd>
		
		<dt><code>F_MetalD</code></dt>
			<dd>Very hard and highly polished. High reflectivity.</dd>
		
		<dt><code>F_MetalE</code></dt>
			<dd>Very highly polished and reflective.</dd>
	</dl>

<p><strong>Textures:</strong></p>
	<dl>
		<dt><code>T_Brass_1A to T_Brass_5E</code></dt>
		<dt><code>T_Copper_1A to T_Copper_5E</code></dt>
		<dt><code>T_Chrome_1A to T_Chrome_5E</code></dt>
		<dt><code>T_Silver_1A to T_Silver_5E</code></dt>
	</dl></div>

<a name="r3_8_1_1_16"></a>
<div class="content-level-h5" contains="Rad_def.inc" id="r3_8_1_1_16">
<h5>3.8.1.1.16 Rad_def.inc</h5>

<p>This file defines a macro that sets some common radiosity settings. These settings are extremely general and are intended for ease of use, and do not necessarily give the best results.</p>
<p>Usage:</p>
<pre>
#include &quot;rad_def.inc&quot;
global_settings {
  ...
  radiosity {
    Rad_Settings(Setting, Normal, Media)
    }
  }
</pre>

<p>Parameters:</p>
<ul>
	<li>Setting = Quality setting. Use one of the predefined constants:</li>
		<ul>
			<li>Radiosity_Default</li>
			<li>Radiosity_Debug</li>
			<li>Radiosity_Fast</li>
			<li>Radiosity_Normal</li>
			<li>Radiosity_2Bounce</li>
			<li>Radiosity_Final</li>
			<li>Radiosity_OutdoorLQ</li>
			<li>Radiosity_OutdoorHQ</li>
			<li>Radiosity_OutdoorLight</li>
			<li>Radiosity_IndoorLQ</li>
			<li>Radiosity_IndoorHQ</li>
		</ul>
	<li>Normal = Boolean value, whether or not to use surface normal modifiers for radiosity samples.</li>
	<li>Media = Boolean value, whether or not to calculate media for radiosity samples.</li>
</ul></div>

<a name="r3_8_1_1_17"></a>
<div class="content-level-h5" contains="Rand.inc" id="r3_8_1_1_17">
<h5>3.8.1.1.17 Rand.inc</h5>

<p>A collection of macros for generating random numbers, as well as 4 predefined random number streams: <code>RdmA, RdmB, RdmC,</code> and <code>RdmD</code>. There are macros for creating random numbers in a flat distribution (all numbers equally likely) in various ranges, and a variety of other distributions.</p>

</div>
<a name="r3_8_1_1_17_1"></a>
<div class="content-level-h6" contains="Flat Distributions" id="r3_8_1_1_17_1">
<h6>3.8.1.1.17.1 Flat Distributions</h6>
<p><code>SRand(Stream)</code>: <em>Signed rand()</em>, returns random numbers in the range [-1, 1].</p>
<p>Parameters:</p>
<ul>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>RRand(Min, Max, Stream)</code>: Returns random numbers in the range [Min, Max].</p>
<p>Parameters:</p>
<ul>
	<li><code>Min</code> = The lower end of the output range.</li>
	<li><code>Max</code> = The upper end of the output range.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>VRand(Stream)</code>: Returns random vectors in a box from &lt; 0, 0, 0&gt; to &lt; 1, 1, 1&gt;</p>
<p>Parameters:</p>
<ul>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>VRand_In_Box(PtA, PtB, Stream)</code>: Like VRand(), this macro returns a random vector in a box, but this version lets you specify the two corners of the box.</p>
<p>Parameters:</p>
<ul>
	<li><code>PtA</code> = Lower-left-bottom corner of box.</li>
	<li><code>PtB</code> = Upper-right-top corner of box.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>VRand_In_Sphere(Stream)</code>: Returns a random vector in a unit-radius sphere located at the origin.</p>
<p>Parameters:</p>
<ul>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>VRand_On_Sphere(Stream)</code>: Returns a random vector on the surface of a unit-radius sphere located at the origin.</p>
<p>Parameters:</p>
<ul>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>VRand_In_Obj(Object, Stream)</code>: This macro takes a solid object and returns a random point that is inside it. It does this by randomly sampling the bounding box of the object, and can be quite slow if the object occupies a small percentage of the volume of its bounding box (because it will take more attempts to find a point inside the object). This macro is best used on finite, solid objects (non-solid objects, such as meshes and bezier patches, do not have a defined <em>inside</em>, and will not work).</p>
<p>Parameters:</p>
<ul>
	<li><code>Object</code> = The object the macro chooses the points from.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>

</div>
<a name="r3_8_1_1_17_2"></a>
<div class="content-level-h6" contains="Other Distributions" id="r3_8_1_1_17_2">
<h6>3.8.1.1.17.2 Other Distributions</h6>

</div>
<a name="r3_8_1_1_17_3"></a>
<div class="content-level-h6" contains="Continuous Symmetric Distributions" id="r3_8_1_1_17_3">
<h6>3.8.1.1.17.3 Continuous Symmetric Distributions</h6>
<p><code>Rand_Cauchy(Mu, Sigma, Stream)</code>: Cauchy distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>Mu</code> = Mean.</li>
	<li><code>Sigma</code> = Standard deviation.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Student(N, Stream)</code>: Student's distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>N</code> = degrees of freedom.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Normal(Mu, Sigma, Stream)</code>: Normal distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>Mu</code> = Mean.</li>
	<li><code>Sigma</code> = Standard deviation.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Gauss(Mu, Sigma, Stream)</code>: Gaussian distribution. Like Rand_Normal(), but a bit faster.</p>
<p>Parameters:</p>
<ul>
	<li><code>Mu</code> = Mean.</li>
	<li><code>Sigma</code> = Standard deviation.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>

</div>
<a name="r3_8_1_1_17_4"></a>
<div class="content-level-h6" contains="Continuous Skewed Distributions" id="r3_8_1_1_17_4">
<h6>3.8.1.1.17.4 Continuous Skewed Distributions</h6>
<p><code>Rand_Spline(Spline, Stream)</code>: This macro takes a spline describing the desired distribution. The T value of the spline is the output value, and the .y value its chance of occuring.</p>
<p>Parameters:</p>
<ul>
	<li><code>Spline</code> = A spline determining the distribution.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Gamma(Alpha, Beta, Stream)</code>: Gamma distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>Alpha</code> = Shape parameter &gt; 0.</li>
	<li><code>Beta</code> = Scale parameter &gt; 0.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Beta(Alpha, Beta, Stream)</code>: Beta variate.</p>
<p>Parameters:</p>
<ul>
	<li><code>Alpha</code> = Shape Gamma1.</li>
	<li><code>Beta</code> = Scale Gamma2.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Chi_Square(N, Stream)</code>: Chi Square random variate.</p>
<p>Parameters:</p>
<ul>
	<li><code>N</code> = Degrees of freedom (integer).</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_F_Dist(N, M, Stream)</code>: F-distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>N, M</code> = Degrees of freedom.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Tri(Min, Max, Mode, Stream)</code>: Triangular distribution </p>
<p>Parameters:</p>
<ul>
	<li><code>Min, Max, Mode</code>: Min &lt; Mode &lt; Max.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Erlang(Mu, K, Stream)</code>: Erlang variate.</p>
<p>Parameters:</p>
<ul>
	<li><code>Mu</code> = Mean &gt;= 0.</li>
	<li><code>K</code> = Number of exponential samples.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Exp(Lambda, Stream)</code>: Exponential distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>Lambda</code> = rate = 1/mean.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Lognormal(Mu, Sigma, Stream)</code>: Lognormal distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>Mu</code> = Mean.</li>
	<li><code>Sigma</code> = Standard deviation.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Pareto(Alpha, Stream)</code>: Pareto distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>Alpha</code> = ?</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Weibull(Alpha, Beta, Stream)</code>: Weibull distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>Alpha</code> = ?</li>
	<li><code>Beta</code> = ?</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>

</div>
<a name="r3_8_1_1_17_5"></a>
<div class="content-level-h6" contains="Discrete Distributions " id="r3_8_1_1_17_5">
<h6>3.8.1.1.17.5 Discrete Distributions </h6>
<p><code>Rand_Bernoulli(P, Stream)</code> and <code>Prob(P, Stream)</code>: Bernoulli distribution. Output is true with probability equal to the value of P and false with a probability of 1 - P.</p>
<p>Parameters:</p>
<ul>
	<li><code>P</code> = probability range (0-1).</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Binomial(N, P, Stream)</code>: Binomial distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>N</code> = Number of trials.</li>
	<li><code>P</code> = Probability (0-1)</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Geo(P, Stream)</code>: Geometric distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>P</code> = Probability (0-1).</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul>
	
<p><code>Rand_Poisson(Mu, Stream)</code>: Poisson distribution.</p>
<p>Parameters:</p>
<ul>
	<li><code>Mu</code> = Mean.</li>
	<li><code>Stream</code> = Random number stream.</li>
</ul></div>

<a name="r3_8_1_1_18"></a>
<div class="content-level-h5" contains="Screen.inc" id="r3_8_1_1_18">
<h5>3.8.1.1.18 Screen.inc</h5>

<p>Screen.inc will enable you to place objects and textures right in front of the camera. When you move the camera, the objects placed with screen.inc will follow the movement and stay in the same position on the screen. One use of this is to place your signature or a logo in the corner of the image.</p>

<p>You can only use screen.inc with the perspective camera. Screen.inc will automatically create a default camera definition for you when it is included. All aspects of the camera can than be changed, by invoking the appropriate 'Set_Camera_...' macros in your scene. After calling these setup macros you can use the macros Screen_Object and Screen_Plane.</p>

<p class="Note"><strong>Note:</strong> Even though objects aligned using screen.inc follow the camera, they are still part of the scene. That means that they will be affected by perspective, lighting, the surroundings etc.</p>

<p>For an example of use, see the screen.pov demo file.</p>

<p><code>Set_Camera_Location(Loc)</code>: Changes the position of the default camera to a new location as specified by the <code>Loc</code> vector.</p>

<p><code>Set_Camera_Look_At(LookAt)</code>: Changes the position the default camera looks at to a new location as specified by the <code>LookAt</code> vector.</p>

<p><code>Set_Camera_Aspect_Ratio(Aspect)</code>: Changes the default aspect ratio, <code>Aspect</code> is a float value, usually width divided by the height of the image.</p>

<p><code>Set_Camera_Aspect(Width,Height)</code>: Changes the default aspect ratio of the camera.</p>

<p><code>Set_Camera_Sky(Sky)</code>: Sets a new Sky-vector for the camera.</p>

<p><code>Set_Camera_Zoom(Zoom)</code>: The amount to zoom in or out, <code>Zoom</code> is a float.</p>

<p><code>Set_Camera_Angle(Angle)</code>: Sets a new camera angle.</p>

<p><code>Set_Camera(Location, LookAt, Angle)</code>: Set <code>location</code>, <code>look_at</code> and <code>angle</code> in one go.</p>

<p><code>Reset_Camera()</code>: Resets the camera to its default values.</p>

<p><code>Screen_Object (Object, Position, Spacing, Confine, Scaling)</code>: Puts an object in front of the camera.</p>
<p>Parameters:</p>
<ul>
	<li><code>Object</code> = The object to place in front of the screen.</li>
	<li><code>Position</code> = UV coordinates for the object. &lt;0,0&gt; is lower left corner of the screen and &lt;1,1&gt; is upper right corner.</li>
	<li><code>Spacing</code> = Float describing minimum distance from object to the borders. UV vector can be used to get different horizontal and vertical spacing.</li>
	<li><code>Confine</code> = Set to true to confine objects to visible screen area. Set to false to allow objects to be outside visible screen area.</li>
	<li><code>Scaling</code> = If the object intersects or interacts with the scene, try to move it closer to the camera by decreasing Scaling.</li>
</ul>
<p><code>Screen_Plane (Texture, Scaling, BLCorner, TRCorner)</code>: Screen_Plane is a macro that will place a texture of your choice on a plane right in front of the camera.</p>
<p>Parameters:</p>
<ul> 
	<li><code>Texture  </code> = The texture to be displayed on the camera plane. &lt;0,0,0&gt; is lower left corner and &lt;1,1,0&gt; is upper right corner.</li>
	<li><code>Scaling  </code> = If the plane intersects or interacts with the scene, try to move it closer to the camera by decreasing Scaling.</li>
	<li><code>BLCorner </code> = The bottom left corner of the Screen_Plane.</li>
	<li><code>TRCorner </code> = The top right corner of the Screen_Plane.</li>
</ul></div>

<a name="r3_8_1_1_19"></a>
<div class="content-level-h5" contains="Shapes.inc" id="r3_8_1_1_19">
<h5>3.8.1.1.19 Shapes.inc</h5>

<p>These files contain predefined shapes and shape-generation macros.</p>
<p><em>shapes.inc</em> includes <em>shapes_old.inc</em> and contains many macros for working
with objects, and for creating special objects, such as bevelled text, spherical height fields,
and rounded shapes.</p>
<p>Many of the objects in <em>shapes_old.inc</em> are not very useful in the newer versions of
POV-Ray, and are kept for backwards compatability with old scenes written for versions of POV-Ray
that lacked primitives like cones, disks, planes, etc.</p>
<p>The file <em>shapes2.inc</em> contains some more useful shapes, including regular polyhedrons,
and <em>shapesq.inc</em> contains several quartic and cubic shape definitions.</p>
<p>Some of the shapes in <em>shapesq.inc</em> would be much easier to generate, more flexible,
and possibly faster rendering as isosurfaces, but are still useful for two reasons: backwards
compatability, and the fact that isosurfaces are always finite.</p>
<p><code>Isect(Pt, Dir, Obj, OPt)</code> and <code>IsectN(Pt, Dir, Obj, OPt, ONorm)</code>: These macros are interfaces to the trace() function. Isect() only returns the intersection point, IsectN() returns the surface normal as well. These macros return the point and normal information through their parameters, and true or false depending on whether an intersection was found: If an intersection is found, they return true and set OPt to the intersection point, and ONorm to the normal. Otherwise they return false, and do not modify OPt or ONorm.</p>
<p>Parameters:</p>
<ul>
	<li><code>Pt</code> = The origin (starting point) of the ray.</li>
	<li><code>Dir</code> = The direction of the ray.</li>
	<li><code>Obj</code> = The object to test for intersection with.</li>
	<li><code>OPt</code> = A declared variable, the macro will set this to the intersection point.</li>
	<li><code>ONorm</code> = A declared variable, the macro will set this to the surface normal at the intersection point.</li>
</ul>

<p><code>Extents(Obj, Min, Max)</code>: This macro is a shortcut for calling both min_extent() and max_extent() to get the corners of the bounding box of an object. It returns these values through the Min and Max parameters.</p>
<p>Parameters:</p>
<ul>
	<li><code>Obj</code> = The object you are getting the extents of.</li>
	<li><code>Min</code> = A declared variable, the macro will set this to the min_extent of the object.</li>
	<li><code>Max</code> = A declared variable, the macro will set this to the max_extent of the object.</li>
</ul>

<p><code>Center_Object(Object, Axis)</code>: A shortcut for using the Center_Trans() macro with an object.</p>
<p>Parameters:</p>
<ul>
	<li><code>Object</code> = The object to be centered.</li>
	<li><code>Axis</code> = See Center_Trans() in the transforms.inc documentation.</li>
</ul>

<p><code>Align_Object(Object, Axis, Pt)</code>: A shortcut for using the <a href="r3_8.html#r3_8_1_1_30">Align_Trans()</a> macro with an object.</p>
<p>Parameters:</p>
<ul>
	<li><code>Object</code> = The object to be aligned.</li>
	<li><code>Axis</code> = See Align_Trans() in the transforms.inc documentation.</li>
	<li><code>Point</code> = The point to which to align the bounding box of the object. </li>
</ul>

<p><code>Bevelled_Text(Font, String, Cuts, BevelAng, BevelDepth, Depth, Offset, UseMerge)</code>: This macro attempts to <em>bevel</em> the front edges of a text object. It accomplishes this by making an intersection of multiple copies of the text object, each sheared in a different direction. The results are no perfect, but may be entirely acceptable for some purposes. Warning: the object generated may render considerably more slowly than an ordinary text object.</p>
<p>Parameters:</p>
<ul>
	<li><code>Font</code> = A string specifying the font to use.</li>
	<li><code>String</code> = The text string the object is generated from.</li>
	<li><code>Cuts</code> = The number of intersections to use in bevelling the text. 
 More cuts give smoother results, but take more memory and are slower rendering.</li>
	<li><code>BevelAng</code> = The angle of the bevelled edge.</li>
	<li><code>BevelDepth</code> = The thickness of the bevelled portion.</li>
	<li><code>Depth</code> = The total thickness of the resulting text object.</li>
	<li><code>Offset</code> = The offset parameter for the text object. The z value 
of this vector will be ignored, because the front faces of all the letters need 
to be coplanar for the bevelling to work.</li>
	<li><code>UseMerge</code> = Switch between merge (1) and union (0).</li>
</ul>

<p><code>Text_Space(Font, String, Size, Spacing)</code>: Computes the width of a text string, including <em>white space</em>, it returns the advance widths of all n letters. Text_Space gives the space a text, or a glyph, occupies in regard to its surroundings.</p>
<p>Parameters:</p>
<ul>
	<li><code>Font</code> = A string specifying the font to use.</li>
	<li><code>String</code> = The text string the object is generated from.</li>
	<li><code>Size</code> = A scaling value.</li>
	<li><code>Spacing</code> = The amount of space to add between the characters.</li>
</ul>

<p><code>Text_Width(Font, String, Size, Spacing)</code>: Computes the width of a text string, it returns the advance widths of the first n-1 letters, plus the glyph width of the last letter. Text_Width gives the <em>physical</em> width of the text and if you use only one letter the <em>physical</em> width of one glyph.</p>
<p>Parameters:</p>
<ul>
	<li><code>Font</code> = A string specifying the font to use.</li>
	<li><code>String</code> = The text string the object is generated from.</li>
	<li><code>Size</code> = A scaling value.</li>
	<li><code>Spacing</code> = The amount of space to add between the characters.</li>
</ul>

<p><code>Align_Left, Align_Right, Align_Center</code>: These constants are used by the
<code>Circle_Text()</code> macro.
</p>

<p><code>Circle_Text(Font, String, Size, Spacing, Depth, Radius, Inverted, Justification, Angle)</code>: Creates a text object with the bottom (or top) of the character cells aligned with all or part of a circle. This macro should be used inside an <code>object{...}</code> block.</p>
<p>Parameters:</p>
	<ul>
		<li><code>Font</code> = A string specifying the font to use.</li>
		<li><code>String</code> = The text string the object is generated from.</li>
		<li><code>Size</code> = A scaling value.</li>
		<li><code>Spacing</code> = The amount of space to add between the characters.</li>
		<li><code>Depth</code> = The thickness of the text object.</li>
		<li><code>Radius</code> = The radius of the circle the letters are aligned to.</li>
		<li><code>Inverted</code> = Controls what part of the text faces <em>outside</em>. 
      If this parameter is nonzero, the tops of the letters will point toward the center 
      of the circle.  Otherwise, the bottoms of the letters will do so.</li>
		<li><code>Justification</code> = Align_Left, Align_Right, or Align_Center.</li>
		<li><code>Angle</code> = The point on the circle from which rendering will begin. The +x
      direction is 0 and the +y direction is 90 (i.e. the angle increases
      anti-clockwise).</li>
	</ul>

<p><code>Wedge(Angle)</code>: This macro creates an infinite wedge shape, an intersection of two planes. It is mainly useful in CSG, for example to obtain a specific arc of a torus. The edge of the wedge is positioned along the y axis, and one side is fixed to the zy plane, the other side rotates clockwise around the y axis.</p>
<p>Parameters:</p>
<ul>
	<li><code>Angle</code> = The angle, in degrees, between the sides of the wedge shape.</li>
</ul>

<p><code>Spheroid(Center, Radius)</code>: This macro creates an unevenly scaled sphere. Radius is a vector where each component is the radius along that axis.</p>
<p>Parameters:</p>
<ul>
	<li><code>Center</code> = Center of the spheroid.</li>
	<li><code>Radius</code> = A vector specifying the radii of the spheroid.</li>
</ul>

<p><code>Supertorus(MajorRadius, MinorRadius, MajorControl, MinorControl, Accuracy, MaxGradient)</code>: This macro creates an isosurface of the torus equivalent of a superellipsoid. If you specify a MaxGradient of less than 1, evaluate will be used. You will have to adjust MaxGradient to fit the parameters you choose, a squarer supertorus will have a higher gradient. You may want to use the function alone in your own isosurface.</p>
<p>Parameters:</p>
<ul>
	<li><code>MajorRadius, MinorRadius</code> = Base radii for the torus.</li>
	<li><code>MajorControl, MinorControl</code> = Controls for the roundness of the supertorus. Use numbers in the range [0, 1].</li>
	<li><code>Accuracy</code> = The accuracy parameter.</li>
	<li><code>MaxGradient</code> = The max_gradient parameter.</li>
</ul>

<p><code>Supercone(EndA, A, B, EndB, C, D)</code>: This macro creates an object similar to a cone, but where the end points are ellipses. The actual object is an intersection of a quartic with a cylinder.</p>
<p>Parameters:</p>
<ul>
	<li><code>EndA</code> = Center of end A.</li>
	<li><code>A, B</code> = Controls for the radii of end A.</li>
	<li><code>EndB</code> = Center of end B.</li>
	<li><code>C, D</code> = Controls for the radii of end B.</li>
</ul>

<p><code>Connect_Spheres(PtA, RadiusA, PtB, RadiusB)</code>: This macro creates a cone that will smoothly join two spheres. It creates only the cone object, however, you will have to supply the spheres yourself or use the Round_Cone2() macro instead.</p>
<p>Parameters:</p>
<ul>
	<li><code>PtA</code> = Center of sphere A.</li>
	<li><code>RadiusA</code> = Radius of sphere A.</li>
	<li><code>PtB</code> = Center of sphere B.</li>
	<li><code>RadiusB</code> = Radius of sphere B.</li>
</ul>

<p><code>Wire_Box_Union(PtA, PtB, Radius)</code>,</p>
<p><code>Wire_Box_Merge(PtA, PtB, Radius)</code>,</p>
<p><code>Wire_Box(PtA, PtB, Radius, UseMerge)</code>: Creates a wire-frame box from cylinders and spheres. The resulting object will fit entirely within a box object with the same corner points.</p>
<p>Parameters:</p>
<ul>
	<li><code>PtA</code> = Lower-left-front corner of box.</li>
	<li><code>PtB</code> = Upper-right-back corner of box.</li>
	<li><code>Radius</code> = The radius of the cylinders and spheres composing the object.</li>
	<li><code>UseMerge</code> = Whether or not to use a merge.</li>
</ul>

<p><code>Round_Box_Union(PtA, PtB, EdgeRadius)</code>,</p>
<p><code>Round_Box_Merge(PtA, PtB, EdgeRadius)</code>,</p>
<p><code>Round_Box(PtA, PtB, EdgeRadius, UseMerge)</code>: Creates a box with rounded edges from boxes, cylinders and spheres. The resulting object will fit entirely within a box object with the same corner points. The result is slightly different from a superellipsoid, which has no truely flat areas.</p>
<p>Parameters:</p>
<ul>
	<li><code>PtA</code> = Lower-left-front corner of box.</li>
	<li><code>PtB</code> = Upper-right-back corner of box.</li>
	<li><code>EdgeRadius</code> = The radius of the edges of the box.</li>
	<li><code>UseMerge</code> = Whether or not to use a merge.</li>
</ul>

<p><code>Round_Cylinder_Union(PtA, PtB, Radius, EdgeRadius)</code>,</p>
<p><code>Round_Cylinder_Merge(PtA, PtB, Radius, EdgeRadius)</code>,</p>
<p><code>Round_Cylinder(PtA, PtB, Radius, EdgeRadius, UseMerge)</code>: Creates a cylinder with rounded edges from cylinders and tori. The resulting object will fit entirely within a cylinder object with the same end points and radius. The result is slightly different from a superellipsoid, which has no truely flat areas.</p>
<p>Parameters:</p>
<ul>
	<li><code>PtA, PtB</code> = The end points of the cylinder.</li>
	<li><code>Radius</code> = The radius of the cylinder.</li>
	<li><code>EdgeRadius</code> = The radius of the edges of the cylinder.</li>
	<li><code>UseMerge</code> = Whether or not to use a merge.</li>
</ul>

<p><code>Round_Cone_Union(PtA, RadiusA, PtB, RadiusB, EdgeRadius)</code>,</p>
<p><code>Round_Cone_Merge(PtA, RadiusA, PtB, RadiusB, EdgeRadius)</code>,</p>
<p><code>Round_Cone(PtA, RadiusA, PtB, RadiusB, EdgeRadius, UseMerge)</code>: Creates a cone with rounded edges from cones and tori. The resulting object will fit entirely within a cone object with the same end points and radii.</p>
<p>Parameters:</p>
<ul>
	<li><code>PtA, PtB</code> = The end points of the cone.</li>
	<li><code>RadiusA, RadiusB</code> = The radii of the cone.</li>
	<li><code>EdgeRadius</code> = The radius of the edges of the cone.</li>
	<li><code>UseMerge</code> = Whether or not to use a merge.</li>
</ul>

<p><code>Round_Cone2_Union(PtA, RadiusA, PtB, RadiusB)</code>,</p>
<p><code>Round_Cone2_Merge(PtA, RadiusA, PtB, RadiusB)</code>,</p>
<p><code>Round_Cone2(PtA, RadiusA, PtB, RadiusB, UseMerge)</code>: Creates a cone with rounded edges from a cone and two spheres. The resulting object will not fit entirely within a cone object with the same end points and radii because of the spherical caps. The end points are not used for the conical portion, but for the spheres, a suitable cone is then generated to smoothly join them.</p>
<p>Parameters:</p>
<ul>
	<li><code>PtA, PtB</code> = The centers of the sphere caps.</li>
	<li><code>RadiusA, RadiusB</code> = The radii of the sphere caps.</li>
	<li><code>UseMerge</code> = Whether or not to use a merge.</li>
</ul>

<p><code>Round_Cone3_Union(PtA, RadiusA, PtB, RadiusB)</code>,</p>
<p><code>Round_Cone3_Merge(PtA, RadiusA, PtB, RadiusB)</code>,</p>
<p><code>Round_Cone3(PtA, RadiusA, PtB, RadiusB, UseMerge)</code>: Like Round_Cone2(), this creates a cone with rounded edges from a cone and two spheres, and the resulting object will not fit entirely within a cone object with the same end points and radii because of the spherical caps. The difference is that this macro takes the end points of the conical portion and moves the spheres to be flush with the surface, instead of putting the spheres at the end points and generating a cone to join them.</p>
<p>Parameters:</p>
<ul>
	<li><code>PtA, PtB</code> = The end points of the cone.</li>
	<li><code>RadiusA, RadiusB</code> = The radii of the cone.</li>
	<li><code>UseMerge</code> = Whether or not to use a merge.</li>
</ul>

<p><code>Quad(A, B, C, D)</code> and <code>Smooth_Quad(A, NA, B, NB, C, NC, D, ND)</code>: These macros create <em>quads</em>, 4-sided polygonal objects, using triangle pairs.</p>
<p>Parameters:</p>
<ul>
	<li><code>A, B, C, D</code> = Vertices of the quad.</li>
	<li><code>NA, NB, NC, ND</code> = Vertex normals of the quad.</li>
</ul>

</div>
<a name="r3_8_1_1_19_1"></a>
<div class="content-level-h6" contains="The HF Macros" id="r3_8_1_1_19_1">
<h6>3.8.1.1.19.1 The HF Macros</h6>
<p>There are several HF macros in shapes.inc, which generate meshes in various shapes. All the HF macros have these things in common: </p>
<ul>
	<li>The HF macros do not directly use an image for input, but evaluate a user-defined function. The macros deform the surface based on the function values.</li>
	<li>The macros can either write to a file to be included later, or create an object directly. If you want to output to a file, simply specify a filename. If you want to create an object directly, specify &quot;&quot; as the file name (an empty string).</li>
	<li>The function values used for the heights will be taken from the square that goes from  &lt;0,0,0&gt; to &lt;1,1,0&gt; if UV height mapping is on. Otherwise the function values will be taken from the points where the surface is (before the deformation).</li>
	<li>The texture you apply to the shape will be evaluated in the square that goes from &lt;0,0,0&gt; to &lt;1,1,0&gt; if UV texture mapping is on. Otherwise the texture is evaluated at the points where the surface is (after the deformation.</li>
</ul>
<p>The usage of the different HF macros is described below.</p>

<p><code>HF_Square (Function, UseUVheight, UseUVtexture, Res, Smooth, FileName, MnExt, MxExt)</code>: This macro generates a mesh in the form of a square height field, similar to the built-in height_field primitive. Also see the general description of the HF macros above.</p>

<p>Parameters:</p>
<ul>
	<li><code>Function</code> = The function to use for deforming the height field.</li>
	<li><code>UseUVheight</code> = A boolean value telling the macro whether or not to use UV height mapping.</li>
	<li><code>UseUVtexture</code> = A boolean value telling the macro whether or not to use UV texture mapping.</li>
	<li><code>Res</code> = A 2D vector specifying the resolution of the generated mesh.</li>
	<li><code>Smooth</code> = A boolean value telling the macro whether or not to smooth the generated mesh.</li>
	<li><code>FileName</code> = The name of the output file.</li>
	<li><code>MnExt</code> = Lower-left-front corner of a box containing the height field.</li>
	<li><code>MxExt</code> = Upper-right-back corner of a box containing the height field.</li>
</ul>

<p><code>HF_Sphere(Function, UseUVheight, UseUVtexture, Res, Smooth, FileName, Center, Radius, Depth)</code>: This macro generates a mesh in the form of a spherical height field. When UV-mapping is used, the UV square will be wrapped around the sphere starting at +x and going anti-clockwise around the y axis. Also see the general description of the HF macros above.</p>
<p>Parameters:</p>
<ul>
	<li><code>Function</code> = The function to use for deforming the height field.</li>
	<li><code>UseUVheight</code> = A boolean value telling the macro whether or not to use UV height mapping.</li>
	<li><code>UseUVtexture</code> = A boolean value telling the macro whether or not to use UV texture mapping.</li>
	<li><code>Res</code> = A 2D vector specifying the resolution of the generated mesh.</li>
	<li><code>Smooth</code> = A boolean value telling the macro whether or not to smooth the generated mesh.</li>
	<li><code>FileName</code> = The name of the output file.</li>
	<li><code>Center</code> = The center of the height field before being displaced, the displacement can, and most likely will, make the object off-center.</li>
	<li><code>Radius</code> = The starting radius of the sphere, before being displaced.</li>
	<li><code>Depth</code> = The depth of the height field.</li>
</ul>

<p><code>HF_Cylinder(Function, UseUVheight, UseUVtexture, Res, Smooth, FileName, EndA, EndB, Radius,Depth)</code>: This macro generates a mesh in the form of an open-ended cylindrical height field. When UV-mapping is used, the UV square will be wrapped around the cylinder. Also see the general description of the HF macros above.</p>
<p>Parameters:</p>
<ul>
	<li><code>Function</code> = The function to use for deforming the height field.</li>
	<li><code>UseUVheight</code> = A boolean value telling the macro whether or not to use UV height mapping.</li>
	<li><code>UseUVtexture</code> = A boolean value telling the macro whether or not to use UV texture mapping.</li>
	<li><code>Res</code> = A 2D vector specifying the resolution of the generated mesh.</li>
	<li><code>Smooth</code> = A boolean value telling the macro whether or not to smooth the generated mesh.</li>
	<li><code>FileName</code> = The name of the output file.</li>
	<li><code>EndA, EndB</code> = The end points of the cylinder.</li>
	<li><code>Radius</code> = The (pre-displacement) radius of the cylinder.</li>
	<li><code>Depth</code> = The depth of the height field.</li>
</ul>

<p><code>HF_Torus (Function, UseUVheight, UseUVtexture, Res, Smooth, FileName, Major, Minor, Depth)</code>: This macro generates a mesh in the form of a torus-shaped height field. When UV-mapping is used, the UV square is wrapped around similar to spherical or cylindrical mapping. However the top and bottom edges of the map wrap over and under the torus where they meet each other on the inner rim. Also see the general description of the HF macros above.</p>
<p>Parameters:</p>
<ul>
	<li><code>Function</code> = The function to use for deforming the height field.</li>
	<li><code>UseUVheight</code> = A boolean value telling the macro whether or not to use UV height mapping.</li>
	<li><code>UseUVtexture</code> = A boolean value telling the macro whether or not to use UV texture mapping.</li>
	<li><code>Res</code> = A 2D vector specifying the resolution of the generated mesh.</li>
	<li><code>Smooth</code> = A boolean value telling the macro whether or not to smooth the generated mesh.</li>
	<li><code>FileName</code> = The name of the output file.</li>
	<li><code>Major</code> = The major radius of the torus.</li>
	<li><code>Minor</code> = The minor radius of the torus.</li>
</ul></div>

<a name="r3_8_1_1_20"></a>
<div class="content-level-h5" contains="Shapes2.inc" id="r3_8_1_1_20">
<h5>3.8.1.1.20 Shapes2.inc</h5>

<dl>
<dt><code>Tetrahedron</code></dt>
	<dd>4-sided regular polyhedron.</dd>

<dt><code>Octahedron</code></dt>
	<dd>8-sided regular polyhedron.</dd>

<dt><code>Dodecahedron</code></dt>
	<dd>12-sided regular polyhedron.</dd>

<dt><code>Icosahedron</code></dt>
	<dd>20-sided regular polyhedron.</dd>

<dt><code>Rhomboid</code></dt>
	<dd>Three dimensional 4-sided diamond, basically a sheared box.</dd>

<dt><code>Hexagon</code></dt>
	<dd>6-sided regular polygonal solid, axis along x.</dd>

<dt><code>HalfCone_Y</code></dt>
	<dd>Convenient finite cone primitive, pointing up in the Y axis.</dd>

<dt><code>Pyramid</code></dt>
	<dd>4-sided pyramid (union of triangles, can not be used in CSG).</dd>

<dt><code>Pyramid2</code></dt>
	<dd>4-sided pyramid (intersection of planes, can be used in CSG).</dd>

<dt><code>Square_X, Square_Y, Square_Z</code></dt>
	<dd>Finite planes stretching 1 unit along each axis. In other words, 2X2 unit squares.</dd>
</dl></div>

<a name="r3_8_1_1_21"></a>
<div class="content-level-h5" contains="Shapes3.inc" id="r3_8_1_1_21">
<h5>3.8.1.1.21 Shapes3.inc</h5>

<p>This file contains macros for segments of shapes, facetted shapes and others.</p>

<p><strong>Segments of shapes:</strong></p>
<dl>
<dt><code>Segment_of_Torus ( R_major, R_minor, Segment_Angle )</code></dt>
	<dd>Segment of a torus around the y axis. The angle starts at positive x axis.</dd>
	 
<dt><code>Segment_of_CylinderRing ( R_out, R_in, Height, Segment_Angle )</code></dt>
	<dd>Segment of a cylindrical ring around the y axis. The angle starts at positive x axis.</dd>

<dt><code>Segment_of_Object ( Segment_Object, Segment_Angle )</code></dt>
	<dd>Segment of an object around the y axis. The angle starts at positive x axis.<br>
Based on min_extend and max_extend.</dd>
</dl>

<p><strong>Angular shapes:</strong></p>
<dl>
<dt><code>Column_N (N, R_in, Height )</code></dt>
	<dd>A regular n-sided column around the y axis, defined by the incircle radius <code>R_in</code>. <code>Height</code> is the height in y direction.</dd>

<dt><code>Column_N_AB (N, A, B, R_in)</code></dt>
	<dd>A regular n-sided column from point <code>A</code> to  point <code>B</code>, defined by the incircle radius <code>R_in</code>.</dd>

<dt><code>Pyramid_N   (N, R_in_1, R_in_2, Height )</code></dt>
	<dd>A regular n-sided pyramid around the y axis, defined by the incircle radii:<br>
<code>R_in_1</code> at y = 0 and <code>R_in_2</code> at y = <code>Height</code>.</dd>

<dt><code>Pyramid_N_AB(N, A, R_in_A, B, R_in_B)</code></dt>
	<dd>A regular n-sided column from point <code>A</code> to point <code>B</code>,
defined by the incircle radii:<br>
<code>R_in_A</code> at point <code>A</code> and <code>R_in_B</code> at point <code>B</code>.</dd>
</dl>

<p><strong>Facetted shapes:</strong></p>
<dl>
<dt><code>Facetted_Sphere (Quarter_Segments, Radial_Segments)</code></dt>
	<dd>A facetted sphere with incircle radius 1.<br>
<code>Quarter_Segments</code> = number of equitorial facetts in one quarter (1/2 of the total number).<br>
<code>Radial_Segments</code> = number of radial facetts.</dd>

<dt><code>Facetted_Egg_Shape (Quarter_Segments, Radial_Segments, Lower_Scale, Upper_Scale)</code></dt>
	<dd>A facetted egg shape. The number of facetts are defined analog to <code>Facetted_Egg_Shape()</code>.<br>
Equitorial incircle radius = 1. Lower half scaled in y by <code>Lower_Scale</code>,
Upper half scaled in y by <code>Upper_Scale</code>.</dd>

<dt><code>Facetted_Egg (N_Quarter_Segments, N_Radial_Segments)</code></dt>
	<dd>A facetted egg with total height = 2. Lower half scaled in y by 1.15, Upper half scaled in y by 1.55.</dd>
</dl>
<p><strong>Round shapes:</strong></p>
<dl>
<dt><code>Egg_Shape (Lower_Scale, Upper_Scale)</code></dt>
	<dd>An egg shape with equitorial radius 1. <br>
Lower half scaled in y by <code>Lower_Scale</code>,
Upper half scaled in y by <code>Upper_Scale</code>.</dd>

<dt><code>Egg</code></dt>
	<dd>Uses the macro Egg_Shape.<br>
Lower half scaled in y by 1.15, upper half scaled in y by 1.55.</dd>
</dl>
Wireframe shape (mostly also optionally filled:
<dl>
<dt><code>Ring_Sphere (Rmaj_H, Rmaj_V, Rmin_H, Rmin_V, Number_of_Rings_horizontal, Number_of_Rings_vertical)</code></dt>
	<dd>A wireframe sphere by vertical and horizontal torii. <br>
Horizontal tori: equatorial radius major <code>Rmaj_H</code>, radius minor <code>Rmin_H</code>.<br>
Vertical tori: radius major <code>Rmaj_V</code>, radius minor <code>Rmin_V</code>.</dd>

<dt><code>Round_Pyramid_N_out (N, A, CornerR_out_A, B, CornerR_out_B, R_Border, Filled, Merge )</code></dt>
	<dd>A regular n-sided column from point <code>A</code> to point <code>B</code>,
defined by the outcircle radii:
<code>R_in_A</code> at point <code>A</code> and <code>R_in_B</code> at point <code>B</code>.</dd>

<dt><code>Round_Pyramid_N_in  (N, A, FaceR_in_A, B, FaceR_in_B, R_Border, Filled, Merge_On )</code></dt>
	<dd>A regular n-sided column from point <code>A</code> to point <code>B</code>,
defined by the incircle radii:
<code>R_in_A</code> at point <code>A</code> and <code>R_in_B</code> at point <code>B</code>..</dd>

<dt><code>Round_Cylinder_Tube( A, B, R_out, R_border, Filled, Merge)</code></dt>
	<dd>A cylindrical tube from point <code>A</code> to point <code>B</code>,
with the outer radius <code>R_out</code> and the border radius <code>R_border</code>.
The inner radius is <code>R_out - R_border</code>.<br>
With <code>Filled</code> = 1 we get a <code>Round_Cylinder</code>.</dd>

<dt><code>Rounded_Tube( R_out, R_in, R_Border,  Height,  Merge)</code></dt>
	<dd>A cylindrical tube around the y axis with the <code>Height</code> in y, with the outer radius <code>R_out</code>, the inner radius <code>R_in</code> and the radius of the rounded borders <code>R_border</code>.</dd>

<dt><code>Rounded_Tube_AB( A, B, R_out, R_in, R_Border, Merge)</code></dt>
	<dd>A cylindrical tube from point <code>A</code>  to  point <code>B</code>.<br>
The outer radius is <code>R_out</code>, the inner radius is <code>R_in</code>
and the radius of the rounded borders is <code>R_border</code>.</dd>

<dt><code>Round_Conic_Torus( Center_Distance, R_upper, R_lower, R_border, Merge)</code></dt>
	<dd>A toroid ring the z axis,
with the lower torus part at y = 0 and the upper part at y = Center_Distance.<br>
The radius of the lower part is <code>R_lower</code>,
the radius of the lower part is <code>R_lower</code>
The minor radius of the toroid is <code>R_border</code>.</dd>

<dt><code>Round_Conic_Prism( Center_Distance, R_upper, R_lower, Length_Zminus, R_Border, Merge)</code></dt>
	<dd>A shape of the toroidal form like <code>Round_Conic_Torus()</code>,
but filled and in the negativ z direction with the length <code> Length_Zminus</code>.</dd>

<dt><code>Half_Hollowed_Rounded_Cylinder1( Length, R_out, R_border, BorderScale, Merge)</code></dt>
	<dd>A hollowed half rounded cylinder with the <code>Length</code> in x, of the outer radius <code>R_out</code>, with round ends.
The borders have a minor radius <code>R_border</code> with the scale in y <code>BorderScale</code>.<br>
The inner radius is <code>R_out - R_border</code>.</dd>
<dt><code>Half_Hollowed_Rounded_Cylinder2( Length, R_out, R_corner, R_border, BorderScale, Merge)</code></dt>
	<dd>A hollowed half rounded cylinder with the <code>Length</code> in x, of the outer radius <code>R_out</code>, with flat ends.
The corners have a minor radius of <code>R_corner</code>,
the borders have a minor radius of <code>R_border</code> with the scale in y <code>BorderScale</code>.<br>
The inner radius is <code>R_out - R_border</code>, the inner lenght is <code>Length - 2*R_border</code>.</dd>

<dt><code>Round_N_Tube_Polygon (N, Tube_R, R_incircle, Edge_R, Filled, Merge)</code></dt>
	<dd>A regular polygon with <code>N</code> edges (or corners) with incircle radius <code>R_incircle</code>,
formed by a tube with the minor radius <code>Tube_R</code>.
The corners are formed by torus segments with the major radius <code>Edge_R</code>.</dd>

</dl></div>

<a name="r3_8_1_1_22"></a>
<div class="content-level-h5" contains="Shapesq.inc" id="r3_8_1_1_22">
<h5>3.8.1.1.22 Shapesq.inc</h5>

<dl>
<dt><code>Bicorn</code></dt>
<dd>This curve looks like the top part of a paraboloid, bounded from below by another paraboloid.
The basic equation is: </dd>
<dd>y^2 - (x^2 + z^2) y^2 - (x^2 + z^2 + 2 y - 1)^2 = 0</dd>

<dt><code>Crossed_Trough</code></dt>
<dd>This is a surface with four pieces that sweep up from the x-z plane.</dd>
<dd>The equation is: y = x^2 z^2</dd>

<dt><code>Cubic_Cylinder</code></dt>
<dd>A drop coming out of water? This is a curve formed by using the equation:</dd>
<dd>y = 1/2 x^2 (x + 1)</dd>
<dd>as the radius of a cylinder having the x-axis as its central axis. The final form of the equation is:</dd>
<dd>y^2 + z^2 = 0.5 (x^3 + x^2)</dd>

<dt><code>Cubic_Saddle_1</code></dt>
<dd>A cubic saddle. The equation is: z = x^3 - y^3</dd>

<dt><code>Devils_Curve</code></dt>
<dd>Variant of a devil's curve in 3-space. This figure has a top and bottom part that are very similar to a hyperboloid of one sheet, however the central region is pinched in the middle leaving two teardrop shaped holes. 
The equation is:</dd>
<dd>x^4 + 2 x^2 z^2 - 0.36 x^2 - y^4 + 0.25 y^2 + z^4 = 0</dd>

<dt><code>Folium</code></dt>
<dd>This is a folium rotated about the x-axis. The formula is:</dd>
<dd>2 x^2 - 3 x y^2 - 3 x z^2 + y^2 + z^2 = 0</dd>

<dt><code>Glob_5</code></dt>
<dd>Glob - sort of like basic teardrop shape. The equation is:</dd>
<dd>y^2 + z^2 = 0.5 x^5 + 0.5 x^4</dd>

<dt><code>Twin_Glob</code></dt>
<dd>Variant of a lemniscate - the two lobes are much more teardrop-like.</dd>

<dt><code>Helix, Helix_1</code></dt>
<dd>Approximation to the helix z = arctan(y/x). 
The helix can be approximated with an algebraic equation (kept to the range of a quartic) with the following steps:</dd>
<dd>tan(z) = y/x   =&gt;  sin(z)/cos(z) = y/x   =&gt;<br>
(1) x sin(z) - y cos(z) = 0
Using the taylor expansions for sin, cos about z = 0,<br>
sin(z) = z - z^3/3! + z^5/5! - ...<br>
cos(z) = 1 - z^2/2! + z^6/6! - ...<br>
Throwing out the high order terms, the expression (1) can be written as:<br>
x (z - z^3/6) - y (1 + z^2/2) = 0, or<br><br>
(2) -1/6 x z^3 + x z + 1/2 y z^2 - y = 0<br>
This helix (2) turns 90 degrees in the range 0 &lt;= z &lt;= sqrt(2)/2. 
By using scale &lt;2 2 2&gt;, the helix defined below turns 90 degrees in the range 0 &lt;= z &lt;= sqrt(2) = 1.4042.</dd>

<dt><code>Hyperbolic_Torus</code></dt>
<dd>Hyperbolic Torus having major radius sqrt(40), minor radius sqrt(12). This figure is 
generated by sweeping a circle along the arms of a hyperbola. The equation is:</dd>
<dd>x^4 + 2 x^2 y^2 - 2 x^2 z^2 - 104 x^2 + y^4 - 2 y^2 z^2 + 56 y^2 + z^4 + 104 z^2 + 784 = 0</dd>

<dt><code>Lemniscate</code></dt>
<dd>Lemniscate of Gerono. This figure looks like two teardrops with their pointed ends connected. It is formed by rotating the Lemniscate of Gerono about the x-axis. The formula is:</dd>
<dd>x^4 - x^2 + y^2 + z^2 = 0</dd>

<dt><code>Quartic_Loop_1</code></dt>
<dd>This is a figure with a bumpy sheet on one side and something that looks like a paraboloid (but with an internal bubble). The formula is:</dd>
<dd>(x^2 + y^2 + a c x)^2 - (x^2 + y^2)(c - a x)^2</dd>
<dd>-99*x^4+40*x^3-98*x^2*y^2-98*x^2*z^2+99*x^2+40*x*y^2</dd>
<dd>+40*x*z^2+y^4+2*y^2*z^2-y^2+z^4-z^2</dd>

<dt><code>Monkey_Saddle</code></dt>
<dd>This surface has three parts that sweep up and three down.  This gives a saddle that has a place for two legs and a tail. The equation is:</dd>
<dd><code>z = c (x^3 - 3 x y^2)</code></dd>
<dd>The value c gives a vertical scale to the surface - the smaller the value of c, the flatter the surface will be (near the origin).</dd>

<dt><code>Parabolic_Torus_40_12</code></dt>
<dd>Parabolic Torus having major radius sqrt(40), minor radius sqrt(12). This figure is generated by sweeping a circle along the arms of a parabola. The equation is:</dd>
<dd>x^4 + 2 x^2 y^2 - 2 x^2 z - 104 x^2 + y^4 - 2 y^2 z + 56 y^2 + z^2 + 104 z + 784 = 0</dd>

<dt><code>Piriform</code></dt>
<dd>This figure looks like a hersheys kiss. It is formed by sweeping a Piriform about the x-axis. A basic form of the equation is:</dd>
<dd>(x^4 - x^3) + y^2 + z^2 = 0.</dd>

<dt><code>Quartic_Paraboloid</code></dt>
<dd>Quartic parabola - a 4th degree polynomial (has two bumps at the bottom) that has been swept around the z axis. The equation is:</dd>
<dd>0.1 x^4 - x^2 - y^2 - z^2 + 0.9 = 0</dd>

<dt><code>Quartic_Cylinder</code></dt>
<dd>Quartic Cylinder - a Space Needle?</dd>

<dt><code>Steiner_Surface</code></dt>
<dd>Steiners quartic surface</dd>

<dt><code>Torus_40_12</code></dt>
<dd>Torus having major radius sqrt(40), minor radius sqrt(12).</dd>

<dt><code>Witch_Hat</code></dt>
<dd>Witch of Agnesi.</dd>

<dt><code>Sinsurf</code></dt>
<dd>Very rough approximation to the sin-wave surface z = sin(2 pi x y).</dd>
<dd>In order to get an approximation good to 7 decimals at a distance of 1 from the origin would require a polynomial of degree around 60, which would require around 200,000 coefficients. For best results, scale by something like &lt;1 1 0.2&gt;.</dd>
</dl></div>

<a name="r3_8_1_1_23"></a>
<div class="content-level-h5" contains="Skies.inc" id="r3_8_1_1_23">
<h5>3.8.1.1.23 Skies.inc</h5>

<p>These files contain some predefined skies for you to use in your scenes.</p>

<p>skies.inc: There are textures and pigment definitions in this file.</p>
<ul>
	<li>all pigment definitions start with &quot;P_&quot;</li>
	<li>all sky_spheres start with &quot;S_&quot;</li>
	<li>all textures start with &quot;T_&quot;</li>
	<li>and all objects start with &quot;O_&quot;</li>
</ul>

<p>Pigments:</p>
<dl>
	<dt><code>P_Cloud1</code></dt>
	<dt><code>P_Cloud2</code></dt>
	<dt><code>P_Cloud3</code></dt>
</dl>

<p>Sky Spheres:</p>
	<dl>
		<dt><code>S_Cloud1</code></dt>
			<dd>This sky_sphere uses P_Cloud2 and P_Cloud3.</dd>
		<dt><code>S_Cloud2</code></dt>
			<dd>This sky_sphere uses P_Cloud4.</dd>
		<dt><code>S_Cloud3</code></dt>
			<dd>This sky_sphere uses P_Cloud2.</dd>
		<dt><code>S_Cloud4</code></dt>
			<dd>This sky_sphere uses P_Cloud3.</dd>
		<dt><code>S_Cloud5</code></dt>
			<dd>This sky_sphere uses a custom pigment.</dd>
	</dl>

<p>Textures:</p>
	<dl>
		<dt><code>T_Cloud1</code></dt>
			<dd>2-layer texture using P_Cloud1 pigment, contains clear regions.</dd>
		<dt><code>T_Cloud2</code></dt>
			<dd>1-layer texture, contains clear regions.</dd>
		<dt><code>T_Cloud3</code></dt>
			<dd>2-layer texture, contains clear regions.</dd>
	</dl>

<p>Objects:</p>
	<dl>
		<dt><code>O_Cloud1</code></dt>
			<dd>Sphere, radius 10000 with T_Cloud1 texture.</dd>
		<dt><code>O_Cloud2</code></dt>
			<dd>Union of 2 planes, with T_Cloud2 and T_Cloud3.</dd>
	</dl></div>

<a name="r3_8_1_1_24"></a>
<div class="content-level-h5" contains="Stars.inc" id="r3_8_1_1_24">
<h5>3.8.1.1.24 Stars.inc</h5>

<p>stars.inc: This file contains predefined starfield textures. The starfields become denser and more colorful with the number, with Starfield6 being the densest and most colorful.</p>
<dl>
<dt><code>Starfield1</code></dt>
<dt><code>Starfield2</code></dt>
<dt><code>Starfield3</code></dt>
<dt><code>Starfield4</code></dt>
<dt><code>Starfield5</code></dt>
<dt><code>Starfield6</code></dt>
</dl></div>

<a name="r3_8_1_1_25"></a>
<div class="content-level-h5" contains="Stones.inc" id="r3_8_1_1_25">
<h5>3.8.1.1.25 Stones.inc</h5>

<p>The file <em>stones.inc</em> simply includes both <em>stones1.inc</em> and <em>stones2.inc</em>, and the file <em>stoneold.inc</em> provides backwards compatability for old scenes, the user is advised to use the textures in <em>stones1.inc</em> instead.</p>

<p>The two files stones1.inc and stones2.inc contain lists of predefined stone textures.</p>

<p>The file <em>stones1.inc</em> contains texture definitions for:</p>
<ul>
	<li>T_Grnt0 to T_Grnt29</li>
	<li>T_Grnt1a to T_Grnt24a</li>
	<li>T_Stone0 to T_Stone24</li>
</ul>
<p>The T_GrntXX, T_GrntXXa, and CrackX textures are building blocks that are used to create the final <em>usable</em> T_StoneX textures (and other textures that *you* design, of course!)</p>
<p>The T_GrntXX textures generally contain no transparency, but the T_GrntXXa textures <em>DO</em> contain transparency. The CrackX textures are clear with thin opaque bands, simulating cracks.</p>
<p>The file <em>stones2.inc</em> provides additional stone textures, and contains texture definitions for T_Stone25 to T_Stone44.</p></div>

<a name="r3_8_1_1_26"></a>
<div class="content-level-h5" contains="Stdinc.inc" id="r3_8_1_1_26">
<h5>3.8.1.1.26 Stdinc.inc</h5>

<p>This file simply includes the most commonly used include files,
so you can get all of them with a single #include.
The files included are:</p>
<ul>
<li>colors.inc</li>
<li>shapes.inc</li>       
<li>transforms.inc</li>
<li>consts.inc</li>
<li>functions.inc</li>
<li>math.inc</li>
<li>rand.inc</li>
</ul></div>

<a name="r3_8_1_1_27"></a>
<div class="content-level-h5" contains="Strings.inc" id="r3_8_1_1_27">
<h5>3.8.1.1.27 Strings.inc</h5>

<p>This include contains macros for manipulating and generating text strings.</p>
<p><code>CRGBStr(C, MinLen, Padding)</code> and <code>CRGBFTStr(C, MinLen, Padding)</code>: These macros convert a color to a string. The format of the output string is &quot;rgb &lt; R, G, B&gt;&quot; or &quot;rgbft &lt; R, G, B, F, T&gt;&quot;, depending on the macro being called.</p>
<p>Parameters:</p>
<ul>
	<li><code>C</code> = The color to be turned into a string.</li>
	<li><code>MinLen</code> = The minimum length of the individual components, analogous to the second parameter of str().</li>
	<li><code>Padding</code> = The padding to use for the components, see the third parameter of the str() function for details.</li>
</ul>

<p><code>Str(A)</code>: This macro creates a string containing a float with the systems default precision. It is a shortcut for using the str() function.</p>
<p>Parameters:</p><ul>
	<li><code>A</code> = The float to be converted to a string.</li>
</ul>
<p><code>VStr2D(V), VStr(V)</code>: These macros create strings containing vectors using POV syntax (&lt;X,Y,Z&gt;) with the default system precision. VStr2D() works with 2D vectors, VStr() with 3D vectors. They are shortcuts for using the <code>vstr()</code> function.</p>
<p>Parameters:</p>
<ul>
	<li><code>V</code> = The vector to be converted to a string.</li>
</ul>

<p><code>Vstr2D(V,L,P), Vstr(V,L,P)</code>: These macros create strings containing vectors using POV syntax (&lt;X,Y,Z&gt;) with user specified precision. Vstr2D() works with 2D vectors, Vstr() with 3D vectors. They are shortcuts for using the vstr() function. The function of L and P is the same as in <code>vstr</code> specified in <a href="r3_3.html#r3_3_1_9_4">String Functions</a>.</p>
<p>Parameters:</p>
<ul>
<li><code>V</code> = The vector to be converted to a string.</li>
<li><code>L</code> = Minimum length of the string and the type of left padding used if the string's representation is shorter than the minimum.</li>
<li><code>P</code> = Number of digits after the decimal point.</li>
</ul>

<p><code>Triangle_Str(A, B, C)</code> and <code>Smooth_Triangle_Str(A, NA, B, NB, C, NC)</code>: These macros take vertex and normal information and return a string representing a triangle in POV-Ray syntax. They are mainly useful for generating mesh files.</p>
<p>Parameters:</p>
<ul>
	<li><code>A, B, C</code> = Triangle vertex points.</li>
	<li><code>NA, NB, NC</code> = Triangle vertex normals (Smooth_Triangle_Str() only).</li>
</ul>

<p><code>Parse_String(String)</code>: This macro takes a string, writes it to a file, and then includes that file. This has the effect of parsing that string: &quot;<code>Parse_String(&quot;MyColor&quot;)</code>&quot; will be seen by POV-Ray as &quot;<code>MyColor</code>&quot;.</p>
<p>Parameters:</p>
<ul>
	<li><code>String</code> = The string to be parsed.</li>
</ul></div>

<a name="r3_8_1_1_28"></a>
<div class="content-level-h5" contains="Sunpos.inc" id="r3_8_1_1_28">
<h5>3.8.1.1.28 Sunpos.inc</h5>

<p> This file only contains the sunpos() macro</p>

<p><code>sunpos(Year, Month, Day, Hour, Minute, Lstm, LAT, LONG)</code>: The macro returns the position of the sun, for a given date, time, and location on earth. The suns position is also globally declared as the vector <code>SolarPosition</code>. Two other declared vectors are the <code>Az</code> (Azimuth) and <code>Al</code> (Altitude), these can be useful for aligning an object (media container) with the sunlight. Assumption: in the scene north is in the +Z direction, south is -Z.</p>
<p>Parameters:</p>
<ul>
	<li><code>Year</code>= The year in four digits.</li>
	<li><code>Month</code>= The month number (1-12).</li>
	<li><code>Day</code>= The day number (1-31).</li>
	<li><code>Hour</code>= The hour of day in 24 hour format (0-23).</li>
	<li><code>Minute</code>= The minutes (0-59). </li>
	<li><code>Lstm</code>= Meridian of your local time zone in degrees (+1 hour = +15 deg, east = positive, west = negative)</li>
	<li><code>LAT</code>= Lattitude in degrees.decimal, northern hemisphere = positive, southern = negative</li>
	<li><code>LONG</code>=  Longitude in degrees.decimal, east = positive, west is negative</li>
</ul>

<p>Usage:</p>
<pre>
#include &quot;sunpos.inc&quot;

light_source {
  //Greenwich, noon on the longest day of 2000
  SunPos(2000, 6, 21, 12, 2, 0, 51.4667, 0.00) 
  rgb 1
  }

cylinder{
  &lt;-2,0,0&gt;,&lt;2,0,0&gt;,0.1
  rotate &lt;0, Az-90, Al&gt;  //align cylinder with sun
  texture {...}
  }
</pre>

<p class="Note"><strong>Note:</strong> The default distance of the sun from the origin is 1e+9 units.</p></div>

<a name="r3_8_1_1_29"></a>
<div class="content-level-h5" contains="Textures.inc" id="r3_8_1_1_29">
<h5>3.8.1.1.29 Textures.inc</h5>

<p>This file contains many predefined textures, including wood, glass, and metal textures, and a few texture/pattern generation macros.</p>

</div>
<a name="r3_8_1_1_29_1"></a>
<div class="content-level-h6" contains="Stones" id="r3_8_1_1_29_1">
<h6>3.8.1.1.29.1 Stones</h6>
<p>Stone Pigments:</p>
<dl>
<dt><code>Jade_Map, Jade</code></dt>
	<dd>Drew Wells' superb Jade.  Color map works nicely with other textures, too.</dd>
<dt><code>Red_Marble_Map, Red_Marble</code></dt>
	<dd>Classic white marble with red veins.  Over-worked, like checkers.</dd>
<dt><code>White_Marble_Map, White_Marble</code></dt>
	<dd>White marble with black veins.</dd>
<dt><code>Blood_Marble_Map, Blood_Marble</code></dt>
	<dd>Light blue and black marble with a thin red vein.</dd>
<dt><code>Blue_Agate_Map, Blue_Agate</code></dt>
	<dd>A grey blue agate -- kind of purplish.</dd>
<dt><code>Sapphire_Agate_Map, Sapphire_Agate</code></dt>
	<dd>Deep blue agate -- almost glows.</dd>
<dt><code>Brown_Agate_Map, Brown_Agate</code></dt>
	<dd>Brown and white agate -- very pretty.</dd>
<dt><code>Pink_Granite_Map, Pink_Granite</code></dt>
	<dd>Umm, well, pink granite.</dd>
</dl>
<p>Stone textures:</p>
<dl>
<dt><code>PinkAlabaster</code></dt>
	<dd>Gray-pink alabaster or marble. Layers are scaled for a unit object and relative to each other.</dd>
	<dd><p class="Note"><strong>Note:</strong> This texture has very tiny dark blue specks that are often mistaken for rendering errors.</p></dd>
	<dd>Underlying surface is very subtly mottled with bozo.</dd>
	<dd>Second layer texture has some transmit values, yet a fair amount of color.</dd>
	<dd>Veining is kept quite thin in color map and by the largish scale.</dd>
</dl>

</div>
<a name="r3_8_1_1_29_2"></a>
<div class="content-level-h6" contains="Skies" id="r3_8_1_1_29_2">
<h6>3.8.1.1.29.2 Skies</h6>
<p>Sky pigments:</p>
<dl>
<dt><code>Blue_Sky_Map, Blue_Sky</code></dt>
	<dd>Basic blue sky with clouds.</dd>
<dt><code>Bright_Blue_Sky</code></dt>
	<dd>Bright blue sky with very white clouds.</dd>
<dt><code>Blue_Sky2</code></dt>
	<dd>Another sky.</dd>
<dt><code>Blue_Sky3</code></dt>
	<dd>Small puffs of white clouds.</dd>
<dt><code>Blood_Sky</code></dt>
	<dd>Red sky with yellow clouds -- very surreal.</dd>
<dt><code>Apocalypse</code></dt>
	<dd>Black sky with red and purple clouds.</dd>
	<dd>Try adding turbulence values from 0.1 - 5.0</dd>
<dt><code>Clouds</code></dt>
	<dd>White clouds with transparent sky.</dd>
<dt><code>FBM_Clouds</code></dt>
<dt><code>Shadow_Clouds</code></dt>
	<dd>A multilayered cloud texture (a real texture, not a pigment).</dd>
</dl>

</div>
<a name="r3_8_1_1_29_3"></a>
<div class="content-level-h6" contains="Woods" id="r3_8_1_1_29_3">
<h6>3.8.1.1.29.3 Woods</h6>
<p>Wood pigments:</p>
<p>Several wooden pigments by Tom Price:</p>
<dl>
	<dt><code>Cherry_Wood</code></dt>
		<dd>A light reddish wood.</dd>
	<dt><code>Pine_Wood</code></dt>
		<dd>A light tan wood whiteish rings.</dd>
	<dt><code>Dark_Wood</code></dt>
		<dd>Dark wood with a,ish hue to it.</dd>
	<dt><code>Tan_Wood</code></dt>
		<dd>Light tan wood with brown rings.</dd>
	<dt><code>White_Wood</code></dt>
		<dd>A very pale wood with tan rings -- kind of balsa-ish.</dd>
	<dt><code>Tom_Wood</code></dt>
		<dd>Brown wood - looks stained.</dd>
</dl>
<dl>
	<dt><code>DMFWood1, DMFWood2, DMFWood3, DMFWood4, DMFWood5</code></dt>
		<dd>The scaling in these definitions is relative to a unit-sized object (radius 1). 
		<p class="Note"><strong>Note:</strong> These wood definitions are functionally equivalent to a log lying along the z axis. For best results, think like a woodcutter trying to extract the nicest board out of that log. A little tilt along the x axis will give elliptical rings of grain like you would expect to find on most boards.</p></dd>
</dl>

<p>Wood textures:</p>
<dl>
<dt><code>DMFWood6</code></dt>
	<dd>This is a three-layer wood texture.  Renders rather slowly because of the transparent layers and the two layers of turbulence, but it looks great.  Try other colors of <em>varnish</em> for simple variations.</dd>
<dt><code>DMFLightOak</code></dt>
	<dd>Is this really oak?  I dunno.  Quite light, maybe more like spruce.</dd>
<dt><code>DMFDarkOak</code></dt>
	<dd>Looks like old desk oak if used correctly.</dd>
<dt><code>EMBWood1</code></dt>
	<dd>Wood by Eric Barish</dd>
</dl>
<p>Doug Otwell woods:</p>
<dl>
<dt><code>Yellow_Pine</code></dt>
	<dd>Yellow pine, close grained.</dd>
<dt><code>Rosewood</code></dt>
<dt><code>Sandalwood</code></dt>
	<dd>makes a great burled maple, too</dd>
</dl>

</div>
<a name="r3_8_1_1_29_4"></a>
<div class="content-level-h6" contains="Glass" id="r3_8_1_1_29_4">
<h6>3.8.1.1.29.4 Glass</h6>
<p><code>Glass_Finish</code> is a generic glass finish, <code>Glass_Interior</code> is a generic glass interior, it just adds an ior of 1.5.</p>

<p>Glass materials:</p>
<dl>
<dt><code>M_Glass</code></dt>
	<dd>Just glass.</dd>
<dt><code>M_Glass2</code></dt>
	<dd>Probably more of a <em>Plexiglas</em> than glass.</dd>
<dt><code>M_Glass3</code></dt>
	<dd>An excellent lead crystal glass!</dd>
<dt><code>M_Green_Glass</code></dt>
</dl>
<p>Glass textures contributed by Norm Bowler, of Richland WA. NBglass_finish is used by these materials.
</p>
<dl>
<dt><code>M_NBglass</code></dt>
<dt><code>M_NBoldglass</code></dt>
<dt><code>M_NBwinebottle</code></dt>
<dt><code>M_NBbeerbottle</code></dt>
</dl>

<p>A few color variations on Norm's glass.</p>
<dl>
<dt><code>M_Ruby_Glass</code></dt>
<dt><code>M_Dark_Green_Glass</code></dt>
<dt><code>M_Yellow_Glass</code></dt>
<dt><code>M_Orange_Glass</code></dt>
<dt><code>M_Vicks_Bottle_Glass</code></dt>
</dl>

</div>
<a name="r3_8_1_1_29_5"></a>
<div class="content-level-h6" contains="Metals" id="r3_8_1_1_29_5">
<h6>3.8.1.1.29.5 Metals</h6>
<p>Metal finishes:</p>
<dl>
<dt><code>Metal</code></dt>
	<dd>Generic metal finish.</dd>
<dt><code>SilverFinish</code></dt>
	<dd>Basic silver finish</dd>
<dt><code>Metallic_Finish</code></dt>
</dl>
<p>
Metal textures:
</p>
<dl>
<dt><code>Chrome_Metal, Brass_Metal, Bronze_Metal, Gold_Metal, Silver_Metal, Copper_Metal</code></dt>
	<dd>A series of metallic textures using the Metal finish (except for Chrome_Metal, which has a custom finish). There are identical textures ending in _Texture instead of _Metal, but use of those names is discouraged.</dd>
<dt><code>Polished_Chrome</code></dt>
	<dd>A highly reflective Chrome texture.</dd>
<dt><code>Polished_Brass</code></dt>
	<dd>A highly reflective brass texture.</dd>
<dt><code>New_Brass</code></dt>
	<dd>Beautiful military brass texture!</dd>
<dt><code>Spun_Brass</code></dt>
	<dd>Spun Brass texture for cymbals &amp; such</dd>
<dt><code>Brushed_Aluminum</code></dt>
	<dd>Brushed aluminum (brushed along X axis)</dd>
<dt><code>Silver1</code></dt>
<dt><code>Silver2</code></dt>
<dt><code>Silver3</code></dt>
<dt><code>Brass_Valley</code></dt>
	<dd>Sort of a <em>Black Hills Gold</em>, black, white, and orange specks or splotches.</dd>
<dt><code>Rust</code></dt>
<dt><code>Rusty_Iron</code></dt>
<dt><code>Soft_Silver</code></dt>
<dt><code>New_Penny</code></dt>
<dt><code>Tinny_Brass</code></dt>
<dt><code>Gold_Nugget</code></dt>
<dt><code>Aluminum</code></dt>
<dt><code>Bright_Bronze</code></dt>
</dl>
</div>
<a name="r3_8_1_1_29_6"></a>
<div class="content-level-h6" contains="Special textures" id="r3_8_1_1_29_6">
<h6>3.8.1.1.29.6 Special textures</h6>
<dl>
<dt><code>Candy_Cane</code></dt>
<dd>Red and white stripes - Looks best on a y axis Cylinder.</dd>
<dd>It <em>spirals</em> because it's gradient on two axis.</dd>
<dt><code>Peel</code></dt>
<dd>Orange and Clear stripes spiral around the texture to make an object look like it was <em>Peeled</em>. Now, you too can be M.C. Escher!</dd>
<dt><code>Y_Gradient</code></dt>
<dt><code>X_Gradient</code></dt>
<dt><code>M_Water</code></dt>
<dd>Wavy water material. Requires a sub-plane, and may require scaling to fit your scene.</dd>
<dd><p class="Warning"><strong>Warning:</strong> Water texture has been changed to M_Water material, see explanation in the <em>glass</em> section of this file.</p></dd>
<dt><code>Cork</code></dt>
<dt><code>Lightning_CMap1, Lightning1, and Lightning_CMap2, Lightning2</code></dt>
<dd>These are just lightning textures, they look like arcing electricity...earlier versions misspelled them as <em>Lightening</em>.</dd>
<dt><code>Starfield</code></dt>
<dd>A starfield texture by Jeff Burton</dd>
</dl>

</div>
<a name="r3_8_1_1_29_7"></a>
<div class="content-level-h6" contains="Texture and pattern macros" id="r3_8_1_1_29_7">
<h6>3.8.1.1.29.7 Texture and pattern macros</h6>
<p><code>Irregular_Bricks_Ptrn (Mortar Thickness, X-scaling, Variation, Roundness)</code>: This function pattern creates a pattern of bricks of varying lengths on the x-y plane. This can be useful in building walls that do not look like they were built by a computer. Note that mortar thickness between bricks can vary somewhat, too.</p>
<p>Parameters:</p>
<ul>
  <li><code>Mortar Thickness</code> = Thickness of the mortar (0-1).</li>
<li><code>X-scaling</code> = The scaling of the bricks (but not the mortar) in the x direction.</li>
<li><code>Variation</code> = The amount by which brick lengths will vary (0=none, 1=100%).</li>
<li><code>Roundness</code> = The roundness of the bricks (0.01=almost rectangular, 1=very round).</li>
</ul>

<p><code>Tiles_Ptrn()</code>: This macro creates a repeating box pattern on the x-y plane. It can be useful for creating grids. The cells shade continuously from the center to the edges.</p>
<p>Parameters: None.</p>

<p><code>Hex_Tiles_Ptrn()</code>: This macro creates a pattern that is a sort of cross between the hexagon pattern and a repeating box pattern. The hexagonal cells shade continuously from the center to the edges.</p>
<p>Parameters: None.</p>

<p><code>Star_Ptrn (Radius, Points, Skip)</code>: This macro creates a pattern that resembles a star. The pattern is in the x-y plane, centered around the origin.</p>
<p>Parameters:</p>
<ul>
	<li><code>Radius</code> = The radius of a circle drawn through the points of the star.</li>
	<li><code>Points</code> = The number of points on the star.</li>
	<li><code>Skip</code> = The number of points to skip when drawing lines between points to form the star. 
         A normal 5-pointed star skips 2 points. A Star of David also skips 2 points. Skip
         must be less than Points/2 and greater than 0. Integers are preferred but not
         required. Skipping 1 point makes a regular polygon with Points sides.</li>
	<li><code>Pigment</code> = The pigment to be applied to the star.</li>
	<li><code>Background</code> = The pigment to be applied to the background.</li>
</ul></div>

<a name="r3_8_1_1_30"></a>
<div class="content-level-h5" contains="Transforms.inc" id="r3_8_1_1_30">
<h5>3.8.1.1.30 Transforms.inc</h5>

<p>Several useful transformation macros. All these macros produce transformations, you can use them anywhere you can use scale, rotate, etc. The descriptions will assume you are working with an object, but the macros will work fine for textures, etc.</p>

<p><code>Shear_Trans(A, B, C)</code>: This macro reorients and deforms an object so its original XYZ axes point along A, B, and C, resulting in a shearing effect when the vectors are not perpendicular. You can also use vectors of different lengths to affect scaling, or use perpendicular vectors to reorient the object.</p>
<p>Parameters:</p>
<ul>
	<li><code>A, B, C</code> = Vectors representing the new XYZ axes for the transformation.</li>
</ul>

<p><code>Matrix_Trans(A, B, C, D)</code>: This macro provides a way to specify a matrix transform with 4 vectors. The effects are very similar to that of the Shear_Trans() macro, but the fourth parameter controls translation.</p>
<p>Parameters:</p>
<ul>
	<li><code>A, B, C, D</code> = Vectors for each row of the resulting matrix.</li>
</ul>
	
<p><code>Axial_Scale_Trans(Axis, Amt)</code>: A kind of directional scale, this macro will <em>stretch</em> an object along a specified axis.</p>
<p>Parameters:</p>
<ul>
 <li><code>Axis</code> = A vector indicating the direction to stretch along.</li>
 <li>Amt = The amount to stretch.</li>
</ul>
	
<p><code>Axis_Rotate_Trans(Axis, Angle)</code>: This is equivalent to the transformation done by the vaxis_rotate() function, it rotates around an arbitrary axis.</p>
<p>Parameters:</p>
<ul>
 <li><code>Axis</code> = A vector representing the axis to rotate around.</li>
 <li><code>Angle</code> = The amount to rotate by.</li>
</ul>
	
<p><code>Rotate_Around_Trans(Rotation, Point)</code>: Ordinary rotation operates around the origin, this macro rotates around a specific point.</p>
<p>Parameters:</p>
<ul>
 <li><code>Rotation</code> = The rotation vector, the same as the parameter to the rotate keyword.</li>
 <li><code>Point</code> = The point to rotate around.</li>
</ul>
	
<p><code>Reorient_Trans(Axis1, Axis2)</code>: This aligns <code>Axis1</code> to <code>Axis2</code> by rotating the object around a vector perpendicular to both axis1 and axis2.</p>
<p>Parameters:</p>
<ul>
	<li><code>Axis1</code> = Vector to be rotated.</li>
	<li><code>Axis2</code> = Vectors to be rotated towards.</li>
</ul>
	
<p><code>Point_At_Trans(YAxis)</code>: This macro is similar to Reorient_Trans(), but it points the y axis along Axis.</p>
<p>Parameters:</p>
<ul>
 <li><code>YAxis</code> = The direction to point the y axis in.</li>
</ul>
	
<p><code>Center_Trans(Object, Axis)</code>: Calculates a transformation which will center an object along a specified axis. You indicate the axes you want to center along by adding &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; together in the Axis parameter.</p>
<p class="Note"><strong>Note:</strong> This macro actually computes the transform to center the bounding box of the object, which may not be entirely accurate. There is no way to define the <em>center</em> of an arbitrary object.</p>
<p>Parameters:</p>
<ul>
	<li><code>Object</code> = The object the center transform is being computed for.</li>
	<li><code>Axis</code> = The axes to center the object on.</li>
</ul>

<p>Usage:</p>
<pre>
object {MyObj Center_Trans(MyObj, x)} //center along x axis
</pre>
<p> You can also center along multiple axes:</p>
<pre>
object {MyObj Center_Trans(MyObj, x+y)} //center along x and y axis
</pre>
	
<p><code>Align_Trans(Object, Axis, Pt)</code>: Calculates a transformation which will align the sides of the bounding box of an object to a point. Negative values on Axis will align to the sides facing the negative ends of the coordinate system, positive values will align to the opposite sides, 0 means not to do any alignment on that axis.</p>
<p>Parameters:</p>
<ul>
	<li><code>Object</code> = The object being aligned.</li>
	<li><code>Axis</code> = A combination of +x, +y, +z, -x, -y, and -z, or a vector where each component is -1, 0, or +1 specifying the faces of the bounding box to align to the point.</li>
	<li><code>Point</code> = The point to which to align the bounding box of the object.</li>
</ul>
<p>Usage:</p>
<pre>
object {
  MyObj 
  Align_Trans(MyObj, x, Pt) //Align right side of object to be
                            //coplanar with Pt
  Align_Trans(MyObj,-y, Pt) //Align bottom of object to be
                            // coplanar with Pt
  } 
</pre>

<p><code>vtransform(Vect, Trans)</code> and <code>vinv_transform(Vect, Trans)</code>: The <code>vtransform()</code> macro takes a transformation (rotate, scale, translate, etc...) and a point, and returns the result of applying the transformation to the point. The <code>vinv_transform()</code> macro is similar, but applies the inverse of the transform, in effect <em>undoing</em> the transformation. You can combine transformations by enclosing them in a transform block.</p>
<p>Parameters:</p>
<ul>
	<li><code>Vect</code> = The vector to which to apply the transformation.</li>
	<li><code>Trans</code> = The transformation to apply to Vect.</li>
</ul>

<p><code>Spline_Trans(Spline, Time, SkyVector, ForeSight, Banking)</code>: This macro aligns an object to a spline for a given time value. The Z axis of the object will point in the forward direction of the spline and the Y axis of the object will point upwards.</p>
<p>Parameters:</p>
<ul>
	<li><code>Spline</code> = The spline that the object is aligned to.</li>
	<li><code>Time</code> = The time value to feed to the spline, for example clock.</li>
	<li><code>Sky</code> = The vector that is upwards in your scene, usually y.</li>
	<li><code>Foresight</code> = A positive value that controls how much in advance the object will turn and bank. Values close to 0 will give precise results, while higher values give smoother results. It will not affect parsing speed, so just find the value that looks best.</li>
	<li><code>Banking</code> = How much the object tilts when turning. The amount of tilting is equally much controlled by the ForeSight value.</li>
</ul>
<p>Usage:</p>
<pre>
object {MyObj Spline_Trans(MySpline, clock, y, 0.1, 0.5)}
</pre></div>

<a name="r3_8_1_1_31"></a>
<div class="content-level-h5" contains="Woods.inc" id="r3_8_1_1_31">
<h5>3.8.1.1.31 Woods.inc</h5>

<p>The file woods.inc contains predefined wood textures and pigments.</p>

<p>The pigments are prefixed with P_, and do not have color_maps, allowing you to specify a color map from woodmaps.inc or create your own. There are two groups, &quot;A&quot; and &quot;B&quot;: the A series is designed to work better on the bottom texture layer, and the
B series is designed for the upper layers, with semitransparent color maps. The pigments with the same number were designed to work well together, but you do not necessarily have to use them that way.</p>

<p>The textures are prefixed with T_, and are ready to use. They are designed with the major axis of the woodgrain <em>cylinder</em> aligned along the Z axis. With the exception of the few of the textures which have a small amount of rotation built-in, the textures will exhibit a very straight grain pattern unless you apply a small amount of x-axis rotation to them (generally 2 to 4 degrees seems to work well).</p>

<p>Pigments:</p>
<dl>
<dt><code>P_WoodGrain1A, ..., P_WoodGrainA</code></dt>
<dt><code>P_WoodGrain1B, ..., P_WoodGrainB</code></dt>
</dl>

<p>Textures:</p>
<dl>
<dt><code>T_Wood1</code></dt>
<dd>Natural oak (light)</dd>
<dt><code>T_Wood2</code></dt>
<dd>Dark brown		</dd>
<dt><code>T_Wood3</code></dt>
<dd>Bleached oak (white)</dd>
<dt><code>T_Wood4</code></dt>
<dd>Mahogany (purplish-red)</dd>
<dt><code>T_Wood5</code></dt>
<dd>Dark yellow with reddish overgrain</dd>
<dt><code>T_Wood6</code></dt>
<dd>Cocabola (red)</dd>
<dt><code>T_Wood7</code></dt>
<dd>Yellow pine (ragged grain)</dd>
<dt><code>T_Wood8</code></dt>
<dd>Dark brown. Walnut?  </dd>
<dt><code>T_Wood9</code></dt>
<dd>Yellowish-brown burl (heavily turbulated)</dd>
<dt><code>T_Wood10</code></dt>
<dd>Soft pine (light yellow, smooth grain)</dd>
<dt><code>T_Wood11</code></dt>
<dd>Spruce (yellowish, very straight, fine grain)</dd>
<dt><code>T_Wood12</code></dt>
<dd>Another very dark brown.  Walnut-stained pine, perhaps?</dd>
<dt><code>T_Wood13</code></dt>
<dd>Very straight grained, whitish</dd>
<dt><code>T_Wood14</code></dt>
<dd>Red, rough grain</dd>
<dt><code>T_Wood15</code></dt>
<dd>Medium brown</dd>
<dt><code>T_Wood16</code></dt>
<dd>Medium brown</dd>
<dt><code>T_Wood17</code></dt>
<dd>Medium brown</dd>
<dt><code>T_Wood18</code></dt>
<dd>Orange</dd>
<dt><code>T_Wood19, ..., T_Wood30</code></dt>
<dd>Golden Oak.</dd>
<dt><code>T_Wood31</code></dt>
<dd>A light tan wood - heavily grained (variable coloration)</dd>
<dt><code>T_Wood32</code></dt>
<dd>A rich dark reddish wood, like rosewood, with smooth-flowing grain</dd>
<dt><code>T_Wood33</code></dt>
<dd>Similar to T_WoodB, but brighter</dd>
<dt><code>T_Wood34</code></dt>
<dd>Reddish-orange, large, smooth grain.</dd>
<dt><code>T_Wood35</code></dt>
<dd>Orangish, with a grain more like a veneer than a plank</dd>
</dl></div>

<a name="r3_8_1_1_32"></a>
<div class="content-level-h5" contains="Woodmaps.inc" id="r3_8_1_1_32">
<h5>3.8.1.1.32 Woodmaps.inc</h5>

<p>The file woodmaps.inc contains color_maps designed for use in wood textures. The M_WoodXA maps are intended to be used in the first layer of a multilayer texture, but can be used in single-layer textures. The M_WoodXB maps contain transparent areas, and are intended to be used in upper texture layers.</p>
<p>Color maps:</p>
<dl>
<dt><code>M_Wood1A, ..., M_Wood19A</code></dt>
<dt><code>M_Wood1B, ..., M_Wood19B</code></dt>
</dl></div>

<a name="r3_8_1_2"></a>
<div class="content-level-h4" contains="Old Files" id="r3_8_1_2">
<h4>3.8.1.2 Old Files</h4>
<p>These files could be considered either <em>obsolete</em> or <em>deprecated</em>. They have been included for <em>legacy</em> reasons.</p></div>

<a name="r3_8_1_2_1"></a>
<div class="content-level-h5" contains="Glass_old.inc" id="r3_8_1_2_1">
<h5>3.8.1.2.1 Glass_old.inc</h5>

<p>This file contains glass textures for POV-Ray versions 3.1 and earlier. 
These textures do not take advantage of the new features introduced with POV-Ray 3.5 and are
included for backwards compatability, you will get better results with the
materials in glass.inc.</p>
<p class="Note"><strong>Note:</strong> As of version 3.7 the definitions in <code>glass_old.inc</code> have been <code><a href="r3_3.html#r3_3_2_2_5">deprecated</a></code>. To suppress warnings generated from using these textures you should consider converting them to materials.</p>
<p>Using the following example:</p>
<pre>texture {T_Glass4} interior {I_Glass caustics 1}</pre>
<p>should be rewritten as:</p>
<pre>
material {
  texture {
    pigment { color rgbf &lt;0.98, 1.0, 0.99, 0.75&gt; }
    finish { F_Glass4 }
    }
  interior { I_Glass caustics 1 }
  }
</pre>  

</div>
<a name="r3_8_1_2_1_1"></a>
<div class="content-level-h6" contains="Glass finishes" id="r3_8_1_2_1_1">
<h6>3.8.1.2.1.1 Glass finishes</h6>
<p><code>F_Glass1, ..., F_Glass4</code></p>
</div>
<a name="r3_8_1_2_1_2"></a>
<div class="content-level-h6" contains="Glass textures" id="r3_8_1_2_1_2">
<h6>3.8.1.2.1.2 Glass textures</h6>
<dl>
<dt><code>T_Glass1</code></dt>
<dd>Simple clear glass.</dd>	
<dt><code>T_Glass2</code></dt>
<dd>More like an acrylic plastic.</dd>	
<dt><code>T_Glass3</code></dt>
<dd>An excellent lead crystal glass.</dd>	
<dt><code>T_Glass4</code></dt>	
<dt><code>T_Old_Glass</code></dt>	
<dt><code>T_Winebottle_Glass</code></dt>	
<dt><code>T_Beerbottle_Glass</code></dt>	
<dt><code>T_Ruby_Glass</code></dt>	
<dt><code>T_Green_Glass</code></dt>	
<dt><code>T_Dark_Green_Glass</code></dt>	
<dt><code>T_Yellow_Glass</code></dt>	
<dt><code>T_Orange_Glass</code></dt>
<dd>Orange/amber glass.</dd>	
<dt><code>T_Vicksbottle_Glass</code></dt>
</dl></div>

<a name="r3_8_1_2_2"></a>
<div class="content-level-h5" contains="Shapes_old.inc" id="r3_8_1_2_2">
<h5>3.8.1.2.2 Shapes_old.inc</h5>

<dl>
<dt><code>Ellipsoid, Sphere</code></dt>
	<dd>Unit-radius sphere at the origin.</dd>

<dt><code>Cylinder_X, Cylinder_Y, Cylinder_Z</code></dt>
	<dd>Infinite cylinders.</dd>

<dt><code>QCone_X, QCone_Y, QCone_Z</code></dt>
	<dd>Infinite cones.</dd>

<dt><code>Cone_X, Cone_Y, Cone_Z</code></dt>
	<dd>Closed capped cones: unit-radius at -1 and 0 radius at +1 along each axis.</dd>

<dt><code>Plane_YZ, Plane_XZ, Plane_XY</code></dt>
	<dd>Infinite planes passing through the origin.</dd>

<dt><code>Paraboloid_X, Paraboloid_Y, Paraboloid_Z</code></dt>
	<dd>y^2 + z^2 - x = 0</dd>

<dt><code>Hyperboloid, Hyperboloid_Y</code></dt>
	<dd>y - x^2 + z^2 = 0</dd>

<dt><code>UnitBox, Cube</code></dt>
	<dd>A cube 2 units on each side, centered on the origin.</dd>

<dt><code>Disk_X, Disk_Y, Disk_Z</code></dt>
	<dd><em>Capped</em> cylinders, with a radius of 1 unit and a length of 2 units, centered on the origin.</dd>
</dl></div>

<a name="r3_8_1_2_3"></a>
<div class="content-level-h5" contains="Stage1.inc" id="r3_8_1_2_3">
<h5>3.8.1.2.3 Stage1.inc</h5>

<p>This file simply contains a camera, a light_source, and a ground plane, and includes colors.inc, textures.inc, and shapes.inc.</p></div>

<a name="r3_8_1_2_4"></a>
<div class="content-level-h5" contains="Stdcam.inc" id="r3_8_1_2_4">
<h5>3.8.1.2.4 Stdcam.inc</h5>

<p>This file simply contains a camera, a light_source, and a ground plane.</p></div>

<a name="r3_8_1_2_5"></a>
<div class="content-level-h5" contains="Stones1.inc" id="r3_8_1_2_5">
<h5>3.8.1.2.5 Stones1.inc</h5>

<dl>
<dt><code>T_Grnt0</code></dt>
	<dd>Gray/Tan with Rose.</dd>
<dt><code>T_Grnt1</code></dt>
	<dd>Creamy Whites with Yellow &amp; Light Gray.</dd>
<dt><code>T_Grnt2</code></dt>
	<dd>Deep Cream with Light Rose, Yellow, Orchid, &amp; Tan.</dd>
<dt><code>T_Grnt3</code></dt>
	<dd>Warm tans olive &amp; light rose with cream.</dd>
<dt><code>T_Grnt4</code></dt>
	<dd>Orchid, Sand &amp; Mauve.</dd>
<dt><code>T_Grnt5</code></dt>
	<dd>Medium Mauve Med.Rose &amp; Deep Cream.</dd>
<dt><code>T_Grnt6</code></dt>
	<dd>Med. Orchid, Olive &amp; Dark Tan <em>mud pie</em>.</dd>
<dt><code>T_Grnt7</code></dt>
	<dd>Dark Orchid, Olive &amp; Dark Putty.</dd>
<dt><code>T_Grnt8</code></dt>
	<dd>Rose &amp; Light Cream Yellows</dd>
<dt><code>T_Grnt9</code></dt>
	<dd>Light Steely Grays</dd>
<dt><code>T_Grnt10</code></dt>
	<dd>Gray Creams &amp; Lavender Tans</dd>
<dt><code>T_Grnt11</code></dt>
	<dd>Creams &amp; Grays Kahki</dd>
<dt><code>T_Grnt12</code></dt>
	<dd>Tan Cream &amp; Red Rose</dd>
<dt><code>T_Grnt13</code></dt>
	<dd>Cream Rose Orange</dd>
<dt><code>T_Grnt14</code></dt>
	<dd>Cream Rose &amp; Light Moss w/Light Violet</dd>
<dt><code>T_Grnt15</code></dt>
	<dd>Black with subtle chroma</dd>
<dt><code>T_Grnt16</code></dt>
	<dd>White Cream &amp; Peach</dd>
<dt><code>T_Grnt17</code></dt>
	<dd>Bug Juice &amp; Green</dd>
<dt><code>T_Grnt18</code></dt>
	<dd>Rose &amp; Creamy Yellow</dd>
<dt><code>T_Grnt19</code></dt>
	<dd>Gray Marble with White feather Viens</dd>
<dt><code>T_Grnt20</code></dt>
	<dd>White Marble with Gray feather Viens</dd>
<dt><code>T_Grnt21</code></dt>
	<dd>Green Jade</dd>
<dt><code>T_Grnt22</code></dt>
	<dd>Clear with White feather Viens (has some transparency)</dd>
<dt><code>T_Grnt23</code></dt>
	<dd>Light Tan to Mauve</dd>
<dt><code>T_Grnt24</code></dt>
	<dd>Light Grays</dd>
<dt><code>T_Grnt25</code></dt>
	<dd>Moss Greens &amp; Tan</dd>
<dt><code>T_Grnt26</code></dt>
	<dd>Salmon with thin Green Viens</dd>
<dt><code>T_Grnt27</code></dt>
	<dd>Dark Green &amp; Browns</dd>
<dt><code>T_Grnt28</code></dt>
	<dd>Red Swirl</dd>
<dt><code>T_Grnt29</code></dt>
	<dd>White, Tan, w/ thin Red Viens</dd>
</dl>
<dl>
<dt><code>T_Grnt0a</code></dt>
	<dd>Translucent T_Grnt0</dd>
<dt><code>T_Grnt1a</code></dt>
	<dd>Translucent T_Grnt1</dd>
<dt><code>T_Grnt2a</code></dt>
	<dd>Translucent T_Grnt2</dd>
<dt><code>T_Grnt3a</code></dt>
	<dd>Translucent T_Grnt3</dd>
<dt><code>T_Grnt4a</code></dt>
	<dd>Translucent T_Grnt4</dd>
<dt><code>T_Grnt5a</code></dt>
	<dd>Translucent T_Grnt5</dd>
<dt><code>T_Grnt6a</code></dt>
	<dd>Translucent T_Grnt6</dd>
<dt><code>T_Grnt7a</code></dt>
	<dd>Translucent T_Grnt7</dd>
<dt><code>T_Grnt8a</code></dt>
	<dd>Aqua Tints</dd>
<dt><code>T_Grnt9a</code></dt>
	<dd>Transmit Creams With Cracks</dd>
<dt><code>T_Grnt10a</code></dt>
	<dd>Transmit Cream Rose &amp; light yellow</dd>
<dt><code>T_Grnt11a</code></dt>
	<dd>Transmit Light Grays</dd>
<dt><code>T_Grnt12a</code></dt>
	<dd>Transmit Creams &amp; Tans</dd>
<dt><code>T_Grnt13a</code></dt>
	<dd>Transmit Creams &amp; Grays</dd>
<dt><code>T_Grnt14a</code></dt>
	<dd>Cream Rose &amp; light moss</dd>
<dt><code>T_Grnt15a</code></dt>
	<dd>Transmit Sand &amp; light Orange</dd>
<dt><code>T_Grnt16a</code></dt>
	<dd>Cream Rose &amp; light moss (again?)</dd>
<dt><code>T_Grnt17a</code></dt>
	<dd>???</dd>
<dt><code>T_Grnt18a</code></dt>
	<dd>???</dd>
<dt><code>T_Grnt19a</code></dt>
	<dd>Gray Marble with White feather Viens with Transmit</dd>
<dt><code>T_Grnt20a</code></dt>
	<dd>White Feather Viens</dd>
<dt><code>T_Grnt21a</code></dt>
	<dd>Thin White Feather Viens</dd>
<dt><code>T_Grnt22a</code></dt>
	<dd>???</dd>
<dt><code>T_Grnt23a</code></dt>
	<dd>Transparent Green Moss</dd>
<dt><code>T_Grnt24a</code></dt>
	<dd>???</dd>
</dl>
<dl>
<dt><code>T_Crack1</code></dt>
	<dd>T_Crack &amp; Red Overtint</dd>
<dt><code>T_Crack2</code></dt>
	<dd>Translucent Dark T_Cracks</dd>
<dt><code>T_Crack3</code></dt>
	<dd>Overtint Green w/ Black T_Cracks</dd>
<dt><code>T_Crack4</code></dt>
	<dd>Overtint w/ White T_Crack</dd>
</dl>
<p>The StoneXX textures are the complete textures, ready to use.</p>
<dl>
<dt><code>T_Stone1</code></dt>
	<dd>Deep Rose &amp; Green Marble with large White Swirls</dd>
<dt><code>T_Stone2</code></dt>
	<dd>Light Greenish Tan Marble with Agate style veining</dd>
<dt><code>T_Stone3</code></dt>
	<dd>Rose &amp; Yellow Marble with fog white veining</dd>
<dt><code>T_Stone4</code></dt>
	<dd>Tan Marble with Rose patches</dd>
<dt><code>T_Stone5</code></dt>
	<dd>White Cream Marble with Pink veining</dd>
<dt><code>T_Stone6</code></dt>
	<dd>Rose &amp; Yellow Cream Marble</dd>
<dt><code>T_Stone7</code></dt>
	<dd>Light Coffee Marble with darker patches</dd>
<dt><code>T_Stone8</code></dt>
	<dd>Gray Granite with white patches</dd>
<dt><code>T_Stone9</code></dt>
	<dd>White &amp; Light Blue Marble with light violets</dd>
<dt><code>T_Stone10</code></dt>
	<dd>Dark Brown &amp; Tan swirl Granite with gray undertones</dd>
<dt><code>T_Stone11</code></dt>
	<dd>Rose &amp; White Marble with dark tan swirl</dd>
<dt><code>T_Stone12</code></dt>
	<dd>White &amp; Pinkish Tan Marble</dd>
<dt><code>T_Stone13</code></dt>
	<dd>Medium Gray Blue Marble</dd>
<dt><code>T_Stone14</code></dt>
	<dd>Tan &amp; Olive Marble with gray white veins</dd>
<dt><code>T_Stone15</code></dt>
	<dd>Deep Gray Marble with white veining</dd>
<dt><code>T_Stone16</code></dt>
	<dd>Peach &amp; Yellow Marble with white veining</dd>
<dt><code>T_Stone17</code></dt>
	<dd>White Marble with gray veining</dd>
<dt><code>T_Stone18</code></dt>
	<dd>Green Jade with white veining</dd>
<dt><code>T_Stone19</code></dt>
	<dd>Peach Granite with white patches &amp; green trim</dd>
<dt><code>T_Stone20</code></dt>
	<dd>Brown &amp; Olive Marble with white veining</dd>
<dt><code>T_Stone21</code></dt>
	<dd>Red Marble with gray &amp; white veining</dd>
<dt><code>T_Stone22</code></dt>
<dd>Dark Tan Marble with gray &amp; white veining</dd>
<dt><code>T_Stone23</code></dt>
<dd>Peach &amp; Cream Marble with orange veining</dd>
<dt><code>T_Stone24</code></dt>
	<dd>Green &amp; Tan Moss Marble</dd>
</dl></div>

<a name="r3_8_1_2_6"></a>
<div class="content-level-h5" contains="Stones2.inc" id="r3_8_1_2_6">
<h5>3.8.1.2.6 Stones2.inc</h5>

<p><code>T_Stone25, ..., T_Stone44</code>
</p></div>

<a name="r3_8_1_3"></a>
<div class="content-level-h4" contains="Other Files" id="r3_8_1_3">
<h4>3.8.1.3 Other Files</h4>
<p>There are various other files in the include files collection. For example font files, color maps, and images for use in height fields or image maps.</p></div>

<a name="r3_8_1_3_1"></a>
<div class="content-level-h5" contains="Font Files" id="r3_8_1_3_1">
<h5>3.8.1.3.1 Font Files</h5>
<p>The fonts cyrvetic.ttf and timrom.ttf were donated to the POV-Team by their creator, Ted Harrison (CompuServe:70220,344) and were built using his FontLab for Windows by SoftUnion, Ltd. of St. Petersburg, Russia.</p>
<p>The font crystal.ttf was donated courtesy of	Jerry Fitzpatrick, Red Mountain Corporation, redmtn [at] ix.netcom.com</p>
<p>The font povlogo.ttf is created by Fabien Mosen and based on the POV-Ray logo design by Chris Colefax.</p>
<dl>
<dt><code>crystal.ttf</code></dt>
<dd>A fixed space programmer's font.</dd>
<dt><code>cyrvetic.ttf</code></dt>
<dd>A proportional spaces sans-serif font.</dd>
<dt><code>timrom.ttf</code></dt>
<dd>A proportional spaces serif font.</dd>
<dt><code>povlogo.ttf</code></dt>
<dd>Only contains the POV-Ray logo.</dd>
</dl>
<p class="Note"><strong>Note:</strong> In version 3.7 these fonts were <em>built-in</em> to the application. See the <code><a href="r3_5.html#r3_5_1_1_17">text</a></code> object for more details.</p></div>

<a name="r3_8_1_3_2"></a>
<div class="content-level-h5" contains="Color Map Files" id="r3_8_1_3_2">
<h5>3.8.1.3.2 Color Map Files</h5>
<p>These are 255-color color_maps, and are in individual files because of their size.</p>
<dl>
<dt><code>ash.map</code></dt>
<dt><code>benediti.map</code></dt>
<dt><code>bubinga.map</code></dt>
<dt><code>cedar.map</code></dt>
<dt><code>marbteal.map</code></dt>
<dt><code>orngwood.map</code></dt>
<dt><code>pinkmarb.map</code></dt>
<dt><code>rdgranit.map</code></dt>
<dt><code>teak.map</code></dt>
<dt><code>whiteash.map</code></dt>
</dl></div>

<a name="r3_8_1_3_3"></a>
<div class="content-level-h5" contains="Image Files" id="r3_8_1_3_3">
<h5>3.8.1.3.3 Image Files</h5>
<dl>
<dt><code>bumpmap_.png</code></dt>
<dd>A color mandelbrot fractal image, presumably intended for use as a bumpmap.</dd>
<dt><code>fract003.png</code></dt>
<dd>Some kind of fractal landscape, with color for blue water, brown land, and white peaks.</dd>
<dt><code>maze.png</code></dt>
<dd>A maze.</dd>
<dt><code>mtmand.pot</code></dt>
<dd>A grayscale mandelbrot fractal.</dd>
<dt><code>mtmandj.png</code></dt>
<dd>A 2D color julia fractal.</dd>
<dt><code>plasma2.png, plasma3.png</code></dt>
<dd><em>Plasma fractal</em> images, mainly useful for landscape height fields. The file plasma3.png 
is a smoother version of plasma2.png, plasma1.png does not exist.</dd>
<dt><code>povmap.png</code></dt>
<dd>The text &quot;Persistance of Vision&quot; in green on a blue background, framed in black and red.</dd>
<dt><code>test.png</code></dt>
<dd>A <em>test image</em>, the image is divided into 4 areas of different colors (magenta, yellow, 
cyan, red) with black text on them, and the text &quot;POV-Ray&quot; is centered on the image in white.</dd>
<dt><code>spiral.df3</code></dt>
<dd>A 3D bitmap density file. A spiral, <em>galaxy</em> shape.</dd>
</dl></div>

</div>

</div>
</body>
</html>
